<?xml version="1.0"?>
<doc>
    <assembly>
        <name>SEIDR</name>
    </assembly>
    <members>
        <member name="M:SEIDR.BaseExtensions.GetDescription(System.Reflection.MemberInfo)">
            <summary>
            Gets the description of the specified MemberInfo, the name of the MemberInfo if no Description attribute has been specified.
            </summary>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.BaseExtensions.GetDescription(System.Enum)">
            <summary>
            Tries to get the enum's description, or the name of the value if no description specified
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.BaseExtensions.In(System.String,System.StringComparison,System.String[])">
            <summary>
            Return true if the test variable matches any element of <paramref name="compareTo"/>, using string comparison options specified by <paramref name="comparison"/>
            </summary>
            <param name="test"></param>
            <param name="comparison"></param>
            <param name="compareTo"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.BaseExtensions.In(System.String,System.StringComparison,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Return true if the test variable matches any element of <paramref name="compareTo"/>, using string comparison options specified by <paramref name="comparison"/>
            </summary>
            <param name="test"></param>
            <param name="comparison"></param>
            <param name="compareTo"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.BaseExtensions.MapInheritance``2(``1,``0,System.Boolean)">
            <summary>
            Map properties of map to the inheriting class instance, IT
            </summary>
            <typeparam name="RT"></typeparam>
            <typeparam name="IT">Inheriting type</typeparam>
            <param name="inheritor">Object to map properties onto. If null and <paramref name="map"/> is not null, a new object will  be created and returned.</param>
            <param name="map">Object to map properties from. If null, <paramref name="inheritor"/> will be returned as-is.</param>
            <param name="cache">Cache the property info if the mapping for these class types are going to be done often.</param>
            <returns>REturns the inheritor for method chaining</returns>
        </member>
        <member name="M:SEIDR.BaseExtensions.Map(System.Object,System.Object,System.Collections.Generic.Dictionary{System.String,System.Reflection.PropertyInfo},System.Collections.Generic.List{System.Reflection.PropertyInfo})">
            <summary>
            Maps properties from the map to target. 
            </summary>
            <param name="target"></param>
            <param name="map"></param>
            <param name="propertiesToWrite"></param>
            <param name="propertiesToMap"></param>
        </member>
        <member name="M:SEIDR.BaseExtensions.NullifyStringProperties(System.Object)">
            <summary>
            For any string properties on the object, set them to null if they're white space or empty
            </summary>
            <param name="j"></param>
        </member>
        <member name="M:SEIDR.BaseExtensions.DeNullifyStrings(System.Object)">
            <summary>
            For any readable and writable string properties on the object, check if they're null. If so, set them to be an empty string instead
            </summary>
            <param name="j"></param>
        </member>
        <member name="M:SEIDR.BaseExtensions.nLength(System.String)">
            <summary>
            Returns the length of the string, or -1 if null.
            </summary>
            <param name="check"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.BaseExtensions.SplitOnString(System.String,System.String)">
            <summary>
            Splits the string on the split string instead of
            </summary>
            <param name="check"></param>
            <param name="split"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.BaseExtensions.Matches``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{``0})">
            <summary>
            Compares each sequence of list left with the corresponding entry in right using <see cref="M:System.Object.Equals(System.Object)"/>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.BaseExtensions.IsSuperSet``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Checks that every item of the sublist is contained in the main list
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="subList"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.BaseExtensions.IsSubset``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Checks if the list is a super set of sublist
            </summary>
            <typeparam name="T"></typeparam>
            <param name="subList"></param>
            <param name="list"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.BaseExtensions.IsSetEquivalent``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Checks if every item in list is contained by list2 and if every item contained by list 2 is contained by list.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="list2"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.BaseExtensions.Union``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Boolean)">
            <summary>
            Unions the enumerables and returns an IList
            </summary>
            <typeparam name="T"></typeparam>
            <param name="left"></param>
            <param name="right"></param>
            <param name="distinct">If true, will only add items from right to left if they are not already contained in left</param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.BaseExtensions.InsertWithExpansion``1(System.Collections.Generic.List{``0},System.Int32,``0,``0)">
            <summary>
            Inserts a value at the specified index by calling <see cref="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)"/>. If the list does not have enough records, it will have the missing indexes filled by <paramref name="filler"/>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="toFill"></param>
            <param name="index"></param>
            <param name="value"></param>
            <param name="filler"></param>
        </member>
        <member name="M:SEIDR.BaseExtensions.SetWithExpansion``1(System.Collections.Generic.List{``0},System.Int32,``0,``0)">
            <summary>
            Sets the value at the specified index by calling the indexer. If the list does not have enough records, it will have the missing indexes filled by <paramref name="filler"/>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="toFill"></param>
            <param name="index"></param>
            <param name="value"></param>
            <param name="filler"></param>
        </member>
        <member name="M:SEIDR.BaseExtensions.ntLength(System.String)">
            <summary>
            Returns the length of the trimmed string, or -1 if null
            </summary>
            <param name="check"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.BaseExtensions.nTrim(System.String)">
            <summary>
            Null safe version of Trim.
            <para>
            Returns an empty string if null.
            </para>
            </summary>
            <param name="check"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.BaseExtensions.nTrim(System.String,System.Boolean)">
            <summary>
            Null safe version of Trim.
            <para>
            If nullify is true, returns null instead of an empty string.
            </para>
            Else acts the same as nTrim with no boolean
            </summary>
            <param name="check"></param>
            <param name="nullify"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.BaseExtensions.nString(System.String)">
            <summary>
            Returns null if the trimmed string is empty.
            <para>
            Otherwise, returns the string
            </para>
            </summary>
            <param name="check"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.BaseExtensions.Like(System.String,System.String,System.Boolean)">
            <summary>
            Check if string a is like string b
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <param name="escapeRegularExpressions">If set to false, will allow making use of regular expressions included in string a or b for doing the comparison..</param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.BaseExtensions.Include``1(System.Collections.Generic.IEnumerable{``0},``0[])">
            <summary>
            Returns a new IEnumerable including the new record(s) via a union
            </summary>
            <typeparam name="T"></typeparam>
            <param name="source"></param>
            <param name="toInclude"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.BaseExtensions.FirstMatch(System.Collections.Generic.IEnumerable{System.String},System.String,System.Boolean)">
            <summary>
            Gets the first match from the list that matches the LIKE expression
            </summary>
            <param name="list"></param>
            <param name="LIKE"></param>
            <param name="EscapeRegex"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.BaseExtensions.LastMatch(System.Collections.Generic.IEnumerable{System.String},System.String,System.Boolean)">
            <summary>
            Returns the last match from the list that matches the LIKE expression
            </summary>
            <param name="list"></param>
            <param name="LIKE"></param>
            <param name="escapeRegularExpressions"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.BaseExtensions.AllMatches(System.Collections.Generic.IEnumerable{System.String},System.String,System.Boolean)">
            <summary>
            Alias for <see cref="M:SEIDR.BaseExtensions.Like(System.Collections.Generic.IEnumerable{System.String},System.String,System.Boolean)"/>
            </summary>
            <param name="list"></param>
            <param name="LIKE"></param>
            <param name="escapeRegularExpressions"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.BaseExtensions.Like(System.Collections.Generic.IEnumerable{System.String},System.String,System.Boolean)">
            <summary>
            Returns an IEnumerable containing only the strings that are 'Like' b
             </summary>              
        </member>
        <member name="M:SEIDR.BaseExtensions.TakeSubset``1(System.Collections.Generic.IList{``0},System.Predicate{``0})">
            <summary>
            Takes a subset of the ordered list and returns a new IList containing the values that match the selector
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="selector"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.BaseExtensions.MinOfComparison(System.Int32,System.Int32)">
            <summary>
            Returns the minimal value of the two parameters.
            </summary>
            <param name="left"></param>
            <param name="compare"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.BaseExtensions.MinOfComparison(System.Int32,System.Int32[])">
            <summary>
            Gets the minimal value of all the parameters.
            </summary>
            <param name="left"></param>
            <param name="compare"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.BaseExtensions.MaxOfComparison(System.Int32,System.Int32)">
            <summary>
            Returns the maximum value of the parameters
            </summary>
            <param name="left"></param>
            <param name="compare"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.BaseExtensions.MaxOfComparison(System.Int32,System.Int32[])">
            <summary>
            Returns the maximum value of all the parameters
            </summary>
            <param name="left"></param>
            <param name="compare"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.BaseExtensions.AddRangeLimited``1(System.Collections.Generic.List{``0},System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            Adds the range to the list. 
            <para>If the range would increase the count above the limit, then will only insert part of the range
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="aList"></param>
            <param name="range"></param>
            <param name="limit"></param>
        </member>
        <member name="M:SEIDR.BaseExtensions.AddRange``1(System.Collections.Generic.List{``0},``0[])">
            <summary>
            Add list of T objects to the end of List
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="toAdd"></param>
        </member>
        <member name="M:SEIDR.BaseExtensions.NotIn``1(``0,``0[])">
            <summary>
            Short circuit after finding a match to return false. Opposite of In
            </summary>
            <typeparam name="T"></typeparam>
            <param name="obj"></param>
            <param name="list"></param>
            <returns>True if the list does not contain obj. False if obj is found in the list.</returns>
        </member>
        <member name="M:SEIDR.BaseExtensions.Exists``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
            <summary>
            Checks that there is any record in <paramref name="list"/> that matches <paramref name="check"/>. Returns early on finding a match.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="check"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.BaseExtensions.ContainsAnySubstring(System.String,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Checks if the value contains any of the values to check matches on.
            </summary>
            <param name="value">Value to check. If value is null or empty, will return false immediately.</param>
            <param name="matches">Strings to check</param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.BaseExtensions.ContainsAnySubstring(System.String,System.StringComparison,System.String[])">
            <summary>
            Check if the string contains any of the strings to check, using String Comparison options specified.
            </summary>
            <param name="value"></param>
            <param name="options"></param>
            <param name="check"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.BaseExtensions.ContainsAnySubstring(System.String,System.String[])">
            <summary>
            Check if string is a substring, case sensitive. Use <see cref="M:SEIDR.BaseExtensions.ContainsAnySubstring(System.String,System.Boolean,System.String[])"/> to be able to specify Case Sensitive.
            </summary>
            <param name="value"></param>
            <param name="matches"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.BaseExtensions.SplitByKeyword(System.String,System.String,System.Boolean,System.Boolean)">
            <summary>
            Splits the string by a single keyword
            </summary>
            <param name="value"></param>
            <param name="KeyWord"></param>
            <param name="includeKeyword">Incldue the keyword in the resulting IEnumerable</param>
            <param name="IgnoreCase">If true, ignores the cases of value and KeyWord</param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.BaseExtensions.SplitByKeyword(System.String,System.Collections.Generic.IEnumerable{System.String},System.Boolean,System.Boolean)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <param name="KeyWords"></param>
            <param name="IncludeKeywords">If true, include the keywords in the Enumerable. If False, leave them out.</param>
            <param name="IgnoreCase">If true, ignores the cases of value and KeyWord</param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.BaseExtensions.IndexOfAny(System.String,System.Collections.Generic.IEnumerable{System.String},System.Int32,System.String@,System.Boolean)">
            <summary>
            First index of any of the keywords that occurs at or after start.
            <para>Returns -1 if no match found</para>
            </summary>
            <param name="value"></param>
            <param name="words"></param>
            <param name="start"></param>
            <param name="Chosen">The keyword that found the index</param>
            <param name="CaseInsensitive">Ignore case when doing comparison</param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.BaseExtensions.HasMinimumCount``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            Lazy check to make sure that an IEnumerable has at least <paramref name="minimum"/> records.
            <para>Empty IEnumerables will always return false.</para>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="minimum">Must be at least 1 to be useful - null/empty IEnumerables will always return false</param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.BaseExtensions.HasMinimumCount``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0},System.Int32)">
            <summary>
            Lazy check to make sure that an IEnumerable has at least <paramref name="minimum"/> records.
            <para>Empty IEnumerables will always return false.</para>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="condition"></param>
            <param name="minimum">Must be at least 1 to be useful - null/empty IEnumerables will always return false</param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.BaseExtensions.OrderedMap``2(System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Maps the dictionary to an ordered enumerable
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="K"></typeparam>
            <param name="dictionary"></param>
            <param name="orderSelection">Determines order that values are grabbed from the dictionary.<para>
            If a record does not exist as a key, the default of <typeparamref name="T"/> will be returned</para></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.BaseExtensions.MapInto``2(System.Collections.Generic.IList{``1},System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.IList{``0})">
            <summary>
            Maps the values into the dictionary to populate the value of the corresponding key by ordinal position
            </summary>
            <typeparam name="K"></typeparam>
            <typeparam name="T"></typeparam>
            <param name="Keys"></param>
            <param name="values"></param>
            <param name="destination"></param>
        </member>
        <member name="M:SEIDR.BaseExtensions.UnderMaximumCount``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            Lazy check to make sure that an IENumerable has less than <paramref name="maximum"/> records. (Returns immediately after confirming that we're above the count)
            <para>Empty IEnumerables will always return true.</para>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="maximum"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.BaseExtensions.UnderMaximumCount``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0},System.Int32)">
            <summary>
            Lazy check to make sure that an IENumerable has less than <paramref name="maximum"/> records. (Returns immediately after confirming that we're above the count)
            <para>Empty IEnumerables will always return true.</para>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="condition">Condition to filter options that contribute to the count being compared against maximum</param>
            <param name="maximum"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.BaseExtensions.NotExists``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
            <summary>
            Reverse from exists, but exits early on finding a match.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="check"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.BaseExtensions.AndNot(System.Boolean,System.Boolean)">
            <summary>
            returns true if a and not b. False A or true b will result in false
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.BaseExtensions.TransformEach``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``0})">
            <summary>
            Transforms each record of the enumerable and returns it as a new enumerable
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="func"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.BaseExtensions.ForEachIndex``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Int32},System.Int32,System.Int32)">
            <summary>
            Apply <paramref name="Update"/> to each item in <paramref name="list"/>. 
            <para>Passes an integer value starting at <paramref name="startIndex"/> to each record in the list. Value is incremented by <paramref name="Interval"/>each time <paramref name="Update"/> is called.
            </para> 
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="Update"></param>
            <param name="startIndex">Starting value for the indexes passed to the procedure</param>
            <param name="Interval">Interval that index value increases</param>
        </member>
        <member name="M:SEIDR.BaseExtensions.CrossApply``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean},System.Action{``0})">
            <summary>
            Takes an IEnumerable and applies method 'Apply' to every item that fits the predicate. Other items are excluded from the result.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="Predicate"></param>
            <param name="Apply"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.BaseExtensions.CrossApply``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean},System.Func{``0,System.Collections.Generic.IEnumerable{``0}})">
            <summary>
            Cross apply with an action that can return more records.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="Predicate"></param>
            <param name="Apply"></param>
            <returns>Returns results of calling apply on the list members that match Predicate</returns>
        </member>
        <member name="M:SEIDR.BaseExtensions.OuterApply``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean},System.Action{``0})">
            <summary>
            Takes an IEnumerable and applies method 'Apply' to every item that fits the predicate. Other items are left 'As-Is', but included in the result.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="Predicate"></param>
            <param name="Apply"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.BaseExtensions.OuterApply``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean},System.Func{``0,System.Collections.Generic.IEnumerable{``0}})">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="Predicate"></param>
            <param name="Apply"></param>
            <returns>List Members that don't match predicate combined with result of applying function to members that do match</returns>
        </member>
        <member name="T:SEIDR.BigValueFlag">
            <summary>
            Class for holding a very large number of flags somewhat like a zero based array of bools initialized to false
            </summary>
        </member>
        <member name="M:SEIDR.BigValueFlag.GetEnumerator">
            <summary>
            Enumerate through the flagged values
            <para>NOTE: Because of the way values are stored internally, this will probably not be in the same order that the values were flagged.</para>
            <para>Ex: See the debug console output of BigValueFlagTest's method 'BigValueFlagEnumeratorTest' from the Unit test project</para>
            <para>Values *will* be contiguous in chunks of 64, though. I.e., if 1 and 2 and 63 are flagged, 1 is always before 2 and 2 always before 63 in this method's output.</para>
            </summary>
            <returns></returns>
        </member>
        <member name="P:SEIDR.BigValueFlag.Item(System.UInt64)">
            <summary>
            Checks if a value has been flagged as true or false.<para>Set: flips/unflips the value.</para>
            </summary>
            <param name="check"></param>
            <returns></returns>
        </member>
        <member name="P:SEIDR.BigValueFlag.MaxFlagged">
            <summary>
            Gets the largest flag value, or null if nothing is flagged
            </summary>
        </member>
        <member name="P:SEIDR.BigValueFlag.MinFlagged">
            <summary>
            Gets the minimum value that has been flagged, or null if nothing is flagged
            </summary>
        </member>
        <member name="P:SEIDR.BigValueFlag.Count">
            <summary>
            Returns the number of flagged (true) records. Will not overflow
            </summary>
        </member>
        <member name="P:SEIDR.BigValueFlag.BigCount">
            <summary>
            Returns the number of flagged (true) records
            </summary>
        </member>
        <member name="M:SEIDR.BigValueFlag.Clear">
            <summary>
            Resets all values to false.
            </summary>
        </member>
        <member name="F:SEIDR.DataBase.DatabaseManagerExtensions.CheckOutput">
            <summary>
            Flag Parameter direction to determine if the value needs to be checked after execution. Note: InputOutput is Input|Output
            </summary>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseManagerExtensions.GetMappedName(System.Reflection.PropertyInfo)">
            <summary>
            Returns the mapped name (by FieldMapping attribute), or the property's actual name if there is no populated mapping.
            </summary>
            <param name="prop"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseManagerExtensions.GetGetters(System.Type)">
            <summary>
            Returns a dictionary of the mapped property names and their getMethods
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseManagerExtensions.MappingIgnored(System.Reflection.PropertyInfo,System.Boolean)">
            <summary>
            Checks if the property should be ignored by the DatabaseManager when working with SqlParameters
            </summary>
            <param name="prop"></param>
            <param name="forOutParameter">Ignores the mapping only when checking Out Parameters for their updated values</param>
            <returns></returns>
        </member>
        <member name="T:SEIDR.DataBase.DatabaseManagerIgnoreMappingAttribute">
            <summary>
            Tells the DatabaseManager to ignore a mapping. Should only be used if there's a default value
            </summary>
        </member>
        <member name="P:SEIDR.DataBase.DatabaseManagerIgnoreMappingAttribute.IgnoreSet">
            <summary>
            Ignore setting the value in parameters when populating the SqlCommand's parameters if the direction to ignore is either <see cref="F:System.Data.ParameterDirection.Input"/> or <see cref="F:System.Data.ParameterDirection.InputOutput"/>
            </summary>
        </member>
        <member name="P:SEIDR.DataBase.DatabaseManagerIgnoreMappingAttribute.IgnoreReadOut">
            <summary>
            Ignore reading the output parameters of the SqlCommand after execution if the direction to ignore is <see cref="F:System.Data.ParameterDirection.InputOutput"/>, <see cref="F:System.Data.ParameterDirection.Output"/>, or <see cref="F:System.Data.ParameterDirection.ReturnValue"/>
            </summary>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseManagerIgnoreMappingAttribute.#ctor(System.Data.ParameterDirection)">
            <summary>
            Tells DatabaseManager to ignore the parameter for the specified direction
            </summary>
            <param name="directionToIgnore"></param>
        </member>
        <member name="T:SEIDR.DataBase.DatabaseManagerFieldMappingAttribute">
            <summary>
            Changes the name for properties by the DatabaseManager when doing any mappings from/to objects
            </summary>
        </member>
        <member name="F:SEIDR.DataBase.DatabaseManagerFieldMappingAttribute.MappedName">
            <summary>
            Name to be used by DatabaseManagers
            </summary>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseManagerFieldMappingAttribute.#ctor(System.String)">
            <summary>
            Maps the property to a different name for use in DatabaseManager mappings
            </summary>
            <param name="Map">Name to use. Note: This value will be trimmed and set to null if empty. If a property should be ignored in mapping, use the DatabaseManagerIgnoreMapping attribute</param>
        </member>
        <member name="T:SEIDR.DataBase.DatabaseManagerHelperModel">
            <summary>
            Disposable helper class for use with DatabaseManager
            </summary>
        </member>
        <member name="P:SEIDR.DataBase.DatabaseManagerHelperModel.CommandTimeout">
            <summary>
            Command timeout for procedure calls. If null (or less than 0), will use <see cref="P:SEIDR.DataBase.DatabaseConnection.CommandTimeout"/>
            </summary>
        </member>
        <member name="P:SEIDR.DataBase.DatabaseManagerHelperModel.DefaultRetryOnDeadlock">
            <summary>
            Default value for <see cref="P:SEIDR.DataBase.DatabaseManagerHelperModel.RetryOnDeadlock"/> when creating new HelperModels
            </summary>
        </member>
        <member name="P:SEIDR.DataBase.DatabaseManagerHelperModel.RetryOnDeadlock">
            <summary>
            If the DatabaseManager executes the HelperModel and the error code is a deadlock, will try to rerun.
            </summary>
        </member>
        <member name="P:SEIDR.DataBase.DatabaseManagerHelperModel.DeadlockRetryLimit">
            <summary>
            Limit to the number of times the helper can be deadlocked. If less than 0, no limit.
            </summary>
        </member>
        <member name="P:SEIDR.DataBase.DatabaseManagerHelperModel.DoMapUpdate">
            <summary>
            Update the map object after execution.
            </summary>
        </member>
        <member name="P:SEIDR.DataBase.DatabaseManagerHelperModel.HasDeadlockLimit">
            <summary>
            Checks whether or not there's a limit to the number of times the helper can retry after deadlock
            </summary>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseManagerHelperModel.ResetDeadlockLimit(System.Boolean)">
            <summary>
            Resets DeadlockLimit to default.        
            </summary>
            <param name="canAddLimit">If true, allows setting the deadlock limit back to the default even if the limit has been removed</param>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseManagerHelperModel.RemoveDeadlockLimit">
            <summary>
            Removes the deadlock limit.
            </summary>
        </member>
        <member name="P:SEIDR.DataBase.DatabaseManagerHelperModel.RethrowException">
            <summary>
            Provide a value to override the value from DatabaseManager
            </summary>
        </member>
        <member name="P:SEIDR.DataBase.DatabaseManagerHelperModel.Savepoint">
            <summary>
            Set when calling <see cref="M:SEIDR.DataBase.DatabaseManagerHelperModel.SaveTran(System.String)"/>. Used when the DatabaseManager has to rollback.
            </summary>
        </member>
        <member name="P:SEIDR.DataBase.DatabaseManagerHelperModel.Connection">
            <summary>
            Allow maintaining a SQL Connection across commands until the HelperModel is disposed
            </summary>
        </member>
        <member name="P:SEIDR.DataBase.DatabaseManagerHelperModel.ReturnValue">
            <summary>
            The return value from executing a stored procedure using this helper model instance
            </summary>
        </member>
        <member name="P:SEIDR.DataBase.DatabaseManagerHelperModel.ExpectedReturnValue">
            <summary>
            If a value is set - output parameters will not be updated if ReturnValue doesn't match.
            <para>If a transaction is open and the return value doesn't match, it will also rollback automatically</para>
            <para>Otherwise, does nothing, and will not cause any exception to be thrown.</para>
            </summary>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseManagerHelperModel.SetPropertyIgnore(System.String[])">
            <summary>
            Resets the list of Properties to ignore to be the provided string array
            </summary>
            <param name="PropertyList"></param>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseManagerHelperModel.ResetKeys(System.Collections.Generic.Dictionary{System.String,System.Object})">
            <summary>
            Removes existing parameter key/value pairs and sets it the provided Dictionary
            </summary>
            <param name="ParameterKeys">New value for extra parameter list... Null is okay</param>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseManagerHelperModel.AddDataRowAsKeys(System.Data.DataRow)">
            <summary>
            Converts a DataRow from a table to Parameter Key/values
            </summary>
            <param name="r"></param>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseManagerHelperModel.AddKey(System.String,System.Object)">
            <summary>
            Calls Dictionary Add on the underlying key dictionary
            </summary>
            <param name="Name"></param>
            <param name="value"></param>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseManagerHelperModel.RemoveKey(System.String)">
            <summary>
            Removes the key if it exists.
            </summary>
            <param name="Key"></param>
        </member>
        <member name="P:SEIDR.DataBase.DatabaseManagerHelperModel.QualifiedProcedure">
            <summary>
            Qualified procedure name, containing the schema + Procedure.
            <para>If Schema has not been set, dbo will be used.</para>
            </summary>
        </member>
        <member name="F:SEIDR.DataBase.DatabaseManagerHelperModel.ParameterMap">
            <summary>
            Contains readable properties that should be mapped to SQL parameters
            </summary>
        </member>
        <member name="P:SEIDR.DataBase.DatabaseManagerHelperModel.Schema">
            <summary>
            Allow overriding the Default Schema from the Database Connection manager. 
            <para>If null or empty, the Schema from DatabaseConnectionManager will be used, but dbo will be returned in 'QualifiedProcedure' property, if used separately
            </para>
            <para>Removes brackets and quotes, due to the way the manager uses it for schema</para>
            </summary>
        </member>
        <member name="P:SEIDR.DataBase.DatabaseManagerHelperModel.Procedure">
            <summary>
            Procedure to be called. Quotes will be removed and the string surrounded with brackets.
            </summary>
        </member>
        <member name="P:SEIDR.DataBase.DatabaseManagerHelperModel.PropertyIgnore">
            <summary>
            List of properties to ignore from the parameterMap (Ignored parameters will use the default value)
            </summary>
        </member>
        <member name="P:SEIDR.DataBase.DatabaseManagerHelperModel.Item(System.String)">
            <summary>
            Add/Get Key-Value pairs for SQL parameters - will override properties from <see cref="F:SEIDR.DataBase.DatabaseManagerHelperModel.ParameterMap"/>
            <para>Any new keys will also be added to <see cref="P:SEIDR.DataBase.DatabaseManagerHelperModel.PropertyIgnore"/></para>
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="P:SEIDR.DataBase.DatabaseManagerHelperModel.Parameters">
            <summary>
            Parameter information used when the helper is passed to a DatabaseManager to execute.<para>
            If a key in this dictionary is also a property on <see cref="F:SEIDR.DataBase.DatabaseManagerHelperModel.ParameterMap"/>, it will be ignored
            unless the property's name is in <see cref="P:SEIDR.DataBase.DatabaseManagerHelperModel.PropertyIgnore"/>
            </para>
            </summary>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseManagerHelperModel.SetConnection(SEIDR.DataBase.DatabaseConnection)">
            <summary>
            Uses the DatabaseConnection object to override the current connection.
            </summary>
            <param name="db"></param>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseManagerHelperModel.SetConnection(SEIDR.DataBase.DatabaseManager)">
            <summary>
            Uses the Connection associated with the passed DatabaseManager to override the current connection.
            </summary>
            <param name="dm"></param>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseManagerHelperModel.OpenConnection">
            <summary>
            Opens the underlying connection.
            </summary>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseManagerHelperModel.OpenConnection(SEIDR.DataBase.DatabaseConnection)">
            <summary>
            Uses passed connection to update and then open the underlying connection.
            </summary>
            <param name="db"></param>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseManagerHelperModel.OpenConnection(SEIDR.DataBase.DatabaseManager)">
            <summary>
            Uses the connection of the passed database manager to update and then open the underlying connection.
            </summary>
            <param name="dm"></param>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseManagerHelperModel.BeginTran">
            <summary>
            Begins a transaction on the set connection
            </summary>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseManagerHelperModel.RollbackTran">
            <summary>
            Rolls back the transaction and then disposes it. Require open transaction/connection
            </summary>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseManagerHelperModel.RollbackTran(System.String)">
            <summary>
            Partially rolls back the transaction, to the save point. Does not dispose the transaction.
            <para>Requires an open transaction/connection</para>
            </summary>
            <param name="savePoint"></param>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseManagerHelperModel.SaveTran(System.String)">
            <summary>
            Saves the transaction to allow partial rollback.
            <para>Requires an open transaction/connection</para>
            </summary>
            <param name="savePoint"></param>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseManagerHelperModel.CommitTran">
            <summary>
            Commits the transaction and then disposes it. Requires open transaction/connection.
            </summary>
        </member>
        <member name="P:SEIDR.DataBase.DatabaseManagerHelperModel.HasOpenTran">
            <summary>
            Check if this object has an open transaction.
            </summary>
        </member>
        <member name="P:SEIDR.DataBase.DatabaseManagerHelperModel.IsRolledBack">
            <summary>
            If true, there's an open connection which had a Transaction started, but has since rolled back.
            <para>If the transaction was rolled back to a savepoint, you may need to set this back to false before passing the model to a DatabaseManager again.</para>
            </summary>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseManagerHelperModel.ClearConnection">
            <summary>
            Clear and dispose the underlying connection. If there is an open transaction, clears that first.
            </summary>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseManagerHelperModel.ClearTran">
            <summary>
            Removes the transaction by calling dispose, if not null. Resets the IsRolledBack variable
            </summary>        
        </member>
        <member name="M:SEIDR.DataBase.DatabaseManagerHelperModel.Dispose">
            <summary>
            Dispose method dispose.
            </summary>
        </member>
        <member name="T:SEIDR.DataBase.DatabaseConnection">
            <summary>
            Wrapper class for managing a SQL server connection and running some common queries..
            </summary>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseConnection.FromString(System.String)">
            <summary>
            Construct an object using a connection string.
            </summary>
            <param name="connectionString"></param>
            <returns></returns>
        </member>
        <member name="P:SEIDR.DataBase.DatabaseConnection.Timeout">
            <summary>
            If the value is >= 0, will specify the timeout in the connection string.
            </summary>
        </member>
        <member name="F:SEIDR.DataBase.DatabaseConnection.DEFAULT_COMMAND_TIMEOUT">
            <summary>
            The default timeout for commands.
            </summary>
        </member>
        <member name="P:SEIDR.DataBase.DatabaseConnection.CommandTimeout">
            <summary>
            If value is >= 0, will set the Command timeout in SQL commands when run by this class's RunCommand. Default is -1 (Does not change the command timeout).
            <para>Outisde of the class, returns 30 if the internal value is &lt; 0</para>
            <para>NOTE: Not a part of the actual connection string.</para>
            </summary>
        </member>
        <member name="P:SEIDR.DataBase.DatabaseConnection.ApplicationName">
            <summary>
            Application Name for the connection. (E.g., seen when calling sp_who2)
            </summary>
        </member>
        <member name="F:SEIDR.DataBase.DatabaseConnection.DEFAULT_NAME">
            <summary>
            Default name for use in the connection manager
            </summary>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseConnection.#ctor">
            <summary>
            Constructor that does not set values.
            </summary>
        </member>
        <member name="F:SEIDR.DataBase.DatabaseConnection.DEFAULT_DBNAME">
            <summary>
            The database connected to if one is not specified
            </summary>
        </member>
        <member name="P:SEIDR.DataBase.DatabaseConnection.ReadOnlyIntent">
            <summary>
            Application Intent. Default to false (readwrite). Only modifies the final connection string when true.
            <para>https://stackoverflow.com/questions/15347541/what-does-applicationintent-readonly-mean-in-the-connection-string
            </para><para>May be useful if there's a readonly replica configured (or planned)</para>
            </summary>
        </member>
        <member name="P:SEIDR.DataBase.DatabaseConnection.ForceDataSource">
            <summary>
            Force referring to the server as 'Data Source' instead of Server
            </summary>
        </member>
        <member name="P:SEIDR.DataBase.DatabaseConnection.Password">
            <summary>
            Password for non trusted authentication. Must be set outside of constructor
            <para>Should probably only use for logins with limited access, e.g. a dev password with basically read only access or something</para>
            </summary>
        </member>
        <member name="P:SEIDR.DataBase.DatabaseConnection.UserName">
            <summary>
            Username for non trusted authentication. Must be set outside of constructor
            </summary>
        </member>
        <member name="P:SEIDR.DataBase.DatabaseConnection.useTrustedConnection">
            <summary>
            Gets whether or not the connection uses a UserName/Password to log in vs Windows authentication
            </summary>
        </member>
        <member name="P:SEIDR.DataBase.DatabaseConnection.Server">
            <summary>
            Gets or sets the SQL Server to connect to
            </summary>
        </member>
        <member name="P:SEIDR.DataBase.DatabaseConnection.Provider">
            <summary>
            If set, adds a Provider to the connection string
            </summary>
        </member>
        <member name="P:SEIDR.DataBase.DatabaseConnection.DefaultCatalog">
            <summary>
            Sets the Default database to connect to. If missing, will return string.Empty
            </summary>
        </member>
        <member name="P:SEIDR.DataBase.DatabaseConnection.IntegratedSecurity">
            <summary>
            If set, adds an IntegratedSecurity property to the connection string.
            </summary>
        </member>
        <member name="P:SEIDR.DataBase.DatabaseConnection.Encrypt">
            <summary>
            If true, adds Encrypt to the connection string. Default: false
            </summary>
        </member>
        <member name="P:SEIDR.DataBase.DatabaseConnection.Language">
            <summary>
            Optionally sets Language for the connection, for sys message results where applicable.
            </summary>
        </member>
        <member name="P:SEIDR.DataBase.DatabaseConnection.AutoTranslate">
            <summary>
            Adds Auto Translate to connection string
            </summary>
        </member>
        <member name="P:SEIDR.DataBase.DatabaseConnection.FailoverPartner">
            <summary>
            Specifies that there is a mirroring database that can be passed to the connection.
            </summary>
        </member>
        <member name="P:SEIDR.DataBase.DatabaseConnection.ConnectionString">
            <summary>
            Returns the connection string based on properties of this  object
            </summary>
        </member>
        <member name="P:SEIDR.DataBase.DatabaseConnection.IsValid">
            <summary>
            Returns whether the set up is valid - Connection string will not be returned if this is false
            </summary>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseConnection.RunCommand(System.Data.SqlClient.SqlCommand,System.Boolean)">
            <summary>
            Run the command with this Connection
            </summary>
            <param name="cmd"></param>
            <param name="Dispose">If true, dispose the sql command after getting results</param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseConnection.RunCommand(System.Data.SqlClient.SqlCommand,System.Data.SqlClient.SqlConnection,System.Boolean)">
            <summary>
            Runs the sql command on the passed sqlconnection. SQLConnection will be closed if it was unopened when passed. 
            <para>SQL Command will be disposed if <paramref name="Dispose"/> is true</para>
            </summary>
            <param name="cmd"></param>
            <param name="c"></param>
            <param name="Dispose"></param>
            <returns></returns>
        </member>
        <member name="T:SEIDR.DataBase.DatabaseExtensions">
            <summary>
            Extensions to System.Data objects
            </summary>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseExtensions.PullSchemaDoc(SEIDR.DataBase.DatabaseManager,System.String,System.String)">
            <summary>
            Uses a SELECT TOP 0 * to pull data set information into a DataTable (underlying a DataTableDoc)
            </summary>
            <param name="manager"></param>
            <param name="tableName"></param>
            <param name="Schema"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseExtensions.PullSchemaDoc(SEIDR.DataBase.DatabaseManager,System.String,System.Boolean,System.Boolean,System.String,System.Boolean)">
            <summary>
            Pull schema for object with additional options, and returns a DataBaseDoc with that schema. 
            <para>May require additional permissions compared to <see cref="M:SEIDR.DataBase.DatabaseExtensions.PullSchemaDoc(SEIDR.DataBase.DatabaseManager,System.String,System.String)"/>
            </para>
            </summary>
            <param name="manager"></param>
            <param name="tableName"></param>
            <param name="skipIdent"></param>
            <param name="skipComputed"></param>
            <param name="Schema"></param>
            <param name="noLock"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseExtensions.PullSchema(SEIDR.DataBase.DatabaseManager,System.String,System.Boolean,System.Boolean,System.String,System.Boolean)">
            <summary>
            Pull schema for object with additional options. May require additional permissions compared to <see cref="M:SEIDR.DataBase.DatabaseExtensions.PullSchemaDoc(SEIDR.DataBase.DatabaseManager,System.String,System.String)"/>
            </summary>
            <param name="manager"></param>
            <param name="tableName"></param>
            <param name="skipIdent"></param>
            <param name="skipComputed"></param>
            <param name="Schema"></param>
            <param name="noLock"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseExtensions.ToContentList``1(System.Data.DataSet,System.Int32)">
            <summary>
            Converts the DataTable from the specified index of the dataset into a List of <typeparamref name="RT"/>
            </summary>
            <typeparam name="RT"></typeparam>
            <param name="ds"></param>
            <param name="TableIndex"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseExtensions.ToContentList``1(System.Data.DataTable)">
            <summary>
            Converts datatable to a list of objects of type RT. Returns null if the datatable passed is null.
            </summary>
            <typeparam name="RT"></typeparam>
            <param name="dt"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseExtensions.ToContentRecord``1(System.Data.DataSet,System.Int32,System.Int32)">
            <summary>
            If the specified table is in the DataSet and contains a row at the specified index, returns a new record of type <typeparamref name="RT"/>.
            <para>Else, returns the default for the type.</para>
            </summary>
            <typeparam name="RT"></typeparam>
            <param name="ds"></param>
            <param name="TableIndex"></param>
            <param name="RowIndex"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseExtensions.ToContentRecord``1(System.Data.DataTable,System.Int32)">
            <summary>
            If the specified row is in the Datatable, returns a new record of type <typeparamref name="RT"/>.
            <para>Else, returns the default for the type.</para>
            </summary>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseExtensions.ToContentRecord``1(System.Data.DataRow)">
            <summary>
            Returns a new copy of type <typeparamref name="RT"/>. 
            If the passed DataRow is null, returns default for the Type.
            </summary>
            <typeparam name="RT"></typeparam>
            <param name="row"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseExtensions.AddColumns``1(System.Data.DataTable,System.String[])">
            <summary>
            Add Missing columns to the datatable by using the names and information of properties from type <typeparamref name="RT"/>
            </summary>
            <typeparam name="RT"></typeparam>
            <param name="dt"></param>
            <param name="IgnoredProperties"></param>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseExtensions.AddRow``1(System.Data.DataTable,``0)">
            <summary>
            Maps the properties of <paramref name="obj"/> to a new row in <paramref name="dt"/>.
            <para>If <paramref name="obj"/> is null, each column in the new row will be mapped to DBNull.</para>
            </summary>
            <typeparam name="RT"></typeparam>
            <param name="dt"></param>
            <param name="obj"></param>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseExtensions.MapEachColumn(System.Data.DataRow,System.Func{System.Data.DataColumn,System.Object})">
            <summary>
            Applies mapping function to each column of the row. Ignores any existing values
            </summary>
            <param name="r"></param>
            <param name="map"></param>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseExtensions.MapEachColumn(System.Data.DataRow,System.Func{System.Data.DataColumn,System.Object,System.Object})">
            <summary>
            Applies mapping function to each column of the row
            </summary>
            <param name="r"></param>
            <param name="mapUpdate"> Mapping function that can consider any existing value in the column</param>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseExtensions.GetFirstTableOrNull(System.Data.DataSet)">
            <summary>
            Returns the first table from the dataset, or null if there are no tables.
            </summary>
            <param name="ds"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseExtensions.GetFirstRowOrNull(System.Data.DataTable)">
            <summary>
            Returns first row of the dataTable, if it has any rows. Else returns null.
            </summary>
            <param name="dt"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseExtensions.GetFirstRowOrNull(System.Data.DataSet)">
            <summary>
            Returns first row of the first table, or null if there there is none.
            </summary>
            <param name="ds"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseExtensions.GetFirstRowOrNull(System.Data.DataSet,System.Int32)">
            <summary>
            Returns the first row of the specified Table, if the dataset contains that many tables
            </summary>
            <param name="ds"></param>
            <param name="Table">Zero based index of the table to be grabbed</param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseExtensions.GetTableOrNull(System.Data.DataSet,System.Int32)">
            <summary>
            Return table at zero based index or null
            </summary>
            <param name="ds"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseExtensions.GetReturnValue(System.Data.SqlClient.SqlCommand)">
            <summary>
            Gets the Return value of the command. If no return value is set, return 0.
            </summary>
            <param name="cmd"></param>
            <returns></returns>
        </member>
        <member name="T:SEIDR.DataBase.DatabaseManager">
             <summary>
             Sets up a database manager to handle converting c# objects to SQL parameters.
             <para>Can also be used for populating c# objects with results of procedures which could also have had its parameters populated by an object(generic)
            </para>
             </summary>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseManager.GetBasicHelper(System.Boolean)">
            <summary>
            Returns the default Helper Model for this connection.
            </summary>
            <param name="includeConnection">If true, sets the SQL connection using this manager's connection</param>
            <returns></returns>
        </member>
        <member name="P:SEIDR.DataBase.DatabaseManager.DefaultRetryOnDeadlock">
            <summary>
            When inferring a procedure call model, allows overriding the default setting for Retry on Deadlock
            </summary>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseManager.#ctor(SEIDR.DataBase.DatabaseConnection,System.String,System.String,System.String,System.String,System.String,System.String,System.String)">
             <summary>
             Sets up a database manager to handle converting c# objects to SQL parameters.
             <para>Can also be used for populating c# objects with results of procedures which could also have had its parameters populated by an object(generic)
            </para>
             </summary>
             <param name="Connection">The database Connection for storing SQL connection info</param>
             <param name="DefaultSchema">Default Schema to be used when not overridden in any of the versions of the procedures/ when using a ConnectionParameterInfo object</param>
             <param name="SaveFormat">Format to be used in <see cref="!:Save&lt;RT&gt;(RT, string, string[])"/>. Object type name replaces {0}</param>
             <param name="UpdateFormat">Format to be used in <see cref="!:Update&lt;RT&gt;(RT, string, string[])"/>. Object type name replaces {0}</param>
             <param name="InsertFormat">Format to be used in <see cref="!:Insert&lt;RT&gt;(RT, string, string[])"/>. Object type name replaces {0}</param>
             <param name="DeleteFormat">Format to be used in <see cref="!:Delete&lt;RT&gt;(RT, string, string[])"/>. Object type name replaces {0}</param>
             <param name="SelectRowFormat">Format to be used in <see cref="!:SelectSingle&lt;RT&gt;(object, string, string[])"/>. Object type name replaces {0}</param>
             <param name="SelectListFormat">Format to be used in <see cref="!:SelectList&lt;RT&gt;(object, string, string[])"/>. Object type name replaces {0}</param>
        </member>
        <member name="P:SEIDR.DataBase.DatabaseManager.ProgramName">
            <summary>
            Overrides the Application Name of the DatabaseConnection when starting new connections
            </summary>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseManager.Clone(System.Boolean,System.String)">
            <summary>
            Clones the DatabaseManager, but takes the setting of Rethrow from the parameter.
            </summary>
            <param name="reThrowException"></param>
            <param name="programName">If non-null, overrids the value of the cloned manager's program name</param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseManager.CloneConnection(System.String)">
            <summary>
            Returns a cloned copy of the connection associated with this manager.
            </summary>
            <param name="programName">If non null, changes the application name. If null, maintains</param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseManager.GetConnection">
            <summary>
            Returns a new sql connection using the underlying <see cref="T:SEIDR.DataBase.DatabaseConnection"/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseManager.GetConnectionString">
            <summary>
            Returns a copy of the connection string from the underly <see cref="T:SEIDR.DataBase.DatabaseConnection"/>
            </summary>
            <returns></returns>
        </member>
        <member name="P:SEIDR.DataBase.DatabaseManager.TimeOut">
            <summary>
            Connection timeout
            </summary>
        </member>
        <member name="P:SEIDR.DataBase.DatabaseManager.CommandTimeOut">
            <summary>
            Command timeout for SQL commands
            </summary>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseManager.IncreaseCommandTimeOut(System.Int32)">
            <summary>
            Sets the <see cref="P:SEIDR.DataBase.DatabaseManager.CommandTimeOut"/>, but only if the new value is larger than the current command timeout.
            </summary>
            <param name="NewTimeOut"></param>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseManager.ChangeConnection(SEIDR.DataBase.DatabaseConnection)">
            <summary>
            Changes the underlying connection
            </summary>
            <param name="newConnection"></param>
        </member>
        <member name="P:SEIDR.DataBase.DatabaseManager.DefaultSchema">
            <summary>
            Sets the default schema - used when parameters are not passed to methods to override the schema. 
            <para>[ and ] are removed, but will be added around the schema when actually performing the call</para>
            </summary>
        </member>
        <member name="F:SEIDR.DataBase.DatabaseManager.DEFAULT_SAVE">
            <summary>
            Default format for combined "Insert/Update" procedure calls
            </summary>
        </member>
        <member name="F:SEIDR.DataBase.DatabaseManager.DEFAULT_UPDATE">
            <summary>
            Default format for "Update" procedure call
            </summary>
        </member>
        <member name="F:SEIDR.DataBase.DatabaseManager.DEFAULT_INSERT">
            <summary>
            Default format for "Insert" procedure call
            </summary>
        </member>
        <member name="F:SEIDR.DataBase.DatabaseManager.DEFAULT_DELETE">
            <summary>
            Default format for "Delete" procedure call
            </summary>
        </member>
        <member name="F:SEIDR.DataBase.DatabaseManager.DEFAULT_SELECT_ROW">
            <summary>
            Default format for "Select single" procedure call
            </summary>
        </member>
        <member name="F:SEIDR.DataBase.DatabaseManager.DEFAULT_SELECT_LIST">
            <summary>
            Default format for "Select list" procedure call - multiple row result from the first DataTable
            </summary>
        </member>
        <member name="F:SEIDR.DataBase.DatabaseManager.SaveFormat">
            <summary>
            Format for a procedure that handles both inserting and updating. Should not include Schema
            </summary>
        </member>
        <member name="F:SEIDR.DataBase.DatabaseManager.InsertFormat">
            <summary>
            Format for a procedure that handles inserting a new record. Should not include Schema
            </summary>
        </member>
        <member name="F:SEIDR.DataBase.DatabaseManager.UpdateFormat">
            <summary>
            Format for a procedure that handles updating existing a single record. Should not include Schema
            </summary>
        </member>
        <member name="F:SEIDR.DataBase.DatabaseManager.DeleteFormat">
            <summary>
            Format for a procedure that handles deleting a single record. Should not include Schema
            </summary>
        </member>
        <member name="F:SEIDR.DataBase.DatabaseManager.SelectRowFormat">
            <summary>
            Format for a procedure that handles selecting a single row. Should not include Schema
            </summary>
        </member>
        <member name="F:SEIDR.DataBase.DatabaseManager.SelectListFormat">
            <summary>
            Format for a procedure that handles selecting a list of rows. Should not include Schema
            </summary>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseManager.GetSqlCommand(SEIDR.DataBase.DatabaseManagerHelperModel)">
            <summary>
            Executes the command associated with the model. Any open transaction will attempt to commit on success.
            <para>Builds a sql command using the helper model, and its connection.</para>
            <para>If the helper model does not have an open connection, it will be opened first.</para>
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseManager.Execute(SEIDR.DataBase.DatabaseManagerHelperModel,System.Boolean)">
            <summary>
            Executes a SQL Command based on the ConnectionProcedureCallModel. 
            <para>If there's a transaction and <paramref name="CommitSuccess"/> is true, will commit the transaction on the model.</para>
            </summary>
            <param name="i"></param>
            <param name="CommitSuccess">If command is successful, commit the transaction on the model. If the model doesn't have a transaction, does nothing</param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseManager.Execute(System.String,System.Object,System.Boolean)">
            <summary>
            Executes the stored procedure. 
            </summary>
            <param name="QualifiedProcedureName"></param>
            <param name="mapObj">Object to use for populating parameters from properties</param>
            <param name="updateMap"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseManager.ExecuteNonQuery(SEIDR.DataBase.DatabaseManagerHelperModel,System.Boolean)">
            <summary>
            Executes a SQL Command based on the ConnectionProcedureCallModel, with no result set.
            <para>If there's a transaction and <paramref name="CommitSuccess"/> is true, will commit the transaction on the model.</para>
            </summary>
            <param name="i"></param>
            <param name="CommitSuccess">If command is successful, commit the transaction from the model. If the model doesn't have a transaction, does nothing</param>
            <returns>Affected RowCount</returns>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseManager.ExecuteNonQuery(System.String,System.Object,System.Nullable{System.Boolean})">
            <summary>
            Executes the non query specified by the Qualified procedure name (Schema + Procedure Name)
            </summary>
            <param name="QualifiedProcedureName"></param>
            <param name="mapObj"></param>
            <param name="RetryDeadlock"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseManager.ExecuteNonQuery(System.String,System.Int32@,System.Object,System.Nullable{System.Boolean},System.Boolean)">
            <summary>
            Executes the fully Qualified procedure.
            </summary>
            <param name="QualifiedProcedureName">Procedure name. If not actually fully qualified, use the default schema.</param>
            <param name="ReturnCode">The SQL Return code from calling the stored procedure</param>
            <param name="mapObj"></param>
            <param name="RetryDeadlock">Priority for determining whether to retry on deadlock</param>
            <param name="updateMap">Indicates whether the map object should have its properties updated</param>
            <returns>RowCount from ExecuteNonQuery</returns>
        </member>
        <member name="P:SEIDR.DataBase.DatabaseManager.RethrowException">
            <summary>
            Rethrows exceptions from execution. Set to false if dealing with procedures where you don't care about catching the exception yourself.
            </summary>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseManager.ExecuteTextNonQuery(System.String,System.Nullable{System.Boolean})">
            <summary>
            Executes the command text as a non query.
            </summary>
            <param name="CommandText"></param>
            <param name="RetryDeadlock">If a value is provided, determines whether to retry on a deadlock.
            <para>If no value is provided, will use the DatabaseManager's value, or the default for HelperModels</para></param>
            <returns>Affected RowCount from Executing non query</returns>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseManager.ExecuteText(System.String,System.Nullable{System.Boolean})">
            <summary>
            Executes the command text as a query.
            </summary>
            <param name="CommandText"></param>
            <param name="RetryDeadlock">If a value is provided, determines whether to retry on a deadlock.
            <para>If no value is provided, will use the DatabaseManager's value, or the default for HelperModels</para></param>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseManager.ExecuteText(SEIDR.DataBase.DatabaseManagerHelperModel,System.String,System.Boolean)">
            <summary>
            Executes the command text using settings/connection information from the Helper model
            </summary>
            <param name="i"></param>
            <param name="CommandText"></param>
            <param name="Commit"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseManager.SelectSingle``1(SEIDR.DataBase.DatabaseManagerHelperModel,System.Boolean,System.Boolean)">
            <summary>
            Selects a single record
            </summary>
            <typeparam name="RT"></typeparam>
            <param name="i">Contain information for calling a procedure</param>
            <param name="RequireSingleResult">If true, will return null when the the procedure returns more than one result</param>
            <param name="CommitSuccess">If true, commitsa if the transaction is open</param>
            <returns></returns>        
        </member>
        <member name="M:SEIDR.DataBase.DatabaseManager.SelectSingle``1(System.Object,System.String,System.String,System.String[],System.Boolean)">
            <summary>
            Call a procedure to select a single data record which matches to the return type {_}.
            </summary>
            <typeparam name="RT"></typeparam>
            <param name="paramObj"></param>
            <param name="suffix">String value to append at the end of the <see cref="F:SEIDR.DataBase.DatabaseManager.SelectRowFormat"/> for the particular procedure we want to run, to allow a more context specific version call.</param>
            <param name="Schema">Schema of procedure. If null, uses the <see cref="P:SEIDR.DataBase.DatabaseManager.DefaultSchema"/> </param>
            <param name="ignore"></param>
            <param name="RequireSingle"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseManager.SelectList``1(SEIDR.DataBase.DatabaseManagerHelperModel)">
            <summary>
            Select a list of <typeparamref name="RT"/> records, based on the information in the helper model.
            </summary>
            <typeparam name="RT"></typeparam>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseManager.Update``1(``0,System.String,System.String,System.String[])">
            <summary>
            Calls the update procedure (name found using Schema attached to the UpdateFormat)
            </summary>
            <typeparam name="RT"></typeparam>
            <param name="paramObj">Object with properties corresponding to the parameters used for updating a Database Object</param>
            <param name="suffix"></param>
            <param name="Schema">Allow overriding the Manager's main schema</param>
            <param name="ignore">Ignore properties from object - if exists as a parameter, will try to use default parameter value</param>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseManager.Insert``1(``0,System.String,System.String,System.String[])">
            <summary>
            Insert procedure - found by using the type name, formatted using the InsertFormat variable
            </summary>
            <typeparam name="RT"></typeparam>
            <param name="paramObj"></param>
            <param name="suffix">Suffix to tack onto the end of the procedure name (E.g. '_Register' for RT=Batch to get usp_Batch_i_Register)</param>
            <param name="Schema"></param>
            <param name="ignore"></param>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseManager.Delete``1(``0,System.String,System.String,System.String[])">
            <summary>
            Calls a procedure whose name is determined by combining <see cref="F:SEIDR.DataBase.DatabaseManager.DeleteFormat"/> with the name of type <typeparamref name="RT"/>.
            </summary>
            <typeparam name="RT"></typeparam>
            <param name="paramObj"></param>
            <param name="suffix"></param>
            <param name="Schema"></param>
            <param name="ignore"></param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:SEIDR.DataBase.DatabaseManager.SelectWithKey(System.String,System.Object,System.String,System.Int32,System.Int32)" -->
        <member name="M:SEIDR.DataBase.DatabaseManager.SelectRowWithKey(System.String,System.Object,System.String)">
            <summary>
            Gets the first row from selecting by the Key, or null if there are no rows
            </summary>
            <param name="Key"></param>
            <param name="value"></param>
            <param name="TableOrView"></param>
            <returns></returns>
        </member>
        <member name="T:SEIDR.DataBase.DatabaseObject">
            <summary>
            Basic base class for classes that will use an instance of <see cref="T:SEIDR.DataBase.DatabaseConnection"/>.
            <para>Inherit generically with your type as the generic to get basic method functionality as well.</para>
            </summary>
        </member>
        <member name="P:SEIDR.DataBase.DatabaseObject.Manager">
            <summary>
            Used for 
            </summary>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseObject.#ctor(SEIDR.DataBase.DatabaseManager)">
            <summary>
            Base constructor for DatabaseObject.
            </summary>
            <param name="manager"></param>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseObject.#ctor">
            <summary>
            Basic constructor, to allow constructing from reflection
            </summary>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseObject.CloneConnection(System.String)">
            <summary>
            Clones the connection
            </summary>
            <param name="programName"></param>
            <returns></returns>
        </member>
        <member name="T:SEIDR.DataBase.DatabaseObject`1">
            <summary>
            Base class inheriting from <see cref="T:SEIDR.DataBase.DatabaseObject"/>, which adds basic method functionality.
            Use with a recursive generic.
            </summary>
            <typeparam name="RT">Recursive generic. Ex: class myObject: DatabaseObject&lt;myObject> </typeparam>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseObject`1.#ctor(SEIDR.DataBase.DatabaseManager)">
            <summary>
            Constructor for the Generic base class inheriting from <see cref="T:SEIDR.DataBase.DatabaseObject"/>
            </summary>
            <param name="dbm"></param>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseObject`1.#ctor">
            <summary>
            Basic, parameterless constructor to allow constructing from reflection.
            </summary>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseObject`1.ExecuteProcedure(System.String)">
            <summary>
            Executes the non query procedure by passing to the DatabaseManager
            </summary>
            <param name="QualifiedProcedure"></param>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseObject`1.ExecuteProcedure(System.String,System.String)">
            <summary>
            Executes the non query procedure by passing to the DatabaseManager
            </summary>
            <param name="Schema"></param>
            <param name="Procedure"></param>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseObject`1.PassToProcedure(System.String)">
            <summary>
            Executes the procedure by passing to the DatabaseManager and returning any result set.
            </summary>
            <param name="QualifiedProcedure"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseObject`1.PassToProcedure(System.String,System.String)">
            <summary>
            Executes the procedure by passing to the DatabaseManager and returning any result set.
            </summary>
            <param name="Schema"></param>
            <param name="Procedure"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseObject`1.PassToProcedureForTable(System.String)">
            <summary>
            Executes the procedure by passing to the DatabaseManager and returning the first table of any result set.
            </summary>
            <param name="QualifiedProcedure"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseObject`1.PassToProcedureForTable(System.String,System.String)">
            <summary>
            Executes the procedure by passing to the DatabaseManager and returning the first table of any result set.
            </summary>
            <param name="Schema"></param>
            <param name="Procedure"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseObject`1.GetRecord(SEIDR.DataBase.DatabaseManager,SEIDR.DataBase.DatabaseManagerHelperModel)">
            <summary>
            Executes the procedure by passing to the DatabaseManager and returning the first record of the first table of any result set.
            <para>Result record is converted to a <see cref="!:RT"/>. </para>
            </summary>
            <param name="manager"></param>
            <param name="model">Model for the query to be executed</param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseObject`1.GetList(SEIDR.DataBase.DatabaseManager,SEIDR.DataBase.DatabaseManagerHelperModel)">
            <summary>
            Executes the procedure by passing to the DatabaseManager and returning the first table of any result set, converted to a list of <see cref="!:RT"/>
            </summary>        
            <returns></returns>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseObject`1.GetRow(System.String)">
            <summary>
            Executes the procedure by passing to the DatabaseManager and returning the first row of the first table of any result set.
            </summary>
            <param name="QualifiedProcedure"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseObject`1.GetRow(System.String,System.String)">
            <summary>
            Executes the procedure by passing to the DatabaseManager and returning the first row of the first table of any result set.
            </summary>
            <param name="Schema"></param>
            <param name="Procedure"></param>
            <returns></returns>
        </member>
        <member name="T:SEIDR.DataBase.ParamStore">
            <summary>
            Cache SQLCommand information
            </summary>
        </member>
        <member name="M:SEIDR.DataBase.ParamStore.#ctor">
            <summary>
            Creates a new param store, for caching SQL Parameters of commands
            </summary>
        </member>
        <member name="M:SEIDR.DataBase.ParamStore.Remove(System.Data.SqlClient.SqlCommand)">
            <summary>
            Removes the parameters associated with the Command used for <paramref name="cmd"/>
            </summary>
            <param name="cmd"></param>
        </member>
        <member name="M:SEIDR.DataBase.ParamStore.FillParameterCollection(System.Data.SqlClient.SqlCommand)">
            <summary>
            Stores the parameter information fromn the given command
            </summary>
            <param name="cmd"></param>
        </member>
        <member name="T:SEIDR.DataBase.Schema.Schema">
            <summary>
            Helper class for DB Conversions
            </summary>
        </member>
        <member name="T:SEIDR.DateFormatter">
            <summary>
            A class to sugarcoat converting a consistent column to a DateTime. <para>Expected to be useful when you're not sure if a file will keep the same date format,
            if the date format changes depending on the column with the file, or if the c# code is expected to be reused for multiple, different data sources.</para>
            </summary>
            <remarks>It's technically possible for a junk column to be converted to a date. 
            <para>Ex: After finding the format for Col A to be mm-dd-yyyy, the string "ash04ketchum142014" should convert to 4/14/2014.</para>
            <para>Also to note, null and invisible characters should not impact date transformation AS LONG AS the *ENTIRE* date string can be read.</para>    
            </remarks>
        </member>
        <member name="F:SEIDR.DateFormatter.checkSanity">
            <summary>
            Set to true to prevent successful conversion of outstanding dates when calling ParseString. Default: False. 
            <para>E.g. 3/24/1825 would have a valid datetime out, but would return false instead of true.</para>
            </summary>
            <remarks>
            The requirements for failing sanity check are that it would be at least 100 years back from runtime, or at least 150 years into the future from runtime.
            <para>It's false by default since the usefulness of this really depends on what you're doing.</para>
            </remarks>
        </member>
        <member name="P:SEIDR.DateFormatter.size">
            <summary>
            Return the number of columns contained in the dateformatter. Columns and the number of columns cannot be changed without recreating the dateformatter. 
            <para>Columns CAN be renamed using the indexer and their index though.</para><para> E.g., df["pat"] -> 0. df[0] = "pie" -> . df["pat"] -> -1. df["pie"] -> 0</para>
            </summary>
        </member>
        <member name="M:SEIDR.DateFormatter.#ctor(System.Int32)">
            <summary>
            Creates a new date formatter.
            </summary>
            <param name="size">This should be the number of date columns you're expecting to exist.</param>
        </member>
        <member name="M:SEIDR.DateFormatter.#ctor(System.String[])">
             <summary>
             Create a new dateformatter using an array of column names.
             </summary>
            <param name="names">(Params) String array containing ALL names of columns expected to be dates. 
            Can be passed as just a number of string arguments if you don't have a lot of them</param>
        </member>
        <member name="P:SEIDR.DateFormatter.Item(System.String)">
            <summary>
            Returns the column index within the dateformatter of the given column's name. Not case sensitive
            </summary>
            <param name="column">Column you want the index of.</param>
            <returns>integer index of the column</returns>
        </member>
        <member name="P:SEIDR.DateFormatter.Item(System.Int32)">
            <summary>
            Get: Return the name of the column at that index. Set: Change the name of a column using it's index.
            </summary>
            <param name="column">Index</param>
            <returns>Empty string if no name has been set, else the name associated with a column</returns>
        </member>
        <member name="M:SEIDR.DateFormatter.getFormat(System.String)">
            <summary>
            Attempts to return the format for the given column. If unable to find the column using the given name, "Column not found" is returned instead.
            </summary>
            <param name="columnName">Name of the column</param>
            <returns>The format for the column to use when parsing the format.</returns>
        </member>
        <member name="M:SEIDR.DateFormatter.getFormat(System.Int32)">
            <summary>
            Attempts to return the format for the given column index. If unable to find the column using the given name, "Column not found" is returned instead.
            </summary>
            <param name="column">Index of the column in the dateFormatter. Can be obtained using an indexer if you're not sure.</param>
            <returns>Format for the column to use when parsing the format</returns>
        </member>
        <member name="M:SEIDR.DateFormatter.ParseFormat(System.String,System.Int32)">
            <summary>
            Takes a string and attempts to find the format to use in ParseString
            </summary>
            <param name="original">String to parse format from</param>
            <param name="column">Column the string is in.</param>
            <returns>True if we are able to parse a date from this string. False otherwise</returns>
        </member>
        <member name="M:SEIDR.DateFormatter.ParseString(System.String,System.String,System.DateTime@)">
            <summary>
            Calls on ParseString(int column, string value, out DateTime result) after finding the index of the column Name
            </summary>
            <param name="columnName">Name of column</param>
            <param name="value">Value to parse</param>
            <param name="result">Value converted to a DateTime</param>
            <returns>True if conversion to date succeeded.</returns>
        </member>
        <member name="M:SEIDR.DateFormatter.ParseString(System.Int32,System.String,System.DateTime@)">
            <summary>
            Attempts to parse the passed value using the given column's format.
            </summary>
            <param name="column">Index of column in dateformatter</param>
            <param name="value">Value to parse</param>
            <param name="result">Value converted to a DateTime</param>
            <returns>True if conversion to date succeeded. 
            <para>If CheckSanity is true, then failing the sanity check will cause this to return false even if the conversion to date succeeded</para>         
            </returns>
        </member>
        <member name="M:SEIDR.DateFormatter.ParseOnce(System.String,System.DateTime@,System.Boolean)">
            <summary>
            Creates a local dateformatter to run a single check on the date and then be deleted via leaving scope.
            </summary>
            <param name="value">String we want to parse</param>
            <param name="result">Output date</param>
            <param name="SanityCheck">If true, includes Sanity check</param>
            <returns>True if the result is a valid datetime</returns>
        </member>
        <member name="M:SEIDR.DateFormatter.ParseOnceS(System.String,System.DateTime@)">
            <summary>
            Same as the static ParseOnce method, but has Sanity Checking turned on
            </summary>
            <param name="value"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="T:SEIDR.Doc.DataReaderDoc">
            <summary>
            For large set of data from DB, read FORWARD only. (As is the underlying <see cref="T:System.Data.SqlClient.SqlDataReader"/>)
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DataReaderDoc.ColumnSet">
            <summary>
            Underlying column collection from the schema of the reader.
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DataReaderDoc.GetMetaDataForFile(System.String)">
            <summary>
            Creates a new metadata for specified file path by copying the column set of this object.
            </summary>
            <param name="filePath"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DataReaderDoc.GetMetaDataForFile(System.String,System.String,System.String)">
            <summary>
            Creates a new metadata for specified file path by copying the column set of this object.
            </summary>
            <param name="folder"></param>
            <param name="FileName"></param>
            <param name="alias"></param>        
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DataReaderDoc.Dispose">
            <summary>
            Dispose underlying reader.
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DataReaderDoc.CurrentRowID">
            <summary>
            Number of records that have been read so far.
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DataReaderDoc.Closed">
            <summary>
            Returns true if the underlying reader has finished reading and is now closed.
            </summary>
        </member>
        <member name="T:SEIDR.Doc.DocDatabaseLoader">
            <summary>
            Helper class for loading <see cref="T:SEIDR.Doc.IDataRecord"/> implementations into a database.
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DocDatabaseLoader.#ctor(System.String,SEIDR.DataBase.DatabaseManager,System.Data.SqlClient.SqlBulkCopyOptions,System.String)">
            <summary>
            Construct a helper class for bulk loading file content to a DataTable.
            </summary>
            <param name="TableName"></param>
            <param name="connectionManager"></param>
            <param name="bulkCopyOptions"></param>
            <param name="Schema"></param>
        </member>
        <member name="F:SEIDR.Doc.DocDatabaseLoader.DefaultSchema">
            <summary>
            Default schema when setting table name.
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DocDatabaseLoader.Linked">
            <summary>
            Indicates whether or not the loader is linked to a datatable.
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DocDatabaseLoader.Link(System.Data.DataTable)">
            <summary>
            Links the bulk loader to a DataTable object. 
            <para>As the number of rows in the DataTable reaches <see cref="P:SEIDR.Doc.DocDatabaseLoader.BatchSize"/>, the loader will automatically call <see cref="M:SEIDR.Doc.DocDatabaseLoader.BulkLoadLinkedTable(System.Boolean)"/>, indicating to clear the row data.</para>
            </summary>
            <param name="toLink"></param>
        </member>
        <member name="M:SEIDR.Doc.DocDatabaseLoader.UnLink">
            <summary>
            Removes the link to the DataTable object
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DocDatabaseLoader.BatchSize">
            <summary>
            Number of records to go through before writing to the database when enumerating a file.
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DocDatabaseLoader.BulkCopyTimeout">
            <summary>
            Gets or sets the Bulk Copy timeout of the underlying bulk copy object
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DocDatabaseLoader.SetBatchSize(System.Int32)">
            <summary>
            Sets the <see cref="P:SEIDR.Doc.DocDatabaseLoader.BatchSize"/>
            </summary>
            <param name="batchSize"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocDatabaseLoader.AddColumnMappings(System.Data.SqlClient.SqlBulkCopyColumnMapping[])">
            <summary>
            Add a set of column mappings.
            </summary>
            <param name="columnMappings"></param>
        </member>
        <member name="M:SEIDR.Doc.DocDatabaseLoader.SetDestinationTable(System.String,System.String)">
            <summary>
            Add a set of column mappings.
            </summary>
            <param name="tableName"></param>
            <param name="Schema"></param>
        </member>
        <member name="M:SEIDR.Doc.DocDatabaseLoader.AddColumnMapping(System.String,System.String)">
            <summary>
            Add a mapping of a column in the IDataRecords to the destination column of the table.
            </summary>
            <param name="sourceColumn"></param>
            <param name="destinationColumn"></param>
        </member>
        <member name="M:SEIDR.Doc.DocDatabaseLoader.AddColumnMapping(SEIDR.Doc.DocRecordColumnInfo,System.Int32)">
            <summary>
            Add a set of column mappings.
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DocDatabaseLoader.AddColumnMapping(SEIDR.Doc.DocRecordColumnInfo,System.String)">
            <summary>
            Add a set of column mappings.
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DocDatabaseLoader.SetColumnMappings(SEIDR.Doc.DocRecordColumnInfo[])">
            <summary>
            Overrides all column mappings on the underlying bulk copier.
            </summary>
            <param name="source"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocDatabaseLoader.SetColumnMappings(System.Collections.Generic.IEnumerable{SEIDR.Doc.DocRecordColumnInfo})">
            <summary>
            Overrides all column mappings on the underlying bulk copier.
            </summary>
            <param name="colSource"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocDatabaseLoader.SetColumnMappings(System.Collections.Generic.IEnumerable{SEIDR.Doc.DocRecordColumnInfo},System.Collections.Generic.IEnumerable{SEIDR.Doc.DocRecordColumnInfo})">
            <summary>
            Overrides all column mappings on the underlying bulk copier, using the column names from <paramref name="sourceColumns"/> that are also in <paramref name="destColSource"/>.
            </summary>
            <param name="sourceColumns"></param>
            <param name="destColSource">List of columns in destination.</param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocDatabaseLoader.SetColumnMappings(System.Collections.Generic.IEnumerable{SEIDR.Doc.DocRecordColumnInfo},System.Func{SEIDR.Doc.DocRecordColumnInfo,System.Boolean})">
            <summary>
            Overrides all column mappings on the underlying bulk copier.
            </summary>
            <param name="colSource"></param>
            <param name="include">Function to return true if the column should be mapped.</param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocDatabaseLoader.ClearColumnMappings">
            <summary>
            Clear column mappings
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DocDatabaseLoader.BulkLoadRecords(System.Collections.Generic.IEnumerable{SEIDR.Doc.IDataRecord})">
            <summary>
            Write the records to the destination table.
            <para>Cannot be called while linked to a DataTable.</para>
            <para>NOTE: See <see cref="M:SEIDR.Doc.DocRecordColumnInfo.FormatValue(System.Object)"/> for conversion formatting.</para>
            </summary>
            <param name="records"></param>
        </member>
        <member name="P:SEIDR.Doc.DocDatabaseLoader.DestinationTableName">
            <summary>
            The destination table for this loader.
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DocDatabaseLoader.BulkLoadLinkedTable(System.Boolean)">
            <summary>
            Bulk loads the link table data to the Bulk copy destination, and optionally clears the row data.
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DocDatabaseLoader.BulkLoadTable(System.Data.DataTable)">
            <summary>
            Bulk load the DataTable to the table specified by <see cref="P:SEIDR.Doc.DocDatabaseLoader.DestinationTableName"/>
            </summary>
            <param name="tableData"></param>
        </member>
        <member name="M:SEIDR.Doc.DocDatabaseLoader.Dispose">
            <summary>
            Dispose underlying SQL Bulk copy object.
            <para>If <see cref="P:SEIDR.Doc.DocDatabaseLoader.Linked"/>, will attempt to bulk insert any data remaining in the datatable, and then clear row data.</para>
            </summary>
        </member>
        <member name="T:SEIDR.Doc.DocValueRandom">
            <summary>
            Object to help with creating random values for a test/dummy file.
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DocValueRandom.#ctor">
            <summary>
            Object to help with creating random values for a test/dummy file.
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DocValueRandom.#ctor(System.Random)">
            <summary>
            Object to help with creating random values for a test/dummy file.
            </summary>
            <param name="rand"></param>
        </member>
        <member name="M:SEIDR.Doc.DocValueRandom.CycleXTimes(System.Int32)">
            <summary>
            Since the <see cref="T:System.Random"/> class makes use of a subtractive algorithm and pseudo-randomness, allow calling the <see cref="M:System.Random.Next(System.Int32)"/> method a number of times.
            </summary>
            <param name="x"></param>
        </member>
        <member name="M:SEIDR.Doc.DocValueRandom.PercentCheck(System.Int32)">
            <summary>
            Uses <see cref="T:System.Random"/> to provide a bool value of true <paramref name="percent"/>% of the time, and false the rest.
            </summary>
            <param name="percent">Integer value between 0 and 100 (inclusive). 0 will always be false, and 100 will always be true.</param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocValueRandom.PercentCheck(System.Double)">
            <summary>
            Uses <see cref="T:System.Random"/> to provide a bool value of true <paramref name="percent"/>% of the time, and false the rest.
            </summary>
            <param name="percent">Decimal value between 0 and 100 (inclusive). 0 will always be false, and 100 will always be true.</param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocValueRandom.GetDateTimeNullable(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Gets a random DateTime? object, which will be null <paramref name="PercentNull"/>% of the time.
            </summary>
            <param name="PercentNull"></param>
            <param name="yearFrom"></param>
            <param name="monthFrom"></param>
            <param name="DayFrom"></param>
            <param name="yearThrough"></param>
            <param name="monthThrough"></param>
            <param name="DayThrough"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocValueRandom.GetDateTime(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Gets a random date in the specified range.
            <para> If the yearThrough is smaller than yearFrom, will be treated as X years after yearFrom instead.</para>
            </summary>
            <param name="yearFrom"></param>
            <param name="monthFrom">Only used when the out year is the same as the <paramref name="yearFrom"/></param>
            <param name="DayFrom"></param>
            <param name="yearThrough"></param>
            <param name="monthThrough">Only used when out year is the same as the <paramref name="yearThrough"/></param>
            <param name="DayThrough"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocValueRandom.GetMoney(System.Int32,System.Int32)">
            <summary>
            Gets a random money amount (decimal rounded to 2)
            </summary>
            <param name="dollarMin"></param>
            <param name="DollarMax"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocValueRandom.GetDecimal(System.Decimal,System.Decimal,System.Int32)">
            <summary>
            Returns a random decimal between min and max. If max is less than min, will treat max as X values after min. (E.g. if max is 50 and min is 100, then treat as 100 through 150)
            </summary>
            <param name="min"></param>
            <param name="max"></param>
            <param name="round"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocValueRandom.GetText(System.Double,System.Int32,System.Int32)">
            <summary>
            Gets a set of text from lorem ipsum
            </summary>
            <param name="percentNull"></param>
            <param name="minLength"></param>
            <param name="maxLength">Maximum length. If less than minLength, will treat max as equal to min.</param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocValueRandom.GetString(System.Int32,System.String[])">
            <summary>
            Gets a random string from the provided list, or null <paramref name="percentNull"/>% of the time.
            </summary>
            <param name="percentNull"></param>
            <param name="possibleValueList"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocValueRandom.GetString(System.String,System.Int32)">
            <summary>
            Gets a random string based on regex derived rules. <para>E.g. '@[1-2]{1,2}' can return one of the following values: 
            @1, @2, @11, @12, @21, @22</para>
            <para>'@[1-24]{2}' could return one of the following: @11, @12, @14, @21, @22, @24, @41, @42, @44</para>
            <para>'@[1-2]{2}-1 could return one of the following: @11-1, @12-1, @21-1, @22-1</para>
            <para>'@[1-2]\{2} COuld return one of the following: @1{2}, @2{2}</para>
            </summary>
            <param name="pattern"></param>
            <param name="percentNull"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.SBSONHelper.FormatObject(SEIDR.Doc.DocRecordColumnType,System.Object)">
            <summary>
            Format a typed object into a string based to a standard format.
            </summary>
            <param name="type"></param>
            <param name="o"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.SBSONHelper.CheckValue(System.Byte[],System.Int32@)">
            <summary>
            Check that the input has the full value of the next item based on starting position.
            </summary>
            <param name="input"></param>
            <param name="Position"></param>
            <returns></returns>
        </member>
        <member name="T:SEIDR.Doc.DataItem">
            <summary>
            Wrapper class for storing object with type meta data and allowing implicit conversion to store in a variable of a matching type.
            <para>Note: do not do direct string concatenation - string interpolation works, as well as after explicit string conversion</para>
            </summary>
        </member>
        <member name="F:SEIDR.Doc.DataItem.DEFAULT_NO_MATCH">
            <summary>
            If true, will return default instead of throwing an exception if the data type does not match when casting.
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DataItem.Value">
            <summary>
            Underlying object.
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DataItem.DataType">
            <summary>
            Data Type associated with value.
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DataItem.ToString">
            <summary>
            String representation of underlying object.
            </summary>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DataItem.CheckArrayObject(System.Object@,SEIDR.Doc.DocRecordColumnType)">
            <summary>
            If object type is IList rather than a plain array, convert to array.
            </summary>
            <param name="o"></param>
            <param name="dataType"></param>
            <returns></returns>
        </member>
        <member name="T:SEIDR.Doc.DataTableDoc`1">
            <summary>
            Enumerate readonly versions of DataTable as though the DataRows are of type <typeparamref name="DT"/>
            </summary>
            <typeparam name="DT"></typeparam>
        </member>
        <member name="M:SEIDR.Doc.DataTableDoc`1.op_Explicit(System.Data.DataTable)~SEIDR.Doc.DataTableDoc{`0}">
            <summary>
            Allow casting a DataTable as a DataTableDoc
            </summary>
            <param name="source"></param>
        </member>
        <member name="M:SEIDR.Doc.DataTableDoc`1.op_Implicit(SEIDR.Doc.DataTableDoc{`0})~System.Data.DataTable">
            <summary>
            Allow using a DataTableDoc as a <see cref="T:System.Data.DataTable"/>, by returning the underlying source object.
            </summary>
            <param name="source"></param>
        </member>
        <member name="M:SEIDR.Doc.DataTableDoc`1.op_Implicit(SEIDR.Doc.DataTableDoc{`0})~SEIDR.Doc.DocRecordColumnCollection">
            <summary>
            Allow using a DataTableDoc as a DocRecordColumn collection by returning the underlying column set
            </summary>
            <param name="source"></param>
        </member>
        <member name="P:SEIDR.Doc.DataTableDoc`1.ColumnSet">
            <summary>
            Underlying column set built by parsing DataColumn information from the source dataTable.
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DataTableDoc`1.GetMetaData(System.String)">
            <summary>
            Gets a meta data that can be used for writing the data in this instance to a file.
            </summary>
            <param name="DestinationFile"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DataTableDoc`1.Clear">
            <summary>
            Clear the rows in the underlying table.
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DataTableDoc`1.RecordCount">
            <summary>
            Number of rows in underlying table.
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DataTableDoc`1.ColumnCount">
            <summary>
            Number of columns in underlying table.
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DataTableDoc`1.SetRecord(SEIDR.Doc.IDataRecord,System.Int32,SEIDR.Doc.DocWriterMap,System.Boolean)">
            <summary>
            Updates the value of a row.
            <para>NOTE: See <see cref="M:SEIDR.Doc.DocRecordColumnInfo.FormatValue(System.Object)"/> for conversion formatting.</para>
            </summary>
            <param name="record"></param>
            <param name="rowID"></param>
            <param name="map"></param>
            <param name="trimOnExceedMaxLength"></param>
        </member>
        <member name="M:SEIDR.Doc.DataTableDoc`1.AddRecord(SEIDR.Doc.IDataRecord,System.Boolean)">
            <summary>
            Adds a record ot this table.
            <para>NOTE: See <see cref="M:SEIDR.Doc.DocRecordColumnInfo.FormatValue(System.Object)"/> for conversion formatting.</para>
            </summary>
            <param name="record"></param>
            <param name="trimOnExceedMaxLength"></param>
        </member>
        <member name="M:SEIDR.Doc.DataTableDoc`1.GetBasicRecord">
            <summary>
            Gets a basic record set, which is NOT attached to this object, but does have the same column collection.
            </summary>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DataTableDoc`1.RemoveColumn(SEIDR.Doc.DocRecordColumnInfo)">
            <summary>
            Removes a column from both the underlying table's columnset, and the underlying DocRecord Column set.
            </summary>
            <param name="columnName"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DataTableDoc`1.#ctor(SEIDR.Doc.DocRecordColumnCollection)">
            <summary>
            Construct empty DataTableDoc using specified column info.
            </summary>
            <param name="columnInfo"></param>
        </member>
        <member name="P:SEIDR.Doc.DataTableDoc`1.CanWrite">
            <summary>
            Indicate whether or not a data record can be updated when getting by index or enumerator.
            <para>NOTE: To actually update the DataTableDoc, use <see cref="M:SEIDR.Doc.DataTableDoc`1.SetRecord(SEIDR.Doc.IDataRecord,System.Int32,SEIDR.Doc.DocWriterMap,System.Boolean)" /> </para>
            </summary>
        </member>
        <member name="T:SEIDR.Doc.DateConverter">
            <summary>
            Helper for Dates from Doc data
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DateConverter.GetDateTime(SEIDR.Doc.IRecord,SEIDR.Doc.DocRecordColumnInfo)">
            <summary>
            Gets a DateTime object for the specified column.
            </summary>
            <param name="r"></param>
            <param name="columnInfo"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DateConverter.GuessDateTimeFormats(SEIDR.Doc.DocReader)">
            <summary>
            Guess the formats of any date columns in the DocReader
            </summary>
            <param name="doc"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DateConverter.GuessFormats(SEIDR.Doc.MetaDataBase,SEIDR.Doc.IDataRecord)">
            <summary>
            Check Date/DateTime formats for a single record, given the metadata for the file.
            </summary>
            <param name="metaData"></param>
            <param name="record"></param>
            <returns>Number of DateColumns remaining with an undetermined format.</returns>
        </member>
        <member name="M:SEIDR.Doc.DateConverter.GuessFormats(SEIDR.Doc.DocRecordColumnCollection,SEIDR.Doc.IDataRecord)">
            <summary>
            Check Date/DateTime Formats for a single record
            </summary>
            <param name="columnSet"></param>
            <param name="record"></param>        
            <returns>Number of DateColumns remaining with an undetermined format.</returns>
        </member>
        <member name="M:SEIDR.Doc.DateConverter.GuessFormats(SEIDR.Doc.DocRecordColumnCollection,System.Collections.Generic.IEnumerable{SEIDR.Doc.IDataRecord})">
            <summary>
            Attempts to use <see cref="M:SEIDR.Doc.DateConverter.GuessFormatDateTime(System.String,System.String@)"/> to populate the formats of the columns.
            <para>Note: will only guess for values that are populated and does not already have a Format - 
            if a column is never populated in the data, then it will still have a null Format after this call.</para>
            </summary>
            <param name="columnSet"></param>
            <param name="records">Set of records to check. Note: You should be able to pass an entire DocReader to this method because it implements IEnumerable for <see cref="T:SEIDR.Doc.DocRecord"/></param>
            <returns>Number of DateColumns remaining with an undetermined format.</returns>
        </member>
        <member name="M:SEIDR.Doc.DateConverter.GuessFormatDateTime(System.String,System.String@)">
            <summary>
            Guesses the format of a date string.
            </summary>
            <param name="DateString"></param>
            <param name="Format"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DateConverter.GuessFormatDate(System.String,System.String@)">
            <summary>
            Guess the format of a date string (No time component)
            </summary>
            <param name="DateString"></param>
            <param name="Format"></param>
            <returns></returns>
        </member>
        <member name="T:SEIDR.Doc.DocRecordColumnType">
            <summary>
            For some methods in DocRecord, and derived classes, to specify type of data. 
            <para>Mainly for formatting purposes when writing, but also some being able to parse to a consistent format based on <see cref="P:SEIDR.Doc.DocRecordColumnInfo.Format"/>
            </para>
            </summary>
        </member>
        <member name="F:SEIDR.Doc.DocRecordColumnType.NUL">
            <summary>
            For BSON. Should not be used for actual column info.
            </summary>
        </member>
        <member name="F:SEIDR.Doc.DocRecordColumnType.Unknown">
            <summary>
            Default type. Essentially treated as Varchar, but indicates that the type has not been set.
            </summary>
        </member>
        <member name="F:SEIDR.Doc.DocRecordColumnType.Varchar">
            <summary>
            Variable character
            </summary>
        </member>
        <member name="F:SEIDR.Doc.DocRecordColumnType.NVarchar">
            <summary>
            NonVariable characters, indicates length should be constant (padded if needed). Use with <see cref="P:SEIDR.Doc.DocRecordColumnInfo.MaxLength"/>
            </summary>
        </member>
        <member name="F:SEIDR.Doc.DocRecordColumnType.DateTime">
            <summary>
            Parses the string value of a record/column into a DateTime object, using the column's format. 
            <para>If a format is not set, then <see cref="!:DateConverter.GuessFormats(DocRecordColumnCollection, IRecord)"/> will be used and attempt to set the format.</para>
            </summary>
        </member>
        <member name="F:SEIDR.Doc.DocRecordColumnType.Date">
            <summary>
            Similar to DateTime, but no time component expected
            </summary>
        </member>
        <member name="F:SEIDR.Doc.DocRecordColumnType.Decimal">
            <summary>
            Gets the value of a record/column and parse it to a decimal value.
            </summary>
        </member>
        <member name="F:SEIDR.Doc.DocRecordColumnType.Money">
            <summary>
            Money Type - parse to decimal after removal of all non-numeric values. Will be treated as negative if a '-' occurs anywhere in the value, otherwise positive.
            <para>Does not perform any validations - if you want to perform custom validations, get the underlying string value instead of using <see cref="M:SEIDR.Doc.DocRecord.Evaluate``1(System.String,System.String,System.Boolean)"/></para>
            </summary>
        </member>
        <member name="T:SEIDR.Doc.DocRecordFormat">
            <summary>
            Describe format for reading/writing to files using a <see cref="T:SEIDR.Doc.MetaDataBase"/> derived class.
            </summary>
        </member>
        <member name="F:SEIDR.Doc.DocRecordFormat.DELIMITED">
            <summary>
            Delimited Output format when formatting a record as a string.
            </summary>
        </member>
        <member name="F:SEIDR.Doc.DocRecordFormat.FIX_WIDTH">
            <summary>
            Set width for all columns when formatting record as a string
            </summary>
        </member>
        <member name="F:SEIDR.Doc.DocRecordFormat.RAGGED_RIGHT">
            <summary>
            Set width for all columns when formatting record as a string, except the last column does not need to be padded.
            </summary>
        </member>
        <member name="F:SEIDR.Doc.DocRecordFormat.VARIABLE_WIDTH">
            <summary>
            Hybrid of Delimited/RaggedRight
            </summary>
        </member>
        <member name="F:SEIDR.Doc.DocRecordFormat.SBSON">
            <summary>
            Bit Condensed Object notation. SEIDR Custom Variation of BSON
            </summary>
        </member>
        <member name="F:SEIDR.Doc.DocRecordFormat.BSON">
            <summary>
            Variation of Binary JSON, intended to be closer to specifications from http://bsonspec.org
            </summary>
        </member>
        <member name="T:SEIDR.Doc.DocSorter`1">
            <summary>
            Parameterized sorter for a parameterized DocReader.
            </summary>
            <typeparam name="G"></typeparam>
        </member>
        <member name="M:SEIDR.Doc.DocSorter`1.#ctor(SEIDR.Doc.DocReader{`0},System.Int32,System.Boolean,System.Boolean,SEIDR.Doc.DuplicateHandling,SEIDR.Doc.IRecordColumnInfo[])">
            <summary>
            Constructor. Parameters: Parameterized DocReader, column to sort on.
            </summary>
            <param name="source"></param>
            <param name="cacheSize"></param>
            <param name="createIndex">If true, will auto create the index at the end of construction</param>
            <param name="disposeCleansIndex">If true, <see cref="M:SEIDR.Doc.DocSorter`1.Dispose"/> will also delete the sort index file.</param>
            <param name="handling">Determines what to do when duplicate records are discovered by the sort.</param>
            <param name="mainSort"></param>
        </member>
        <member name="M:SEIDR.Doc.DocSorter`1.#ctor(SEIDR.Doc.DocReader{`0},System.Int32,System.Int32,System.Boolean,System.Boolean,SEIDR.Doc.IRecordColumnInfo[])">
            <summary>
            Constructor. Parameters: Parameterized DocReader, column to sort on.
            </summary>
            <param name="source"></param>
            <param name="indexPageSize"></param>
            <param name="cacheSize"></param>
            <param name="createIndex">If true, will auto create the index at the end of construction</param>
            <param name="disposeCleansIndex">If true, <see cref="M:SEIDR.Doc.DocSorter`1.Dispose"/> will also delete the sort index file.</param>
            <param name="mainSort"></param>
        </member>
        <member name="M:SEIDR.Doc.DocSorter`1.#ctor(SEIDR.Doc.DocReader{`0},System.Int32,System.Int32,System.Boolean,System.Boolean,SEIDR.Doc.DuplicateHandling,SEIDR.Doc.IRecordColumnInfo[])">
            <summary>
            Constructor. Parameters: Parameterized DocReader, column to sort on.
            </summary>
            <param name="source"></param>
            <param name="cacheSize"></param>
            <param name="indexPageSize"></param>
            <param name="createIndex">If true, will auto create the index at the end of construction</param>
            <param name="disposeCleansIndex">If true, <see cref="M:SEIDR.Doc.DocSorter`1.Dispose"/> will also delete the sort index file.</param>
            <param name="handling">Determines what to do when duplicate records are found based on sorting. Note: Handled in the index logic.</param>
            <param name="mainSort"></param>
        </member>
        <member name="P:SEIDR.Doc.DocSorter`1.SortIndexConfigured">
            <summary>
            Check if the sort index has been created.
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DocSorter`1.#ctor(SEIDR.Doc.DocReader{`0},SEIDR.Doc.IRecordColumnInfo[])">
            <summary>
            Constructor. Parameters: Parameterized DocReader, column to sort on.
            </summary>
            <param name="source"></param>
            <param name="mainSort"></param>
        </member>
        <member name="M:SEIDR.Doc.DocSorter`1.#ctor(SEIDR.Doc.DocReader{`0},System.Boolean,SEIDR.Doc.IRecordColumnInfo[])">
            <summary>
            Constructor. Parameters: Parameterized DocReader, column to sort on.
            </summary>
            <param name="source"></param>
            <param name="createIndex">If true, will auto create the index at the end of construction</param>
            <param name="mainSort"></param>
        </member>
        <member name="P:SEIDR.Doc.DocSorter`1.Item(System.Int64)">
            <summary>
            Gets the record at position <paramref name="position"/> after mapping from sort. Note: If <see cref="T:SEIDR.Doc.DuplicateHandling"/> is <see cref="F:SEIDR.Doc.DuplicateHandling.Delete"/>, result may be null.
            </summary>
            <param name="position"></param>
            <returns></returns>
        </member>
        <member name="P:SEIDR.Doc.DocSorter`1.Item(System.Int32,System.Int32)">
            <summary>
            Gets the record at position <paramref name="page"/>/<paramref name="pageLine"/> after mapping from sort. Note: If <see cref="T:SEIDR.Doc.DuplicateHandling"/> is <see cref="F:SEIDR.Doc.DuplicateHandling.Delete"/>, result may be null.
            </summary> 
            <param name="page"></param>
            <param name="pageLine"></param>
            <returns></returns>
        </member>
        <member name="P:SEIDR.Doc.DocSorter`1.Item(System.Int32,System.Int32,SEIDR.Doc.IRecordColumnInfo)">
            <summary>
            Gets the line
            </summary>
            <param name="page"></param>
            <param name="pageLine"></param>
            <param name="columnInfo"></param>
            <returns></returns>
        </member>
        <member name="P:SEIDR.Doc.DocSorter`1.Item(System.Int64,SEIDR.Doc.IRecordColumnInfo)">
            <summary>
            Gets the line
            </summary>
            <param name="line">Line number in the entire file</param>
            <param name="columnInfo"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocSorter`1.GetPage(System.Int32)">
            <summary>
            Returns the records mapped to this index after sorting.Note: duplicate records may be marked as null and placed somewhat arbitrarily.(When index is created with <see cref="F:SEIDR.Doc.DuplicateHandling.Delete"/>)
            </summary>
            <param name="page"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocSorter`1.GetEnumerator">
            <summary>
            Enumerate records. Note: if deduping, duplicates will be returned as null.
            </summary>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocSorter`1.AddSortColumn(SEIDR.Doc.IRecordColumnInfo[])">
            <summary>
            Adds one or more column sort information to the list of columns to sort.
            </summary>
            <param name="toSort"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocSorter`1.ResetSortColumns">
            <summary>
            clears the columns associated with sorting. Does not clear the index if that has been created
            </summary>
            <returns></returns>
        </member>
        <member name="P:SEIDR.Doc.DocSorter`1.CleanIndexFile">
            <summary>
            If true, delete the index file during <see cref="M:SEIDR.Doc.DocSorter`1.Dispose(System.Boolean)"/>
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DocSorter`1.Dispose">
            <summary>
            IDisposable support
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DocSorter`1.DeleteSortIndex">
            <summary>
            Deletes the sort index associated with the DocReader's file.
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DocSorter`1.CreateSortIndex(SEIDR.Doc.DuplicateHandling)">
            <summary>
            Creates the sort index for pulling data from the initially passed <see cref="T:SEIDR.Doc.DocReader`1"/>
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DocSorter`1.WriteToFile(SEIDR.Doc.DocMetaData,System.Int32)">
            <summary>
            Writes the index to a specified file path. Somewhat optimized compared to using the enumerator to write loop through records and write
            </summary>
            <param name="destination"></param>
            <param name="indexCache"></param>
        </member>
        <member name="M:SEIDR.Doc.DocSorter`1.WriteToFile(System.String)">
            <summary>
            Writes the index to a specified file path. Somewhat optimized compared to using the enumerator to write loop through records and write
            </summary>
            <param name="filePath"></param>
        </member>
        <member name="M:SEIDR.Doc.DocSorter`1.WriteToFile(System.String,System.String)">
            <summary>
            Writes the index to a specified file path. Somewhat optimized compared to using the enumerator to write loop through records and write
            </summary>
            <param name="folder"></param>
            <param name="fileName"></param>
        </member>
        <member name="T:SEIDR.Doc.DocSorter">
            <summary>
            Default DocSorter, for <see cref="T:SEIDR.Doc.DocRecord"/> collection
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DocSorter.#ctor(SEIDR.Doc.DocReader,SEIDR.Doc.IRecordColumnInfo[])">
            <summary>
            Constructor with DocReader, columns to sort on
            </summary>
            <param name="source"></param>
            <param name="mainSort">Sort columns</param>
        </member>
        <member name="M:SEIDR.Doc.DocSorter.#ctor(SEIDR.Doc.DocReader,System.Boolean,SEIDR.Doc.IRecordColumnInfo[])">
            <summary>
            Constructor with DocReader, columns to sort on
            </summary>
            <param name="source"></param>
            <param name="createIndexFile">If true, will auto create the index at the end of construction</param>
            <param name="mainSort">Sort columns</param>
        </member>
        <member name="M:SEIDR.Doc.DocSorter.#ctor(SEIDR.Doc.DocReader,System.Int32,System.Boolean,System.Boolean,SEIDR.Doc.IRecordColumnInfo[])">
            <summary>
            Constructor with DocReader, columns to sort on
            </summary>
            <param name="source"></param>
            <param name="pageCacheSize"></param>
            <param name="createIndexFile">If true, will auto create the index at the end of construction</param>
            <param name="disposeCleansIndex">If true, <see cref="M:SEIDR.Doc.DocSorter`1.Dispose"/> will also delete the sort index file.</param>
            <param name="mainSort">Sort columns</param>
        </member>
        <member name="M:SEIDR.Doc.DocSorter.#ctor(SEIDR.Doc.DocReader,System.Int32,System.Boolean,System.Boolean,SEIDR.Doc.DuplicateHandling,SEIDR.Doc.IRecordColumnInfo[])">
            <summary>
            Constructor with DocReader, columns to sort on
            </summary>
            <param name="source"></param>
            <param name="pageCacheSize"></param>
            <param name="createIndexFile">If true, will auto create the index at the end of construction</param>
            <param name="disposeCleansIndex">If true, <see cref="M:SEIDR.Doc.DocSorter`1.Dispose"/> will also delete the sort index file.</param>
            <param name="handling">Determines what to do when duplicate records are found based on sorting. Note: Handled in the index logic.</param>
            <param name="mainSort">Sort columns</param>
        </member>
        <member name="M:SEIDR.Doc.DocWriter.op_Implicit(SEIDR.Doc.DocWriter)~SEIDR.Doc.DocMetaData">
            <summary>
            Allow treating the doc writer as a DocMetaData to help keep code more succinct
            </summary>
            <param name="writer"></param>
        </member>
        <member name="M:SEIDR.Doc.DocWriter.op_Implicit(SEIDR.Doc.DocWriter)~SEIDR.Doc.DocRecordColumnCollection">
            <summary>
            Allow treating the writer as a column colleciton to help keep code more succinct
            </summary>
            <param name="writer"></param>
        </member>
        <member name="M:SEIDR.Doc.DocWriter.SetTextQualify(System.Boolean,System.String[])">
            <summary>
            Sets whether or not qualify listed columns as text when writing. Default is false.<para>Note: Ignored in FixedWidth</para>
            </summary>
            <param name="qualifying"></param>
            <param name="columnsToQualify"></param>
        </member>
        <member name="P:SEIDR.Doc.DocWriter.Columns">
            <summary>
            Sets whether or not qualify listed columns as text when writing. Default is false.<para>Note: Ignored in FixedWidth</para>
            </summary>
        </member>
        <member name="T:SEIDR.Doc.DocWriter`1">
            <summary>
            Helper using DocMetaData to wrap a StreamWriter and write metaData to a file
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DocWriter`1.AddRecord(SEIDR.Doc.IDataRecord)">
            <summary>
            Adds record to output.
            </summary>
            <param name="record"></param>
        </member>
        <member name="P:SEIDR.Doc.DocWriter`1.FixedWidthMode">
            <summary>
            True if the file being written to is being written with columns having fixed widths and positions.
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DocWriter`1.TextQualifier">
            <summary>
            Sets the textQualifier. Default is null
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DocWriter`1.sw">
            <summary>
            Column meta Data
            </summary>
        </member>
        <member name="F:SEIDR.Doc.DocWriter`1.md">
            <summary>
            Calls <see cref="!:AddRecord&lt;RecordType&gt;(RecordType, IDictionary&lt;int, DocRecordColumnInfo&gt;)"/> using the DocWriter's underlying dictionary.
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DocWriter`1.#ctor(`0,System.Boolean,System.Int32)">
            <summary>
            Adds the record to the file via streamWriter
            </summary>
            <param name="metaData"></param>
            <param name="AppendIfExists"></param>
            <param name="bufferSize">Initial buffer size for underlying stream in KB. 
            <para>Note: can be forced to grow, which can be expensive according to https://stackoverflow.com/questions/32346051/what-does-buffer-size-mean-when-streaming-text-to-a-file. </para>
            <para>Adding one line at a time, though, so should probably choose based on max size of a line </para>
            <para>May also need to consider whether you're writing locally or on a network.</para></param>
        </member>
        <member name="M:SEIDR.Doc.DocWriter`1.BulkWrite(System.Collections.Generic.IEnumerable{SEIDR.Doc.IDataRecord})">
            <summary>
            Writes the records out using ToString without validating that they match the column meta data of the writer.
            <para>Null records will be ignored unless the meta data allows null records.</para>
            </summary>
            <param name="toWrite"></param>
        </member>
        <member name="M:SEIDR.Doc.DocWriter`1.BulkWrite(SEIDR.Doc.IDataRecord[])">
            <summary>
            Writes the records out using ToString without validating that they match the column meta data of the writer.
            </summary>
            <param name="toWrite"></param>
        </member>
        <member name="M:SEIDR.Doc.DocWriter`1.BulkWrite(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Writes the strings out without validating that they match the column meta data of the writer. Will add the LineEndDelimiter of this metaData if specified, though.
            <para>NOTE: THIS IGNORES METADATA EXCEPT FOR LINE END DELIMITER.</para>
            <para>If meta Data does not have a line end delimiter, then it will *NOT* add one.</para>
            </summary>
            <param name="Lines"></param>
        </member>
        <member name="M:SEIDR.Doc.DocWriter`1.BulkWrite(System.String[])">
            <summary>
            Writes the strings out without validating that they match the column meta data of the writer. Will add the LineEndDelimiter of this metaData if specified, though.
            <para>NOTE: THIS IGNORES METADATA.</para>
            </summary>
            <param name="Lines"></param>
        </member>
        <member name="M:SEIDR.Doc.DocWriter`1.AddRecord(System.String)">
            <summary>
            Adds record to the file via underlying streamWriter
            </summary>
            <param name="record"></param>
        </member>
        <member name="M:SEIDR.Doc.DocWriter`1.AddRecord(System.Text.StringBuilder)">
            <summary>
            Adds a StringBuilder to the output Document
            </summary>
            <param name="sbRecord"></param>
        </member>
        <member name="M:SEIDR.Doc.DocWriter`1.BulkAdd(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Parses the strings and maps them using this collection's MetaData. Will add the LineEndDelimiter of this metaData if specified, though.
            </summary>
            <param name="Lines"></param>
        </member>
        <member name="M:SEIDR.Doc.DocWriter`1.BulkAdd(System.String[])">
            <summary>
            Parses the strings and maps them using this collection's MetaData. Will add the LineEndDelimiter of this metaData if specified, though.
            </summary>
            <param name="Lines"></param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:SEIDR.Doc.DocWriter`1.AddDocRecord(SEIDR.Doc.DocRecord,SEIDR.Doc.DocWriterMap)" -->
        <member name="M:SEIDR.Doc.DocWriter`1.AddDocRecord(SEIDR.Doc.DocRecord,System.Collections.Generic.IDictionary{System.Int32,SEIDR.Doc.DocRecordColumnInfo})">
            <summary>
            Adds the record to the file via streamWriter
            </summary>
            <param name="record"></param>
            <param name="columnMapping">Optional mapping override. Positions can be set to null or ignored to use the default mapping. 
            <para>Key should be the target position in the output file, value should be the column information from the source.
            </para>
            </param>
        </member>
        <member name="T:SEIDR.Doc.DocWriterMap">
            <summary>
            Helper class for mapping data from one column collection to another for a DocWriter
            </summary>
        </member>
        <member name="F:SEIDR.Doc.DocWriterMap.MapData">
            <summary>
            Underlying column mapping dictionary
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DocWriterMap.#ctor(SEIDR.Doc.DocWriter,SEIDR.Doc.DocRecordColumnCollection)">
            <summary>
            Helper class for mapping data from one column collection to another for a DocWriter
            </summary>
            <param name="mapTo"></param>
            <param name="mapFrom"></param>
        </member>
        <member name="M:SEIDR.Doc.DocWriterMap.AddMapping(System.Int32,System.Int32)">
            <summary>
            Adds a column mapping to the undedrlying dictionary
            </summary>
            <param name="fromColumnPosition"></param>
            <param name="toColumnPosition"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocWriterMap.AddMapping(SEIDR.Doc.DocRecordColumnInfo,System.Int32)">
            <summary>
            Adds a new mapping to the underlying dictionary
            </summary>
            <param name="from"></param>
            <param name="toColumnPosition"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocWriterMap.SetMapping(System.Int32,System.Int32)">
            <summary>
            Sets a column mapping in the underlying dictionary
            </summary>
            <param name="fromColumnPosition"></param>
            <param name="toColumnPosition"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocWriterMap.SetMapping(SEIDR.Doc.DocRecordColumnInfo,System.Int32)">
            <summary>
            Sets a column mapping in the underlying dictionary
            </summary>
            <param name="from"></param>
            <param name="toColumnPosition"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocWriterMap.AddMapping(System.String,System.String,System.String,System.String)">
            <summary>
            Adds a Column mapping to the underlying dictionary
            </summary>
            <param name="fromColumnName"></param>
            <param name="ToColumnName"></param>
            <param name="fromAlias"></param>
            <param name="toAlias"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocWriterMap.SetMapping(System.String,System.String,System.String,System.String)">
            <summary>
            Sets a mapping in the underlying dictionary
            </summary>
            <param name="fromColumnName"></param>
            <param name="ToColumnName"></param>
            <param name="fromAlias"></param>
            <param name="toAlias"></param>
            <returns></returns>
        </member>
        <member name="T:SEIDR.Doc.DuplicateHandling">
            <summary>
            Handling for duplicates when creating the index file.
            </summary>
        </member>
        <member name="F:SEIDR.Doc.DuplicateHandling.Ignore">
            <summary>
            Do nothing when a duplicate appears
            </summary>
        </member>
        <member name="F:SEIDR.Doc.DuplicateHandling.Delete">
            <summary>
            Remove duplicates
            </summary>
        </member>
        <member name="F:SEIDR.Doc.DuplicateHandling.Exception">
            <summary>
            Throw an exception if a duplicate is found.
            </summary>
        </member>
        <member name="T:SEIDR.Doc.DuplicateRecordException">
            <summary>
            Thrown when an instance of <see cref="T:SEIDR.Doc.DocSorter`1"/> finds a duplicate when creating an index with mode <see cref="F:SEIDR.Doc.DuplicateHandling.Exception"/> 
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DuplicateRecordException.#ctor(System.String)">
            <summary>
            Thrown when an instance of <see cref="T:SEIDR.Doc.DocSorter`1"/> finds a duplicate when creating an index with mode <see cref="F:SEIDR.Doc.DuplicateHandling.Exception"/> 
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:SEIDR.Doc.FormatHelper.DelimiterHelper.InferColumnList(System.String,SEIDR.Doc.MetaDataBase,System.Boolean,System.Int32@)">
            <summary>
            Infer column information for a delimited file
            </summary>
            <param name="ContentLine"></param>
            <param name="metaData"></param>
            <param name="CheckTextQualifier"></param>
            <param name="startPosition"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.FormatHelper.DelimiterHelper.GetSkipPosition(System.String,System.String[],System.Boolean,SEIDR.Doc.MetaDataBase,System.Int32,System.Boolean)">
            <summary>
            Get starting byte position after skipping X lines.
            </summary>
            <param name="content"></param>
            <param name="delimiterList"></param>
            <param name="CheckTextQualifier"></param>
            <param name="metaData"></param>
            <param name="skipLines"></param>
            <param name="skipEmpty"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.FormatHelper.FixWidthHelper.InferColumnset(System.Collections.Generic.IList{System.String},SEIDR.Doc.MetaDataBase)">
            <summary>
            Attempt to infer a column set from the provided set of lines from a source file.
            <para>Could use as a starting point, export to a delimited file, manually correct, and then import the column information using <see cref="M:SEIDR.Doc.DocRecordColumnCollection.ParseFromIRecordSet(System.String,System.Collections.Generic.IEnumerable{SEIDR.Doc.IDataRecord})"/>
            </para><para>Note that a DocReader would fit the second parameter.</para>
            </summary>
            <param name="lineSource"></param>
            <param name="metaData"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.IDataRecord.HasColumn(System.String)">
            <summary>
            Returns whether or not the IDataRecord has a column name, regardless of alias.
            </summary>
            <param name="ColumnName"></param>
            <returns></returns>
        </member>
        <member name="P:SEIDR.Doc.IDataRecord.ID">
            <summary>
            ID for data record from its source (if provided).
            <para>Should be zero-based, but usage depends on source that populates the record.</para>        
            </summary>
        </member>
        <member name="T:SEIDR.Doc.MetaDataBase">
            <summary>
            Base class for meta data when reading/writing files. 
            <para>Implementations should be internal only.</para>
            </summary>
        </member>
        <member name="P:SEIDR.Doc.MetaDataBase.TrustPreamble">
            <summary>
            Indicates that we should trust the preamble to cover any control characters at the beginning.
            <para>Any control characters beside the preamble are expected and for the data, if true.</para>
            </summary>
        </member>
        <member name="P:SEIDR.Doc.MetaDataBase.AllowNullRecords">
            <summary>
            Sets whether or not to allow a reader or writer to include null as a record.
            </summary>
        </member>
        <member name="M:SEIDR.Doc.MetaDataBase.SetAllowNullRecords(System.Boolean)">
            <summary>
            Sets whether or not to allow a reader or writer to include null as a record.
            </summary>
            <param name="allowNull"></param>
            <returns></returns>
        </member>
        <member name="F:SEIDR.Doc.MetaDataBase.QuoteEscape">
            <summary>
            Character to use for escaping quotes when splitting lines/columns.
            </summary>
        </member>
        <member name="M:SEIDR.Doc.MetaDataBase.SetQuoteEscape(System.Char)">
            <summary>
            Sets the character for escaping the TextQualifier.
            </summary>
            <param name="escape"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.MetaDataBase.CleanQuotes(System.String)">
            <summary>
            Cleans quotes out from a value, unless they're escaped or in the middle of a line.
            <para>Quotes that were escaped will have their escape removed.</para>
            <para>NOTE: This only does anything if <see cref="P:SEIDR.Doc.MetaDataBase.AllowQuoteEscape"/> is true (default = false)</para>
            </summary>
            <param name="source"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.MetaDataBase.EscapeQuoteValues(System.String)">
            <summary>
            Escape the quotes within a string.
            /// <para>NOTE: This only does anything if <see cref="P:SEIDR.Doc.MetaDataBase.AllowQuoteEscape"/> is true (default = false)</para>
            </summary>
            <param name="source"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.MetaDataBase.CheckFormatValid(System.IO.FileAccess)">
            <summary>
            Perform basic checks to make sure meta Data is valid.
            </summary>
            <param name="mode"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.MetaDataBase.GetRecordColumnInfos(System.String)">
            <summary>
            Gets the Column collection to associate with a line of the file.
            <para>Note: the parameter is called <paramref name="DocumentLine"/>, but it should also be okay to pass just the key column's value.</para>
            </summary>
            <param name="DocumentLine"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.MetaDataBase.GetRecordColumnInfos(SEIDR.Doc.IDataRecord)">
            <summary>
            Gets the Column collection to associate with a line of the file.
            </summary>
            <param name="record"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.MetaDataBase.Parse(System.String)">
            <summary>
            Parses a line from a document and returns a DocRecord.
            </summary>
            <param name="DocumentLine"></param>
            <returns></returns>
        </member>
        <member name="F:SEIDR.Doc.MetaDataBase.FilePath">
            <summary>
            Full path of the file being described.
            </summary>
        </member>
        <member name="P:SEIDR.Doc.MetaDataBase.Directory">
            <summary>
            Gets the name of the directory for the specified path (<see cref="F:SEIDR.Doc.MetaDataBase.FilePath"/>)
            </summary>
        </member>
        <member name="P:SEIDR.Doc.MetaDataBase.FileName">
            <summary>
            Returns name of file at specified path. (<see cref="F:SEIDR.Doc.MetaDataBase.FilePath"/>)
            </summary>
        </member>
        <member name="F:SEIDR.Doc.MetaDataBase.Alias">
            <summary>
            Used for associating column information to an originating file when merging column collections
            </summary>
        </member>
        <member name="P:SEIDR.Doc.MetaDataBase.HasHeader">
            <summary>
            If true, first line of the file after skip lines should be the header. If the header has been configured already, this also means that an additional line will be skipped so that we don't read the header as a normal line.
            </summary>
        </member>
        <member name="P:SEIDR.Doc.MetaDataBase.HeaderConfigured">
            <summary>
            Indicates that the Header is ready to use, if <see cref="P:SEIDR.Doc.MetaDataBase.HasHeader"/> is true.
            </summary>
        </member>
        <member name="M:SEIDR.Doc.MetaDataBase.GetHeader">
            <summary>
            Gets the header as a string. Should ONLY be called if HasHeader is true.
            </summary>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.MetaDataBase.SetEmptyIsNull(System.Boolean,System.Boolean)">
            <summary>
            Sets <see cref="P:SEIDR.Doc.DocRecordColumnCollection.DefaultNullIfEmpty"/> and <see cref="P:SEIDR.Doc.DocRecordColumnInfo.NullIfEmpty"/> for any columns associated with underlying collections.
            </summary>
            <param name="nullifyEmpty"></param>
            <param name="SetDefault">If false, just sets the values on individual columns, not the collection's default.</param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.MetaDataBase.SetEmptyIsNull(System.Boolean,System.Predicate{SEIDR.Doc.DocRecordColumnInfo},System.Boolean)">
            <summary>
            Sets <see cref="P:SEIDR.Doc.DocRecordColumnCollection.DefaultNullIfEmpty"/>, and conditionally sets <see cref="P:SEIDR.Doc.DocRecordColumnInfo.NullIfEmpty"/> for any columns that match the predicate.
            </summary>
            <param name="NullifyEmpty"></param>
            <param name="columnPredicate"></param>
            <param name="SetDefault">If false, just sets the values on individual columns, not the collection's default.</param>
            <returns></returns>
        </member>
        <member name="P:SEIDR.Doc.MetaDataBase.Valid">
            <summary>
            Indicates if the MetaData is in a valid state for usage.
            </summary>
        </member>
        <member name="P:SEIDR.Doc.MetaDataBase.TESTMODE">
            <summary>
            Removes minimum on PageSize. Setting pageSize below the min is silently ignored outside of TestMode
            </summary>
        </member>
        <member name="P:SEIDR.Doc.MetaDataBase.SkipLines">
            <summary>
            Number of lines to skip at the start of the file when reading. Does not include the header's line
            </summary>
        </member>
        <member name="M:SEIDR.Doc.MetaDataBase.SetSkipLines(System.Int32)">
            <summary>
            Set <see cref="P:SEIDR.Doc.MetaDataBase.SkipLines"/>
            </summary>
            <param name="linesToSkip"></param>
            <returns></returns>
        </member>
        <member name="P:SEIDR.Doc.MetaDataBase.AllowQuotedNewLine">
            <summary>
            Indicates whether or to expect newlines in a text qualified column value.
            </summary>
        </member>
        <member name="P:SEIDR.Doc.MetaDataBase.Delimiter">
            <summary>
            Delimiter for columns
            </summary>
        </member>
        <member name="P:SEIDR.Doc.MetaDataBase.LineEndDelimiter">
            <summary>
            Line Ending delimiter, unless <see cref="P:SEIDR.Doc.MetaDataBase.ReadWithMultiLineEndDelimiter"/> is true.
            <para>When writing to a file, this is always used, though.</para>
            <para>Set to <see cref="P:System.Environment.NewLine"/> by default.</para>
            </summary>
        </member>
        <member name="M:SEIDR.Doc.MetaDataBase.SetDelimiter(System.Char,SEIDR.Doc.DocRecordFormat)">
            <summary>
            Set delimiter.
            </summary>
            <param name="delimiter"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.MetaDataBase.SetLineEndDelimiter(System.String)">
            <summary>
            Sets the string that indicates end of records.
            </summary>
            <param name="endLine"></param>
            <returns></returns>
        </member>
        <member name="P:SEIDR.Doc.MetaDataBase.FileEncoding">
            <summary>
            File encoding
            </summary>
        </member>
        <member name="M:SEIDR.Doc.MetaDataBase.SetFileEncoding(System.Text.Encoding)">
            <summary>
            Sets the file encoding for reading and writing.
            </summary>
            <param name="fileEncoding"></param>
            <returns></returns>
        </member>
        <member name="P:SEIDR.Doc.MetaDataBase.PageSize">
            <summary>
            Max number of characters to have in a page when reading from a file
            <para>Will throw an exception if the page is too small to completely parse a line somewhere in the file</para>
            </summary>
        </member>
        <member name="F:SEIDR.Doc.MetaDataBase.DEFAULT_PAGE_SIZE">
            <summary>
            Default value for <see cref="P:SEIDR.Doc.MetaDataBase.PageSize"/> 
            </summary>
        </member>
        <member name="F:SEIDR.Doc.MetaDataBase.MIN_PAGE_SIZE">
            <summary>
            Minimum page size (in characters)
            </summary>
        </member>
        <member name="M:SEIDR.Doc.MetaDataBase.SetPageSize(System.Int32)">
            <summary>
            Sets <see cref="P:SEIDR.Doc.MetaDataBase.PageSize"/> 
            </summary>
            <param name="pageSize"></param>
            <returns></returns>
        </member>
        <member name="P:SEIDR.Doc.MetaDataBase.AccessMode">
            <summary>
            Access mode for file opening. Indicates whether the DocMetaData will be used for Doc reading or doc writing
            </summary>
        </member>
        <member name="P:SEIDR.Doc.MetaDataBase.CanWrite">
            <summary>
            If true, allow writing.
            </summary>
        </member>
        <member name="M:SEIDR.Doc.MetaDataBase.SetCanWrite(System.Boolean)">
            <summary>
            Sets whether or not to allow Modifying DocRecords that are parsed using this metaData
            </summary>
            <param name="CanWrite"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.MetaDataBase.SetFileAccess(System.IO.FileAccess)">
            <returns></returns>
        </member>
        <member name="P:SEIDR.Doc.MetaDataBase.MultiLineEndDelimiter">
            <summary>
            If there are multiple possible line endings when reading.
            </summary>
        </member>
        <member name="M:SEIDR.Doc.MetaDataBase.ClearMultiLineEndDelimiter">
            <summary>
            Clears the multli line end delimiter
            </summary>
        </member>
        <member name="M:SEIDR.Doc.MetaDataBase.SetMultiLineEndDelimiters(System.String[])">
            <summary>
            Use if there may be a mixture of /r/n, /r, /n, etc   
            </summary>
            <param name="endings"></param>
        </member>
        <member name="P:SEIDR.Doc.MetaDataBase.ReadWithMultiLineEndDelimiter">
            <summary>
            Indicates if the MutliLineEnd Delimiter information should be used by DocReader instances. True if there is more than one line ending in the <see cref="P:SEIDR.Doc.MetaDataBase.MultiLineEndDelimiter"/> array.
            </summary>
        </member>
        <member name="M:SEIDR.Doc.MetaDataBase.AddMultiLineEndDelimiter(System.String[])">
            <summary>
            Adds the strings to <see cref="P:SEIDR.Doc.MetaDataBase.MultiLineEndDelimiter"/>, and sorts it so that super sets are earlier. 
            <para>E.g., ensures \r\n comes before \r or \n, while the order of \r and \n are arbitrary.</para>
            </summary>
            <param name="endingToAdd"></param>
            <returns></returns>
        </member>
        <member name="P:SEIDR.Doc.MetaDataBase.FileLength">
            <summary>
            Gets the length of the file, cached.
            </summary>
        </member>
        <member name="P:SEIDR.Doc.MetaDataBase.FileHash">
            <summary>
            Returns a hash of the file content, based on <see cref="M:SEIDR.Doc.DocExtensions.GetFileHash(System.IO.FileInfo)"/>
            </summary>
        </member>
        <member name="M:SEIDR.Doc.MetaDataBase.RefreshFileHash">
            <summary>
            Removes the cached filehash and returns a fresh evaluation of <see cref="P:SEIDR.Doc.MetaDataBase.FileHash"/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.MetaDataBase.RefreshFileSize">
            <summary>
            Removes the cached file length.
            </summary>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.MetaDataBase.CheckExists">
            <summary>
            Check if the file exists
            </summary>
            <returns></returns>
        </member>
        <member name="P:SEIDR.Doc.MetaDataBase.Format">
            <summary>
            Format for reading/writing from a file.
            </summary>
        </member>
        <member name="M:SEIDR.Doc.MetaDataBase.SetFormat(SEIDR.Doc.DocRecordFormat)">
            <summary>
            Sets the <see cref="P:SEIDR.Doc.MetaDataBase.Format"/>. Implementations of MetaDataBase may perform validations when setting.
            </summary>
            <param name="NewFormat"></param>
            <returns></returns>
        </member>
        <member name="P:SEIDR.Doc.MetaDataBase.FixWidthMode">
            <summary>
            Indicates whether or not the file should be treated as FixedWidth
            </summary>
        </member>
        <member name="P:SEIDR.Doc.MetaDataBase.VariableWidthMode">
            <summary>
            Variable width - FixWidth limit but allow using delimiters to end a column early.
            </summary>
        </member>
        <member name="P:SEIDR.Doc.MetaDataBase.RaggedRightMode">
            <summary>
            Fix width, but the last column does not need to be full length.
            </summary>
        </member>
        <member name="P:SEIDR.Doc.MetaDataBase.TextQualifier">
            <summary>
            Use when individual column metadata indicates to use text qualifiers to surround column content inside a delimited setting. Not used with FixWidth/Ragged Right
            <para>Note: Cannot be null - will default to " if not provided.</para>
            </summary>
        </member>
        <member name="M:SEIDR.Doc.MetaDataBase.SetTextQualifier(System.String)">
            <summary>
            Sets the Text Qualifier for writing, or formatting a DocRecord as a string.
            </summary>
            <param name="TextQual"></param>
            <returns></returns>
        </member>
        <member name="P:SEIDR.Doc.MetaDataBase.AllowMissingColumns">
            <summary>
            Doesn't throw <see cref="T:SEIDR.Doc.MissingColumnException"/> when the number of columns is lower than expected.
            </summary>
        </member>
        <member name="M:SEIDR.Doc.MetaDataBase.ParseRecord(System.Boolean,System.String)">
            <summary>
            Parses a DocRecord out of the string. The string should end at <see cref="P:SEIDR.Doc.MetaDataBase.LineEndDelimiter"/>, but not include it.
            </summary>
            <param name="writeMode"></param>
            <param name="record"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.MetaDataBase.ParseRecord``1(System.String)">
            <summary>
            Parses a DocRecord out of the string. The string should end at <see cref="P:SEIDR.Doc.MetaDataBase.LineEndDelimiter"/>, but not include it.
            </summary>
            <param name="record"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.MetaDataBase.ParseRecord``1(System.Boolean,System.String)">
            <summary>
            Parses a DocRecord out of the string. The string should end at <see cref="P:SEIDR.Doc.MetaDataBase.LineEndDelimiter"/>, but not include it.
            </summary>
            <param name="writeMode"></param>
            <param name="record"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.MetaDataBase.ParseRecord(System.String)">
            <summary>
            Parses the record into a list of strings, for use with one of the DocRecord constructors (mainly, when using a class that inherits from DocRecord) 
            </summary>
            <param name="record"></param>
            <returns>IList of strings separated by delimiter. Or based on column sizes in fixed width mode.</returns>
        </member>
        <member name="P:SEIDR.Doc.MetaDataBase.ThrowExceptionColumnCountMismatch">
            <summary>
            If true, throws an exception if the size of a record is too big or too small, based on number of records.
            <para>If false, ignores extra columns, and missing columns are treated as null</para>
            </summary>
        </member>
        <member name="M:SEIDR.Doc.MetaDataBase.SetThrowExceptionOnColumnCountMismatch(System.Boolean)">
            <summary>
            Set whether or not to throw exceptions if the column count doesn't match expected.
            </summary>
            <param name="throwMismatch"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.MetaDataBase.FormatRecord(SEIDR.Doc.IDataRecord,System.Boolean,System.Collections.Generic.IDictionary{System.Int32,SEIDR.Doc.DocRecordColumnInfo})">
            <summary>
            Maps DocRecord to a string for writing out into a file.
            </summary>
            <param name="record"></param>
            <param name="IncludeLineEndDelimiter"></param>
            <param name="columnMapping"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.MetaDataBase.LinkColumnSet(SEIDR.Doc.DocRecordColumnCollection)">
            <summary>
            Links a column set to the metadata, overriding whatever the current column set is.
            </summary>
            <param name="columnSet"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.MetaDataBase.CheckAddLineDelimiter(System.Text.StringBuilder)">
            <summary>
            Conditionally adds a LineEnd delimiter.
            <para>If <see cref="P:SEIDR.Doc.MetaDataBase.LineEndDelimiter"/> is not null, then that will be added.</para>
            <para>Else, will add <see cref="P:System.Environment.NewLine"/>, unless the <see cref="P:SEIDR.Doc.MetaDataBase.Format"/> is either <see cref="F:SEIDR.Doc.DocRecordFormat.FIX_WIDTH"/> or <see cref="F:SEIDR.Doc.DocRecordFormat.SBSON"/></para>
            </summary>
            <param name="sb"></param>
        </member>
        <member name="M:SEIDR.Doc.MetaDataBase.GetBasicRecord">
            <summary>
            Gets a basic DocRecord to that can be used (e.g. for adding new content to a DocWriter)
            </summary>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.MetaDataBase.GetBasicTypedDataRecord">
            <summary>
            Gets a basic TypedDataRecord that can be used.
            </summary>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.MetaDataBase.FormatNullRecord">
            <summary>
            Formats a string for a null record.
            </summary>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.MetaDataBase.FormatRecord(SEIDR.Doc.IDataRecord,System.Boolean)">
            <summary>
            Formats a record for writing to output.
            </summary>
            <param name="record"></param>
            <param name="IncludeLineEndDelimiter"></param>
            <returns></returns>
        </member>
        <member name="T:SEIDR.Doc.MultiRecordDocMetaData">
            <summary>
            MetaData for a Doc file containing multiple sets
            </summary>
        </member>
        <member name="M:SEIDR.Doc.MultiRecordDocMetaData.LinkColumnSet(SEIDR.Doc.DocRecordColumnCollection)">
            <summary>
            Sets the default column set. 
            <para>If you want to set the column set to a speecific key - use <see cref="M:SEIDR.Doc.MultiRecordDocMetaData.SetCollection(System.String,SEIDR.Doc.DocRecordColumnCollection)"/>
            </para>
            </summary>
            <param name="columnSet"></param>
            <returns></returns>
        </member>
        <member name="F:SEIDR.Doc.MultiRecordDocMetaData.DEFAULT_KEY_NAME">
            <summary>
            Default column name for the Key Column (First column)
            </summary>
        </member>
        <member name="P:SEIDR.Doc.MultiRecordDocMetaData.Item(System.String)">
            <summary>
            Attempts to get the DocRecordColumn Collection associated with the key. 
            <para>If the key has not been added yet, it is added.</para>
            </summary>
            <param name="Key"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.MultiRecordDocMetaData.SetCollection(System.String,SEIDR.Doc.DocRecordColumnCollection)">
            <summary>
            Adds or overwrites the column set associated with the given key
            </summary>
            <param name="key"></param>
            <param name="colSet"></param>
            <returns></returns>
        </member>
        <member name="F:SEIDR.Doc.MultiRecordDocMetaData.DEFAULT_KEY">
            <summary>
            Default key to use if no match.
            </summary>
        </member>
        <member name="P:SEIDR.Doc.MultiRecordDocMetaData.ColumnSets">
            <summary>
            Key Identifiers for various column sets in the file.
            <para>Key will be compared against file data using <see cref="M:SEIDR.BaseExtensions.Like(System.String,System.String,System.Boolean)"/> (Regular Expressions NOT escaped)</para>
            <para>NULL should be used as a key for default collection, if relevant.</para>
            </summary>
        </member>
        <member name="M:SEIDR.Doc.MultiRecordDocMetaData.GetBasicRecord">
            <summary>
            Gets a DocRecord using the default Column Collection (<see cref="F:SEIDR.Doc.MultiRecordDocMetaData.DEFAULT_KEY"/> ). If there is no default key, return null.
            </summary>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.MultiRecordDocMetaData.GetBasicTypedDataRecord">
            <summary>
            Gets a basic TypedDataRecord that can be used. Associates with the default column collection (<see cref="F:SEIDR.Doc.MultiRecordDocMetaData.DEFAULT_KEY"/>, or returns null.
            </summary>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.MultiRecordDocMetaData.GetBasicRecord(System.String)">
            <summary>
            Gets a DocRecord using a column collection associated with the key. Will error if there is no matching key.
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.MultiRecordDocMetaData.GetRecordColumnInfos(System.String)">
            <summary>
            Attempt to Get the appropriate column set for a line of a file.
            </summary>
            <param name="DocLine"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.MultiRecordDocMetaData.SetEmptyIsNull(System.Boolean,System.Boolean)">
            <summary>
            Sets <see cref="P:SEIDR.Doc.DocRecordColumnCollection.DefaultNullIfEmpty"/>,
            and also sets the <see cref="P:SEIDR.Doc.DocRecordColumnInfo.NullIfEmpty"/> for each column associated with the ColumnCollection
            </summary>
            <param name="nullifyEmpty"></param>
            <param name="SetDefault">If false, just sets the values on individual columns, not the collection's default.</param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.MultiRecordDocMetaData.SetEmptyIsNull(System.Boolean,System.Predicate{SEIDR.Doc.DocRecordColumnInfo},System.Boolean)">
            <summary>
            Sets <see cref="P:SEIDR.Doc.DocRecordColumnCollection.DefaultNullIfEmpty"/>,
            and also (conditionally) sets the <see cref="P:SEIDR.Doc.DocRecordColumnInfo.NullIfEmpty"/> for each column associated with the ColumnCollection that matches <paramref name="columnPredicate"/>.
            
            </summary>
            <param name="NullifyEmpty"></param>
            <param name="columnPredicate"></param>
            <param name="SetDefault">If false, just sets the values on individual columns, not the collection's default.</param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.MultiRecordDocMetaData.GetRecordColumnInfos(SEIDR.Doc.IDataRecord)">
            <summary>
            Returns the Column Collection that matches this record, based on the key.
            </summary>
            <param name="record"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.MultiRecordDocMetaData.#ctor(System.String,System.String)">
            <summary>
            MetaData for reading a file with multiple record types. (First Column data should specify which column set to use)
            </summary>
            <param name="FilePath"></param>
            <param name="Alias"></param>
        </member>
        <member name="P:SEIDR.Doc.MultiRecordDocMetaData.HasHeader">
            <summary>
            Indicates that file has header information contained - hard coded to false as this doesn't really make sense for multi record.
            <para>Call <see cref="M:SEIDR.Doc.MetaDataBase.SetSkipLines(System.Int32)"/> if needed.</para>
            </summary>
        </member>
        <member name="P:SEIDR.Doc.MultiRecordDocMetaData.HeaderConfigured">
            <summary>
            No support for headers in MultiRecord. SKip lines with <see cref="P:SEIDR.Doc.MetaDataBase.SkipLines"/> if needed.
            </summary>
        </member>
        <member name="P:SEIDR.Doc.MultiRecordDocMetaData.Valid">
            <summary>
            Confirm that underlying column information is valid.
            </summary>
        </member>
        <member name="M:SEIDR.Doc.MultiRecordDocMetaData.GetHeader">
            <summary>
            Do not call for MultiRecord - Headers are not supported.
            </summary>
            <returns></returns>
        </member>
        <member name="T:SEIDR.Doc.RecordChangedEventArgs">
            <summary>
            Record event changed.
            </summary>
        </member>
        <member name="P:SEIDR.Doc.RecordChangedEventArgs.ColumnChanged">
            <summary>
            Column that was changed.
            </summary>
        </member>
        <member name="P:SEIDR.Doc.RecordChangedEventArgs.OldValue">
            <summary>
            Value that column was changed from
            </summary>
        </member>
        <member name="P:SEIDR.Doc.RecordChangedEventArgs.NewValue">
            <summary>
            Value that column was changed to.
            </summary>
        </member>
        <member name="M:SEIDR.Doc.RecordChangedEventArgs.#ctor(SEIDR.Doc.DocRecordColumnInfo,System.String,System.String)">
            <summary>
            Args passed to event handlers when a DocRecord column value is changed.
            <para>(DocRecord will be the event's sender)</para>
            </summary>
            <param name="columnModified"></param>
            <param name="oldValue"></param>
            <param name="newValue"></param>
        </member>
        <member name="T:SEIDR.Doc.TypedRecordChangedEventArgs">
            <summary>
            For responding when a <see cref="T:SEIDR.Doc.TypedDataRecord"/> is modified.
            </summary>
        </member>
        <member name="T:SEIDR.Doc.SortColumn">
            <summary>
            Basic helper for <see cref="T:SEIDR.Doc.DocSorter"/>
            </summary>
        </member>
        <member name="P:SEIDR.Doc.SortColumn.SortASC">
            <summary>
            Sort order for <see cref="T:SEIDR.Doc.DocSorter"/>
            </summary>
        </member>
        <member name="P:SEIDR.Doc.SortColumn.Position">
            <summary>
            Column position for getting a record from an <see cref="T:SEIDR.Doc.IRecord"/>
            </summary>
        </member>
        <member name="M:SEIDR.Doc.SortColumn.#ctor(System.Int32,System.Boolean)">
            <summary>
            Constructor
            </summary>
            <param name="position"></param>
            <param name="ascOrder"></param>
        </member>
        <member name="T:SEIDR.Doc.TypedDataRecord">
            <summary>
            Data accessor helper for reading data from files or databases.
            </summary>
        </member>
        <member name="M:SEIDR.Doc.TypedDataRecord.op_Implicit(SEIDR.Doc.TypedDataRecord)~System.Collections.Generic.Dictionary{System.String,System.Object}">
            <summary>
            Convert TypedDataRecord into a dictionary
            </summary>
            <param name="record"></param>
        </member>
        <member name="M:SEIDR.Doc.TypedDataRecord.op_Implicit(SEIDR.Doc.TypedDataRecord)~System.Collections.Generic.Dictionary{System.String,SEIDR.Doc.DataItem}">
            <summary>
            Convert TypedDataRecord into a dictionary
            </summary>
            <param name="record"></param>
        </member>
        <member name="M:SEIDR.Doc.TypedDataRecord.op_Implicit(System.Collections.Generic.Dictionary{System.String,SEIDR.Doc.DataItem})~SEIDR.Doc.TypedDataRecord">
            <summary>
            Converts a dictionary of DataItems into a TypedDataRecord that can be used to write.
            </summary>
            <param name="keyValues"></param>
        </member>
        <member name="M:SEIDR.Doc.TypedDataRecord.SetValue(SEIDR.Doc.DocRecordColumnInfo,System.Object,System.Boolean)">
            <summary>
            Sets the value in the internal content array.
            </summary>
            <param name="column"></param>
            <param name="value"></param>
            <param name="RaiseColChanged"></param>
        </member>
        <member name="E:SEIDR.Doc.TypedDataRecord.RecordChanged">
            <summary>
            Event watch for when the record has a column changed.
            </summary>
        </member>
        <member name="P:SEIDR.Doc.TypedDataRecord.CanWrite">
            <summary>
            Indicates whether or not the values can be modified.
            </summary>
        </member>
        <member name="P:SEIDR.Doc.TypedDataRecord.Columns">
            <summary>
            Column information.
            </summary>
        </member>
        <member name="P:SEIDR.Doc.TypedDataRecord.ContentCopy">
            <summary>
            For debug purposes - allows viewing a copy of the internal content.
            </summary>
        </member>
        <member name="M:SEIDR.Doc.TypedDataRecord.HasColumn(System.String,System.String)">
            <inheritdoc />
        </member>
        <member name="M:SEIDR.Doc.TypedDataRecord.HasColumn(System.String)">
            <inheritdoc />
        </member>
        <member name="M:SEIDR.Doc.TypedDataRecord.TryGet(SEIDR.Doc.DocRecordColumnInfo,System.Object@)">
            <inheritdoc />
        </member>
        <member name="M:SEIDR.Doc.TypedDataRecord.TryGet(System.String,System.Object@,System.String)">
            <inheritdoc />
        </member>
        <member name="P:SEIDR.Doc.TypedDataRecord.KeyValues">
            <summary>
            Represent object as list of key values. For debug purposes.
            </summary>
        </member>
        <member name="P:SEIDR.Doc.TypedDataRecord.KeyValuesAlphabetical">
            <summary>
            Represent object as list of key values, sorted by column name. For debug purposes.
            </summary>
        </member>
        <member name="M:SEIDR.Doc.TypedDataRecord.Map(SEIDR.Doc.DocRecordColumnCollection,System.Object)">
            <summary>
            Attempts to map the object to a TypedDataRecord based on the passed set of columns and getter properties on the object.
            <para>Note: affected by attributes such as <see cref="T:SEIDR.DataBase.DatabaseManagerIgnoreMappingAttribute"/> and <see cref="T:SEIDR.DataBase.DatabaseManagerFieldMappingAttribute"/></para>
            </summary>
            <param name="columnInfos"></param>
            <param name="source"></param>
            <returns></returns>
        </member>
        <member name="T:SEIDR.Doc.ColumnDateFormatter">
            <summary>
            A class to sugarcoat converting a consistent column to a DateTime. <para>Expected to be useful when you're not sure if a file will keep the same date format,
            if the date format changes depending on the column with the file, or if the c# code is expected to be reused for multiple, different data sources.</para>
            </summary>
            <remarks>It's technically possible for a junk column to be converted to a date. 
            <para>Ex: After finding the format for Col A to be mm-dd-yyyy, the string "ash04ketchum142014" should convert to 4/14/2014.</para>
            <para>Also to note, null and invisible characters should not impact date transformation AS LONG AS the *ENTIRE* date string can be read.</para>    
            </remarks>
        </member>
        <member name="F:SEIDR.Doc.ColumnDateFormatter.checkSanity">
            <summary>
            Set to true to prevent successful conversion of outstanding dates when calling ParseString. Default: False. 
            <para>E.g. 3/24/1825 would have a valid datetime out, but would return false instead of true.</para>
            </summary>
            <remarks>
            The requirements for failing sanity check are that it would be at least 100 years back from runtime, or at least 150 years into the future from runtime.
            <para>It's false by default since the usefulness of this really depends on what you're doing.</para>
            </remarks>
        </member>
        <member name="P:SEIDR.Doc.ColumnDateFormatter.size">
            <summary>
            Return the number of columns contained in the ColumnDateFormatter. Columns and the number of columns cannot be changed without recreating the ColumnDateFormatter. 
            <para>Columns CAN be renamed using the indexer and their index though.</para><para> E.g., df["pat"] -> 0. df[0] = "pie" -> . df["pat"] -> -1. df["pie"] -> 0</para>
            </summary>
        </member>
        <member name="M:SEIDR.Doc.ColumnDateFormatter.#ctor(System.Int32)">
            <summary>
            Creates a new date formatter.
            </summary>
            <param name="size">This should be the number of date columns you're expecting to exist.</param>
        </member>
        <member name="M:SEIDR.Doc.ColumnDateFormatter.#ctor(System.String[])">
             <summary>
             Create a new ColumnDateFormatter using an array of column names.
             </summary>
            <param name="names">(Params) String array containing ALL names of columns expected to be dates. 
            Can be passed as just a number of string arguments if you don't have a lot of them</param>
        </member>
        <member name="P:SEIDR.Doc.ColumnDateFormatter.Item(System.String)">
            <summary>
            Returns the column index within the ColumnDateFormatter of the given column's name. Not case sensitive
            </summary>
            <param name="column">Column you want the index of.</param>
            <returns>integer index of the column</returns>
        </member>
        <member name="P:SEIDR.Doc.ColumnDateFormatter.Item(System.Int32)">
            <summary>
            Get: Return the name of the column at that index. Set: Change the name of a column using it's index.
            </summary>
            <param name="column">Index</param>
            <returns>Empty string if no name has been set, else the name associated with a column</returns>
        </member>
        <member name="M:SEIDR.Doc.ColumnDateFormatter.getFormat(System.String)">
            <summary>
            Attempts to return the format for the given column. If unable to find the column using the given name, "Column not found" is returned instead.
            </summary>
            <param name="columnName">Name of the column</param>
            <returns>The format for the column to use when parsing the format.</returns>
        </member>
        <member name="M:SEIDR.Doc.ColumnDateFormatter.getFormat(System.Int32)">
            <summary>
            Attempts to return the format for the given column index. If unable to find the column using the given name, "Column not found" is returned instead.
            </summary>
            <param name="column">Index of the column in the ColumnDateFormatter. Can be obtained using an indexer if you're not sure.</param>
            <returns>Format for the column to use when parsing the format</returns>
        </member>
        <member name="M:SEIDR.Doc.ColumnDateFormatter.ParseFormat(System.String,System.Int32)">
            <summary>
            Takes a string and attempts to find the format to use in ParseString
            </summary>
            <param name="original">String to parse format from</param>
            <param name="column">Column the string is in.</param>
            <returns>True if we are able to parse a date from this string. False otherwise</returns>
        </member>
        <member name="M:SEIDR.Doc.ColumnDateFormatter.ParseString(System.String,System.String,System.DateTime@)">
            <summary>
            Calls on ParseString(int column, string value, out DateTime result) after finding the index of the column Name
            </summary>
            <param name="columnName">Name of column</param>
            <param name="value">Value to parse</param>
            <param name="result">Value converted to a DateTime</param>
            <returns>True if conversion to date succeeded.</returns>
        </member>
        <member name="M:SEIDR.Doc.ColumnDateFormatter.ParseString(System.Int32,System.String,System.DateTime@)">
            <summary>
            Attempts to parse the passed value using the given column's format.
            </summary>
            <param name="column">Index of column in ColumnDateFormatter</param>
            <param name="value">Value to parse</param>
            <param name="result">Value converted to a DateTime</param>
            <returns>True if conversion to date succeeded. 
            <para>If CheckSanity is true, then failing the sanity check will cause this to return false even if the conversion to date succeeded</para>         
            </returns>
        </member>
        <member name="M:SEIDR.Doc.ColumnDateFormatter.ParseOnce(System.String,System.DateTime@,System.Boolean)">
            <summary>
            Creates a local ColumnDateFormatter to run a single check on the date and then be deleted via leaving scope.
            </summary>
            <param name="value">String we want to parse</param>
            <param name="result">Output date</param>
            <param name="SanityCheck">If true, includes Sanity check</param>
            <returns>True if the result is a valid datetime</returns>
        </member>
        <member name="T:SEIDR.Doc.DelimitedDocumentReader">
            <summary>
            Wrapper class for reading delimited files.
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DelimitedDocumentReader.EMPTY">
            <summary>
            Returns a delimited record with no content, but set up to match the format from this document... 
            </summary>
        </member>
        <member name="F:SEIDR.Doc.DelimitedDocumentReader.ALIAS">
            <summary>
            Alias for the document, can be used for determining source of a delimited record. Defaults to file name without extension
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DelimitedDocumentReader.GetHeader(System.Boolean)">
            <summary>
            Returns the header values delimited by the document's delimiter
            </summary>
            <param name="useDefaultHeader"></param>        
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DelimitedDocumentReader.Reset">
            <summary>
            Resets the document to the start of the file. Does not change other settings like added headers.
            <para>Note that it will start off at the same place as it did originally.</para>
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DelimitedDocumentReader.CurrentPage">
            <summary>
            get the records on the current page
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DelimitedDocumentReader.GetNextPage">
            <summary>
            Increment the page and return its records
            </summary>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DelimitedDocumentReader.GetPage(System.Int32)">
            <summary>
            Get a 'page' of delimited records
            </summary>
            <param name="page">Zero based page number. If the page number goes out of range, returns null</param>
            <returns></returns>
        </member>
        <member name="P:SEIDR.Doc.DelimitedDocumentReader.Page">
            <summary>
            Gets the current "page" of the document
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DelimitedDocumentReader.GetHeader(System.Char,System.Boolean)">
            <summary>
            Gets the header joined by a new delimiter instead of the original
            </summary>
            <param name="newDelimiter"></param>
            <param name="useDefaultHeader"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DelimitedDocumentReader.GetHeader">
            <summary>
            Returns the headers as an an array of column names
            </summary>
            <returns></returns>
        </member>
        <member name="P:SEIDR.Doc.DelimitedDocumentReader.SkippedLines">
            <summary>
            Returns the lines skipped by the reader based on the line to skip parameter
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DelimitedDocumentReader.DefaultPageSize">
            <summary>
            Default value for new readers
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DelimitedDocumentReader.PageSize">
            <summary>
            Modifies the number of characters read at a time when creating records and determines the maximum number of characters per page
            <para>Minimum size of 34,000</para>
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DelimitedDocumentReader.pageRecordCount">
            <summary>
            Number of records on th current page
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DelimitedDocumentReader.minRecord">
            <summary>
            Minimum record number on the current page
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DelimitedDocumentReader.maxRecord">
            <summary>
            Maximum record number on the current page
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DelimitedDocumentReader.AddHeader(System.String)">
            <summary>
            Adds a header to the document. Used for access in the Delimited record/adding extra columns if the record is being used elsewhere.
            </summary>
            <param name="Header"></param>
        </member>
        <member name="P:SEIDR.Doc.DelimitedDocumentReader.FilePath">
            <summary>
            Returns the path used for the file being read.
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DelimitedDocumentReader.ResetHeader">
            <summary>
            Resets the header for Delimited records to match what was originally set
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DelimitedDocumentReader.#ctor(System.String,System.Int32,System.String[])">
            <summary>
            Creates a simple instance fo a delimited document to iterate through line by line, with the column delimiter guessed
            </summary>
            <param name="FilePath"></param>
            <param name="linesToSkip"></param>
            <param name="Header">Optional, the headers for the document. If null, will use the first line</param>
        </member>
        <member name="M:SEIDR.Doc.DelimitedDocumentReader.#ctor(System.String,System.Nullable{System.Char},System.Int32)">
            <summary>
            Creates an instance of a delimited Document to iterate through, line by line.
            <para>Assumes that there is a header at the first line after finish skipping</para>
            </summary>
            <param name="FilePath"></param>
            <param name="Delimiter">If null, will treat as a single column</param>        
            <param name="linesToSkip"></param>
        </member>
        <member name="M:SEIDR.Doc.DelimitedDocumentReader.#ctor(System.String,System.Nullable{System.Char},System.String[],System.Int32)">
            <summary>
            Creates an instance of a Delimited Document to iterate through line by line
            </summary>
            <param name="Filepath"></param>
            <param name="Delimiter"></param>
            <param name="Header"></param>
            <param name="linesToSkip"></param>
        </member>
        <member name="M:SEIDR.Doc.DelimitedDocumentReader.GetEnumerator">
            <summary>
            Loops through the document's content and provides DelimitedRecords
            </summary>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DelimitedDocumentReader.Dispose">
            <summary>
            Disposes the underlying file reader
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DelimitedDocumentReader.Finalize">
            <summary>
            
            </summary>
        </member>
        <member name="T:SEIDR.Doc.ReadonlyLines">
            <summary>
            For maintaining a readonly array of strings
            </summary>
        </member>
        <member name="P:SEIDR.Doc.ReadonlyLines.Item(System.Int32)">
            <summary>
            Gets the skipped line from the specified index
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.ReadonlyLines.#ctor(System.String[])">
            <summary>
            Constructor
            </summary>
            <param name="Lines"></param>
        </member>
        <member name="T:SEIDR.Doc.DelimitedDocumentWriter">
            <summary>
            For adding delimited records to a file. 
            <para>Can be used in conjunction with DelimitedDocumentReader to filter or combine files</para>
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DelimitedDocumentWriter.#ctor(System.String,System.Char,System.Boolean,System.String[])">
            <summary>
            Creates an instance of DelimiteddocumentWriter for adding records to the FilePath
            </summary>
            <param name="FilePath"></param>
            <param name="AppendIfExists">If true, will keep the existing file and just append files. Otherwise will reset the file if it exists already</param>
            <param name="delimiter">The delimiter for records that get added</param>
            <param name="HeaderList"></param>
        </member>
        <member name="M:SEIDR.Doc.DelimitedDocumentWriter.#ctor(System.String,System.Char,System.String[])">
            <summary>
            Creates an instance of DelimiteddocumentWriter for adding records to the FilePath.
            <para>Restarts the file if it already exists</para>
            </summary>
            <param name="filepath"></param>
            <param name="Delimiter"></param>
            <param name="Headers"></param>
        </member>
        <member name="M:SEIDR.Doc.DelimitedDocumentWriter.#ctor(System.String,System.Boolean,System.String[])">
            <summary>
            Creates an instance of DelimiteddocumentWriter for adding records to the FilePath with the default delimiter
            </summary>
            <param name="Filepath"></param>
            <param name="AppendIfExists">If true, will keep the existing file and just append files. Otherwise will reset the file if it exists already</param>        
            <param name="HeaderList"></param>
        </member>
        <member name="M:SEIDR.Doc.DelimitedDocumentWriter.#ctor(System.String,System.String[])">
            <summary>
            Creates an instance of DelimiteddocumentWriter for adding records to the FilePath with the default delimiter
            <para>Resets the file if it exists already.</para>
            </summary>
            <param name="FilePath"></param>        
            <param name="HeaderList"></param>
        </member>
        <member name="F:SEIDR.Doc.DelimitedDocumentWriter.MaxBatchSize">
            <summary>
            Batch size - when the number of records added exceeds this value, they will be added to the file.
            <para>Default value is 50000</para>
            </summary>
        </member>
        <member name="F:SEIDR.Doc.DelimitedDocumentWriter.Delimiter">
            <summary>
            Delimiter for records when writing
            </summary>
        </member>
        <member name="F:SEIDR.Doc.DelimitedDocumentWriter.DefaultDelimiter">
            <summary>
            The default delimiter for new DocumentWriters.
            Default value is set to '|'
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DelimitedDocumentWriter.AddRecordMerge(SEIDR.Doc.DelimitedRecord,SEIDR.Doc.DelimitedRecord)">
            <summary>
            Merges the two DelimitedRecords and adds them to the documentWriter
            </summary>
            <param name="record1"></param>
            <param name="record2"></param>
        </member>
        <member name="M:SEIDR.Doc.DelimitedDocumentWriter.AddRecordMerge(SEIDR.Doc.DelimitedRecord[])">
            <summary>
            Merges multiple delimited records together and adds them to the document output
            </summary>
            <param name="toMerge"></param>
        </member>
        <member name="M:SEIDR.Doc.DelimitedDocumentWriter.AddRecord(SEIDR.Doc.DelimitedRecord)">
            <summary>
            Adds the delimited record to the DocumentWriter
            </summary>
            <param name="record"></param>
        </member>
        <member name="M:SEIDR.Doc.DelimitedDocumentWriter.AddRecordBatch(SEIDR.Doc.DelimitedRecord[])">
            <summary>
            Add multiple delimited records at one time
            </summary>
            <param name="recordBatch"></param>
        </member>
        <member name="M:SEIDR.Doc.DelimitedDocumentWriter.Dispose">
            <summary>
            Ensures that all records that have been added to the documentWriter get added to the actual file.
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DelimitedDocumentWriter.HasHeader">
            <summary>
            If set to true, the document will be created with the header created
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DelimitedDocumentWriter.Flush">
            <summary>
            Adds all of the records that have been added to the file.
            <para>Also clears the records from the internal list.</para>
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DelimitedDocumentWriter.Reset(System.Nullable{System.Boolean})">
            <summary>
            Restarts the file
            </summary>
            <param name="IncludeHeader"></param>
        </member>
        <member name="T:SEIDR.Doc.DelimitedFileIndexInfo">
            <summary>
            Inforamtion about a Seidr Index
            </summary>
        </member>
        <member name="F:SEIDR.Doc.DelimitedFileIndexInfo.FILE_EXTENSION">
            <summary>
            Extension for index files used by DelimitedIndex class
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DelimitedFileIndexInfo.IndexFile">
            <summary>
            Path storing the location of the index file
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DelimitedFileIndexInfo.FilePath">
            <summary>
            Path to the file the index is built for
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DelimitedFileIndexInfo.FileDelimiter">
            <summary>
            Column delimiter for the file being indexed
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DelimitedFileIndexInfo.Columns">
            <summary>
            Columns stored by the index in order
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DelimitedFileIndexInfo.#ctor(System.String,System.String,System.Nullable{System.Char},System.String[])">
            <summary>
            Constructor with delimiter specified
            </summary>
            <param name="RawFilePath"></param>
            <param name="IndexFilePath"></param>
            <param name="Delimiter"></param>
            <param name="ColumnList"></param>
        </member>
        <member name="M:SEIDR.Doc.DelimitedFileIndexInfo.#ctor(System.String,System.String,System.String[])">
            <summary>
            Creates an index info class without the delimiter specified
            </summary>
            <param name="RawFilePath"></param>
            <param name="IndexFilePath"></param>
            <param name="ColumnList"></param>
        </member>
        <member name="T:SEIDR.Doc.DelimitedIndex">
            <summary>
            Class representing an index for a Delimited Document. Takes an indexFile for a constructor
            </summary>
        </member>
        <member name="F:SEIDR.Doc.DelimitedIndex.Header">
            <summary>
            For reading from the actual index file
            </summary>
        </member>
        <member name="F:SEIDR.Doc.DelimitedIndex._IndexInfo">
            <summary>
            Info describing the file being indexed. Meta data for the index file basically
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DelimitedIndex.IndexFile">
            <summary>
            Returns the name of the file being used for the index. Note that it should always have the extension ".sidx",
            unless the file was created outside of this class
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DelimitedIndex.SetFilter(System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Sets up the filter on the index so that you can iterate on records that meet the conditions.        
            </summary>   
            <remarks>If the filter can be parsed as a double, it will look for an exact match -  otherwise just that it's contained
            <para>If the value is null, it will check for empty or white space values.
            </para></remarks>        
            <param name="filters">Column:Value pair to use for filtering the values stored in the index</param>
        </member>
        <member name="M:SEIDR.Doc.DelimitedIndex.#ctor(SEIDR.Doc.DelimitedFileIndexInfo)">
            <summary>
            Sets up a delimited index based on the IndexInfo for setup
            </summary>
            <param name="setupInfo"></param>
        </member>
        <member name="M:SEIDR.Doc.DelimitedIndex.#ctor(System.String)">
            <summary>
            Creates a delimited Index object using the index's actual file
            </summary>
            <param name="IndexFile"></param>
        </member>
        <member name="M:SEIDR.Doc.DelimitedIndex.Dispose">
            <summary>
            Disposer
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DelimitedIndex.GetEnumerator">
            <summary>
            Iterate through the indexed records, or through everything if it has not had a filter set
            </summary>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DelimitedIndex.CreateIndex">
            <summary>
            Checks if the index already exists - if it exists but is older than the actual file's last update, a new index will be created.
            <para>If a new index is created, the index will be reset, but otherwise it will stay at the same position of the index file.</para>
            <para>Will need to re-set the filter if a new index is created</para>
            </summary>
            <returns>False if the index did not need to be created - true if a new index was created</returns>
        </member>
        <member name="P:SEIDR.Doc.DocQuery.Aggregation.Counter">
            <summary>
            Number of non null records matched to this aggregation
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DocQuery.Condition.#ctor(SEIDR.Doc.DocQuery.TransformedColumnMetaData,SEIDR.Doc.DocQuery.TransformedColumnMetaData,SEIDR.Doc.DocQuery.ConditionType)">
            <summary>
            Condition information for checking if columns match a condition for a passed record
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <param name="join">Determines logic to be used in matches. <para>
            Note: For IS NULL and IS NOT NULL, <paramref name="right"/> will be ignored.</para>
            <para>Also, it's probably better to use the static GetNULLCondition methodthen.</para></param>
        </member>
        <member name="M:SEIDR.Doc.DocQuery.Condition.Matches(SEIDR.Doc.IRecord)">
            <summary>
            Works with a record that has already had all the content merged together into one delimited record by <see cref="M:SEIDR.Doc.DelimitedRecord.Merge(SEIDR.Doc.DelimitedRecord,SEIDR.Doc.DelimitedRecord)"/>
            </summary>
            <param name="merged"></param>
            <returns></returns>
        </member>
        <member name="P:SEIDR.Doc.DocQuery.ConditionNode.ConditionCount">
            <summary>
            Count of nodes with populated conditions
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DocQuery.ConditionNode.AddSiblingCondition(SEIDR.Doc.DocQuery.Condition)">
            <summary>
            Adds the condition as a sibling ('OR' condition)
            </summary>
            <param name="OR"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocQuery.ConditionNode.AddChainNodes(SEIDR.Doc.DocQuery.ConditionNode[])">
            <summary>
            Note that this is adding ConditionNodes - i.e., they can already have their own children populated
            </summary>
            <param name="toAdd"></param>
        </member>
        <member name="M:SEIDR.Doc.DocQuery.ConditionNode.AddFlatChainConditions(SEIDR.Doc.DocQuery.Condition[])">
            <summary>
            Add a list of 'OR' grouped chains to the bottom of each child recursively
            </summary>
            <param name="toAdd"></param>
        </member>
        <member name="M:SEIDR.Doc.DocQuery.ConditionNode.AddNode(SEIDR.Doc.DocQuery.ConditionNode)">
            <summary>
            If the new node would be a constant (false), it is ignored, and the current instance is returned instead
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="F:SEIDR.Doc.DocQuery.ConditionTree.LeftHashColumns">
            <summary>
            Columns for the left side. Should be populated by optimization
            </summary>
        </member>
        <member name="F:SEIDR.Doc.DocQuery.DelimitedJoin.unmatched">
            <summary>
            Use for tracking positions in file that need to be returned in a right or outer join
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DocQuery.DelimitedJoin.GetUnmatched">
            <summary>
            For right/outer joins, returns the records that had no match, with the columns to the left prepended as empty.
            <para>Ends early once there are no more unmatched records</para>
            </summary>
            <returns></returns>
        </member>
        <member name="T:SEIDR.Doc.DocQuery.DelimitedQuery">
            <summary>
            Experiment for querying (select, inner join, left join, where clause filter) records from a delimited file.    
            <para>Syntax:</para><br />
            <para>ALIAS ______:(filepath)</para>
            <para>...</para>
            <para>SELECT [__ALIAS__].[ColumnName], [__ALIAS__].[ColumnName], ...</para>
            <para>FROM [__ALIAS__]</para>
            <para>{JOIN|LEFT JOIN} [__ALIAS__] ON [__ALIAS__].[ColumnName] {==|&lt;=|&gt;|&lt;|&gt;=|!=} {[__ALIAS__].[ColumnName] | __LITERAL__} { AND | OR __remaining conditions__ }</para>
            <para>{WHERE [__ALIAS__].[ColumnName] { IS {NOT} NULL | {{==|&lt;=|&gt;|&lt;|&gt;=|!=} {[__ALIAS__].[ColumnName] | __LITERAL__}  } } {AND | OR __Remainin filters__}(</para>
            <para>Note: ands are grouped before Or, unless in parenthesis..</para>
            <br /> On Data types - to specify non varchar, do the following: {DATE|MONEY|NUM}([__ALIAS__].[ColumnName])
            <br />On Literals- specify date with {DATE|MONEY|NUM|}( __Literal___)
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DocQuery.DelimitedQuery.Execute(System.String,System.Char)">
            <summary>
            Execute query, writes output to destination file.
            </summary>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocQuery.DelimitedQuery.Execute">
            <summary>
            Safe call to the getEnumerator (implicit foreach on instance)
            <para>If Query is not in valid state, skips any records</para>
            </summary>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocQuery.DelimitedQuery.GetEnumerator">
            <summary>
            Executes query, yields Delimited records instead of creating an output file
            </summary>
            <returns></returns>
        </member>
        <member name="P:SEIDR.Doc.DocQuery.DelimitedQuery.IsValid">
            <summary>
            Check if the query is valid before running.
            <para>An invalid operation exception will be thrown if this returns false when executing.</para>
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DocQuery.DelimitedQuery.Parse(System.String)">
            <summary>
            Parse a script to create a DelimitedQuery to run
            </summary>
            <param name="QueryContent"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocQuery.DelimitedQuery.Optimize">
            <summary>TODO:
            Removes extra join conditions, moves filters to earlier joins if possible, mark conditions as hash joins where possible
            </summary>
        </member>
        <member name="T:SEIDR.Doc.DocQuery.DelimitedRecordHashTable">
            <summary>
            For eventually performing delimited record hash joins
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DocQuery.DelimitedRecordHashTable.#ctor(System.String[])">
            <summary>
            Creates an object for storing delimited records and accessing them based on their partial hash.
            </summary>
            <param name="Columns"></param>
        </member>
        <member name="M:SEIDR.Doc.DocQuery.DelimitedRecordHashTable.#ctor(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Creates an object for storing delimited records using an IEnumerable of strings.
            </summary>
            <param name="Columns"></param>
        </member>
        <member name="P:SEIDR.Doc.DocQuery.DelimitedRecordHashTable.Item(SEIDR.Doc.DelimitedRecord)">
            <summary>
            Returns an enumerable of records that match on the hash
            </summary>
            <param name="record"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocQuery.DelimitedRecordHashTable.CheckHash(SEIDR.Doc.DelimitedRecord)">
            <summary>
            Calculates the hash for this record that would be used by this hash table.
            <para>Note that the table only uses records that have a non null value</para>
            </summary>
            <param name="record"></param>
            <returns></returns>
        </member>
        <member name="P:SEIDR.Doc.DocQuery.DelimitedRecordHashTable.Item(System.UInt64)">
            <summary>
            Returns an enumerable of records that match on the hash
            </summary>
            <param name="hash"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocQuery.DelimitedRecordHashTable.GetMatchingRecords(SEIDR.Doc.DelimitedRecord)">
            <summary>
            Gets an enumerable of records that have the same hash
            </summary>
            <param name="record"></param>
            <returns></returns>
        </member>
        <member name="P:SEIDR.Doc.DocQuery.DelimitedRecordHashTable.Item(System.UInt64,System.Int32)">
            <summary>
            Gets the delimited record at the specified index
            </summary>
            <param name="hashValue"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocQuery.DelimitedRecordHashTable.CheckCount(System.UInt64)">
            <summary>
            Gets count of records associated with the provided hash
            </summary>
            <param name="Value"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocQuery.DelimitedRecordHashTable.CheckCount(SEIDR.Doc.DelimitedRecord)">
            <summary>
            Gets the number of records with the same hash as the delimited record
            </summary>
            <param name="Value"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocQuery.DelimitedRecordHashTable.Add(SEIDR.Doc.DelimitedRecord)">
            <summary>
            Adds the delimited record to the underlying data structure, if the hash has a value.
            </summary>
            <param name="newRecord"></param>
        </member>
        <member name="M:SEIDR.Doc.DocQuery.DelimitedRecordHashTable.Add(SEIDR.Doc.DelimitedRecord[])">
            <summary>
            Adds all records to the underlying data structure
            </summary>
            <param name="newRecordList"></param>
        </member>
        <member name="M:SEIDR.Doc.DocQuery.DelimitedRecordHashTable.Add(System.Collections.Generic.IEnumerable{SEIDR.Doc.DelimitedRecord})">
            <summary>
            Adds all records to the underlying data structure
            </summary>
            <param name="newRecordList"></param>
        </member>
        <member name="M:SEIDR.Doc.DocQuery.DelimitedRecordHashTable.Clear">
            <summary>
            Completely clears the underlying data structure
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DocQuery.DelimitedRecordHashTable.Clear(System.UInt64)">
            <summary>
            Removes all records associated with the hash
            </summary>
            <param name="hash"></param>
        </member>
        <member name="M:SEIDR.Doc.DocQuery.DelimitedRecordHashTable.ClearSameHash(SEIDR.Doc.DelimitedRecord)">
            <summary>
            Removes all records with the same hash as the record
            </summary>
            <param name="record"></param>
        </member>
        <member name="P:SEIDR.Doc.DocQuery.DocQuerySettings.ExceptionOnParseFailure">
            <summary>
            If true, will throw an exception when failing to parse a non varchar.
            <para>Otherwise, will treat as null.</para>
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DocQuery.DocQuerySettings.SetExceptionOnParseFailure(System.Boolean)">
            <summary>
            Sets value for ExceptionOnParseFailure
            </summary>
            <param name="exception"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocQuery.HashJoin.DoJoin(SEIDR.Doc.DelimitedRecord)">
            <summary>
            Returns all matches for current record from the left
            </summary>
            <param name="left"></param>        
            <returns></returns>
        </member>
        <member name="F:SEIDR.Doc.DocQuery.Predicates.ConditionParser.KeyWords">
            <summary>
            Note: Should be stopped before a where
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DocQuery.Predicates.ConditionParser.ParseExpression">
            <summary>
            Delegate for parsing expressions (functionality set in <see cref="P:SEIDR.Doc.DocQuery.Predicates.LeafCondition.ContentInformation"/>).
            <para>Will be the content on either side of comparison operators (e.g., '&lt;&gt;', '=', '&lt;=', '&gt;', etc)</para>
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DocQuery.Predicates.ConditionParser.Parse(System.String)">
            <summary>
            
            </summary>
            <param name="content">If a join, should be the portion between ON but not including and either the next join or "WHERE", ";", "SELECT", "UNION"<para>
            If a where, should be the portion between but not including the next ";", "SELECT", "UNION" </para></param>
            <returns></returns>
        </member>
        <member name="T:SEIDR.Doc.DocQuery.Predicates.IsNullCondition">
            <summary>
            Leaf condition, check if a column (or constant from meta data) is null or not null
            </summary>
        </member>
        <member name="T:SEIDR.Doc.DocQuery.Predicates.JoinCondition">
            <summary>
            Join condition- joins delimited record columns. left and right should be ignroed
            </summary>
        </member>
        <member name="T:SEIDR.Doc.DocQuery.Predicates.NotCondition">
            <summary>
            Single child condition. 
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DocQuery.Predicates.RootCondition.Simple">
            <summary>
            Checks if the child is a leaf condition - if so, it should be safe to merge the condition with other conditions, if the aliases are available.        
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DocQuery.Predicates.RootCondition.HashConditionType">
            <summary>
            Returns the condition type for the hash condition - equal or not equal
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DocQuery.Predicates.RootCondition.Evaluate(SEIDR.Doc.DocRecord)">
            <summary>
            Checks if the record passes Conditions
            </summary>
            <param name="record"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocQuery.Predicates.RootCondition.MergeWithRoot(SEIDR.Doc.DocQuery.Predicates.RootCondition)">
            <summary>
            Attempts to merge RootCondition b into this root Condition
            </summary>
            <param name="b"></param>
            <returns>True if b was successfully merged into this RootCondition</returns>
        </member>
        <member name="P:SEIDR.Doc.DocQuery.TransformedColumn.ValidContent">
            <summary>
            Check if the column is valid for comparisons.
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DocQuery.TransformedColumn.IsNull">
            <summary>
            Check if the column is null for the content.
            </summary>
        </member>
        <member name="T:SEIDR.Doc.DocQuery.TransformedMoney">
            <summary>
            Decimal content
            </summary>
        </member>
        <member name="T:SEIDR.Doc.DocQuery.TransformedNum">
            <summary>
            int 64 content
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DocQuery.TransformedColumnMetaDataCollection.Count">
            <summary>
            Number of meta data items in the collection
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DocQuery.TransformedColumnMetaDataCollection.Item(System.String,System.String)">
            <summary>
            Gets the Meta Data for the specified column, or null if not exists
            </summary>
            <param name="alias"></param>        
            <param name="Column"></param>
            <returns></returns>
        </member>
        <member name="P:SEIDR.Doc.DocQuery.TransformedColumnMetaDataCollection.Item(System.Int32)">
            <summary>
            Gets the column meta data based on Ordinal position.
            </summary>
            <param name="position"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocQuery.TransformedColumnMetaDataCollection.AddMetaData(SEIDR.Doc.DocQuery.TransformedColumnMetaData)">
            <summary>
            Adds the meta data to the collection, if the column isn't already in use.
            </summary>
            <param name="newMetaData"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocQuery.TransformedColumnMetaDataCollection.RemoveMetaData(System.String,System.String)">
            <summary>
            Removes any meta data for the column name
            </summary>
            <param name="oldMetaDataColumn"></param>
            <param name="OwnerAlias">Specifies the file owner for the column</param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocQuery.TransformedColumnMetaDataCollection.UpdateMetaData(SEIDR.Doc.DocQuery.TransformedColumnMetaData)">
            <summary>
            Replaces any existing meta data for the parameter's Column with newMetaData
            </summary>
            <param name="newMetaData"></param>
        </member>
        <member name="M:SEIDR.Doc.DocQuery.TransformedColumnMetaDataCollection.GetColumn(System.String,System.String,SEIDR.Doc.IRecord)">
            <summary>
            Gets a TransformedColumn for the specified column name using any meta data
            <para>for the column.</para>
            <para>If no meta data is found, it will be treated as null</para>
            </summary>
            <param name="alias">File aliasfrom querying</param>
            <param name="ColumnName"></param>
            <param name="content"></param>
            <returns></returns>
        </member>
        <member name="T:SEIDR.Doc.DocQuery.TransformedColumnMetaData">
            <summary>
            Contains information about a column for usage in a Delimited Query's conditions and/or joining
            </summary>
        </member>
        <member name="F:SEIDR.Doc.DocQuery.TransformedColumnMetaData.ColumnName">
            <summary>
            Name of the column for use in a MetadataCollection
            </summary>
        </member>
        <member name="F:SEIDR.Doc.DocQuery.TransformedColumnMetaData.OwnerAlias">
            <summary>
            Alias of the document containing the column meta data..
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DocQuery.TransformedColumnMetaData.Matches(SEIDR.Doc.DocRecordColumnInfo)">
            <summary>
            Return true if this is referencing the same content, based on the alias and and column name
            </summary>
            <param name="column"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocQuery.TransformedColumnMetaData.op_Implicit(SEIDR.Doc.DocQuery.TransformedColumnMetaData)~SEIDR.Doc.DocRecordColumnInfo">
            <summary>
            Implicitly convert to Column info
            </summary>
            <param name="a"></param>
        </member>
        <member name="F:SEIDR.Doc.DocQuery.TransformedColumnMetaData.Type">
            <summary>
            Used for type validation before performing any comparisons. 
            Null is allowed by default
            </summary>
        </member>
        <member name="F:SEIDR.Doc.DocQuery.TransformedColumnMetaData.Transform">
            <summary>
            Transforms the content 
            </summary>
        </member>
        <member name="T:SEIDR.Doc.DelimitedRecord">
            <summary>
            Contains individual lines from Delimited Document.
            <para>Read only except for being able to add extra columns to the end as a sort of tag.</para>
            <para>Can be used to write a record to a new file using the ToString() method.</para>
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DelimitedRecord.FullRecordHash">
            <summary>
            Returns a ulong value of the record's ToString as a hash
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DelimitedRecord.GetPartialHash(System.String[])">
            <summary>
            Returns an unsigned long hash code using a rolling hash
            </summary>
            <param name="ColumnsToHash"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DelimitedRecord.GetPartialHash(System.Boolean,System.String[])">
            <summary>
            Returns an unsigned long hash code, using either a rolling hash or string's GetHashCode.
            If any of the column values are null or empty strings, will return null instead of a value
            </summary>
            <param name="RollingHash"></param>
            <param name="columnsToHash"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DelimitedRecord.GetPartialHash(System.Boolean,System.Boolean,SEIDR.Doc.DocRecordColumnInfo[])">
            <summary>
            Returns an unsigned long hash code, using either a rolling hash or string's GetHashCode.
            If any of the column values are null or empty strings, will return null instead of a value
            </summary>
            <param name="RollingHash"></param>
            <param name="ExcludeEmpty">If true, will treat empty strings as a null</param>
            <param name="columnsToHash"></param>
            <returns></returns>
        </member>
        <member name="P:SEIDR.Doc.DelimitedRecord.HeaderList">
            <summary>
            Returns a copy of the header information
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DelimitedRecord.Delimiter">
            <summary>
            Gets the delimiter associated with the record
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DelimitedRecord.ChangeDelimiter(System.Char)">
            <summary>
            Changes the delimiter, but only if the record already has a delimiter.
            </summary>
            <param name="newValue"></param>
            <returns>Returns true if the delimiter was changed, else false</returns>
        </member>
        <member name="P:SEIDR.Doc.DelimitedRecord.NullIfTruncated">
            <summary>
            If set to true, will return null instead of erroring when the line does not have enough records for the index even though
            <para>the header length indicates that it should have enough records.</para>
            <para>Used when accessing without headers</para>
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DelimitedRecord.Item(System.Int32)">
            <summary>
            Gets the value of the record at the provided index. For use when Headers are not being used.
            </summary>
            <param name="index">0 based index to grab content from</param>
            <returns></returns>
        </member>
        <member name="P:SEIDR.Doc.DelimitedRecord.Item(System.String)">
            <summary>
            Gets the first value of the record for the provided column( any alias)
            </summary>
            <param name="Column"></param>
            <returns></returns>
        </member>
        <member name="P:SEIDR.Doc.DelimitedRecord.Item(System.String,System.String)">
            <summary>
            Gets the content owned by the specified column under the specified alias
            </summary>
            <param name="Alias"></param>
            <param name="ColumnName"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DelimitedRecord.AddColumn(SEIDR.Doc.DocRecordColumnInfo,System.String)">
            <summary>
            Adds the column to the meta data collection. If a position is specified, will insert at that position and move the position of any later columns forward
            </summary>
            <param name="Column"></param>
            <param name="Value"></param>
        </member>
        <member name="M:SEIDR.Doc.DelimitedRecord.GetValue``1(System.String,System.String,``0)">
            <summary>
            Gets the value specified by the column and converts it to T. Does not handle WhiteSpace
            </summary>
            <typeparam name="T">Must be a primitive type. See the System.TypeCode enumeration</typeparam>
            <param name="Alias">Owning alias. Null will search for the for the first column that matches by name</param>
            <param name="Column"></param>
            <param name="defaultVal">Default value to use if there's no content</param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DelimitedRecord.GetValue``1(System.String,``0)">
            <summary>
            Gets the value specified for the first column that matches (regardless of alias) and converts to T.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="Column"></param>
            <param name="defaultVal"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DelimitedRecord.GetValue``1(System.Int32)">
            <summary>
            Gets the value specified at the given index and converts it to T.
            </summary>
            <typeparam name="T">Must be a primitive type. See the System.TypeCode enumeration</typeparam>
            <param name="index">Numeric index of the data to grab</param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DelimitedRecord.GetContent">
            <summary>
            Returns a new list copy of the internal content of this record.
            </summary>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DelimitedRecord.Merge(SEIDR.Doc.DelimitedRecord,SEIDR.Doc.DelimitedRecord)">
            <summary>
            Combines delimited records. Must be set up for using Headers
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DelimitedRecord.MergeEmpty(System.Collections.Generic.IList{SEIDR.Doc.DocRecordColumnInfo},SEIDR.Doc.DelimitedRecord)">
            <summary>
            Returns a new delimited record with the empty columns at the beginning
            </summary>
            <param name="columns"></param>
            <param name="record"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DelimitedRecord.GetSubset(SEIDR.Doc.DelimitedRecord,System.Collections.Generic.IList{SEIDR.Doc.DocRecordColumnInfo})">
            <summary>
            Gets a new delimited record containing a subset of the columns from the working record
            </summary>
            <param name="work"></param>
            <param name="columns"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DelimitedRecord.#ctor(System.String[],System.Nullable{System.Char})">
            <summary>
            Creates a delimited record but with no Header information.
            <para> Will not be able to access column data using column names</para>
            </summary>
            <param name="Content"></param>
            <param name="Delimited"></param>
        </member>
        <member name="M:SEIDR.Doc.DelimitedRecord.#ctor(System.String[],System.String[],System.Int32,System.Nullable{System.Char},System.String)">
            <summary>
            Creates a new record
            </summary>
            <param name="Header"></param>
            <param name="Content"></param>
            /// <param name="contentExpectedLength">Expected number of columns to be in the passed content - should match the number of columns in the physical file when reading.</param>
            <param name="OwnerAlias">Alias of object owning the columns</param>
            <param name="Delimiter">Delimiter that split Content into an array</param>
        </member>
        <member name="M:SEIDR.Doc.DelimitedRecord.#ctor(System.String[],System.String,System.Int32,System.Nullable{System.Char},System.String)">
            <summary>
            Creates a new delimited record using the delimiter provided to split the content string
            </summary>
            <param name="Header"></param>
            <param name="Content"></param>
            <param name="contentExpectedLength">Expected number of columns to be in the passed content - should match the number of columns in the physical file when reading.</param>
            <param name="Delimiter"></param>
            <param name="Alias">Owner alias</param>
        </member>
        <member name="M:SEIDR.Doc.DelimitedRecord.ConvertToType``1">
            <summary>
            Converts the record into a instance of type 'T'
            <para>Note: Fields may or may not work as expected with setting values.</para>
            <para>Note: Complex types like lists or arrays are not supported, only primitives. If you want more complex logic, you'll have to convert yourself</para>
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DelimitedRecord.ToString">
            <summary>
            Combines the content into a delimited string
            </summary>
            <returns></returns>
        </member>
        <member name="T:SEIDR.Doc.DocMetaData">
            <summary>
            MetaData for configuring other classes in the Doc namespace (e.g., <see cref="T:SEIDR.Doc.DocReader"/> )
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DocMetaData.LinkColumnSet(SEIDR.Doc.DocRecordColumnCollection)">
            <summary>
            Links the columns of this meta data directly to the passed column set. 
            <para>
            (Will point to the same object, so modifying columns on this meta data will affect any other objects using the same column collection)
            </para>
            </summary>
            <param name="columnSet"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocMetaData.UnlinkColumnSet">
            <summary>
            Undoes the logic of <see cref="M:SEIDR.Doc.DocMetaData.LinkColumnSet(SEIDR.Doc.DocRecordColumnCollection)"/> by creating a new column collection internally, copying the current collection's columns into it, and then pointing to the new collection.
            </summary>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocMetaData.op_Implicit(SEIDR.Doc.DocMetaData)~SEIDR.Doc.DocRecordColumnCollection">
            <summary>
            Treats the MetaData as the underlying ColumnsCollection
            </summary>
            <param name="data"></param>
        </member>
        <member name="P:SEIDR.Doc.DocMetaData.Columns">
            <summary>
            The columns from the file
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DocMetaData.GetRecordColumnInfos(System.String)">
            <summary>
            Removes minimum on PageSize. Setting pageSize below the min is silently ignored outside of TestMode
            </summary>
            <param name="DocLine"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocMetaData.GetRecordColumnInfos(SEIDR.Doc.IDataRecord)">
            <summary>
            Returns <see cref="P:SEIDR.Doc.DocMetaData.Columns"/>. 
            </summary>
            <param name="record"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocMetaData.TrySetFixedWidthMode(System.Boolean)">
            <summary>
            Tries to set the doc to fixed width mode. Returns true if value is updated.
            </summary>
            <param name="useFixedWidth"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocMetaData.CloneForNewFile(System.String,System.Nullable{System.Boolean})">
            <summary>
            Clones the various settings of this file, but for a second file path. (E.g., to take input from a file and then modify some of the data and output it in a new location, but without changing metadata)
            </summary>
            <param name="NewFilePath"></param>
            <param name="WriteMode"></param>
            <returns></returns>
        </member>
        <member name="P:SEIDR.Doc.DocMetaData.HeaderConfigured">
            <summary>
            Columns are in a valid state.
            </summary>        
        </member>
        <member name="P:SEIDR.Doc.DocMetaData.Valid">
            <summary>
            Default value for <see cref="!:PageSize"/> 
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DocMetaData.#ctor(System.String,System.String)">
            <summary>
            The columns from the file
            </summary>
            <param name="file"></param>
            <param name="alias"></param>
        </member>
        <member name="M:SEIDR.Doc.DocMetaData.#ctor(System.String,System.String,System.String)">
            <summary>
            Full path of the file being described.
            </summary>
            <param name="DirectoryPath"></param>
            <param name="FileName"></param>
            <param name="alias"></param>
        </member>
        <member name="P:SEIDR.Doc.DocMetaData.HasHeader">
            <summary>
            Gets the name of the directory for the specified path (<see cref="!:FilePath"/>)
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DocMetaData.SetHasHeader(System.Boolean)">
            <summary>
            Sets whether or not the file has a header.
            </summary>
            <param name="headerIncluded"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocMetaData.GetHeader">
            <summary>
            Clears the multli line end delimiter
            </summary>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocMetaData.AddMultiLineEndDelimiter(System.String[])">
            <summary>
            Adds the strings to <see cref="P:SEIDR.Doc.MetaDataBase.MultiLineEndDelimiter"/>, and sorts it so that super sets are earlier. 
            <para>E.g., ensures \r\n comes before \r or \n, while the order of \r and \n are arbitrary.</para>
            </summary>
            <param name="endingToAdd"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocMetaData.SetMultiLineEndDelimiters(System.String[])">
            <summary>
            Access mode for file opening. Indicates whether the DocMetaData will be used for Doc reading or doc writing
            </summary>
            <param name="endings"></param>
        </member>
        <member name="M:SEIDR.Doc.DocMetaData.SetEmptyIsNull(System.Boolean,System.Boolean)">
            <summary>
            Sets <see cref="P:SEIDR.Doc.DocRecordColumnCollection.DefaultNullIfEmpty"/>,
            and also sets the <see cref="P:SEIDR.Doc.DocRecordColumnInfo.NullIfEmpty"/> for each column associated with the ColumnCollection
            </summary>
            <param name="nullifyEmpty"></param>
            <param name="SetDefault">If false, just sets the values on individual columns, not the collection's default.</param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocMetaData.SetEmptyIsNull(System.Boolean,System.Predicate{SEIDR.Doc.DocRecordColumnInfo},System.Boolean)">
            <summary>
            Sets <see cref="P:SEIDR.Doc.DocRecordColumnCollection.DefaultNullIfEmpty"/>,
            and also (conditionally) sets the <see cref="P:SEIDR.Doc.DocRecordColumnInfo.NullIfEmpty"/> for each column associated with the ColumnCollection that matches <paramref name="columnPredicate"/>.
            
            </summary>
            <param name="NullifyEmpty"></param>
            <param name="columnPredicate"></param>
            <param name="SetDefault">If false, just sets the values on individual columns, not the collection's default.</param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocMetaData.AddDelimitedColumns(System.String[])">
            <summary>
            Adds basic columns to be delimited by <see cref="P:SEIDR.Doc.MetaDataBase.Delimiter"/>.
            </summary>
            <param name="columnNames"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocMetaData.AddDetailedColumn(SEIDR.Doc.DocRecordColumnInfo[])">
            <summary>
            Adds one or more populated <see cref="T:SEIDR.Doc.DocRecordColumnInfo"/> instances to the Columns Collection
            </summary>
            <param name="column"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocMetaData.SetColumnMatchStrictMode(System.Boolean)">
            <summary>
            Sets the value for <see cref="P:SEIDR.Doc.DocRecordColumnCollection.BestMatchStrict"/> 
            </summary>
            <param name="strict"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocMetaData.AddDetailedColumnCollection(SEIDR.Doc.DocRecordColumnCollection)">
            <summary>
            Copies the columns from the collection to the end of this doc's column collection. 
            <para>Note: Will replace the alias.</para>
            </summary>
            <param name="columnCollection"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocMetaData.RemoveColumn(SEIDR.Doc.DocRecordColumnInfo[])">
            <summary>
            Remove the columns from the column collection. Should be done *before* reading or writing - may lead to DocRecords being in an inconsistent state otherwise.
            </summary>
            <param name="toRemove"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocMetaData.RemoveColumn(System.String,System.String,System.Int32)">
            <summary>
            Attempts to remove the specified column.
            </summary>
            <param name="ColumnName"></param>
            <param name="alias"></param>
            <param name="position"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocMetaData.CopyDetailedColumnCollection(SEIDR.Doc.DocRecordColumnCollection)">
            <summary>
            Copies the columns from the collection to the end of this doc's column collection. Maintains alias.
            </summary>
            <param name="columnCollection"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocMetaData.AddColumn(System.String,System.Nullable{System.Int32},System.Boolean,SEIDR.Doc.DocRecordColumnType)">
            <summary>
            Creates a new <see cref="T:SEIDR.Doc.DocRecordColumnInfo"/> and adds it to the Columns collection
            </summary>
            <param name="ColumnName"></param>
            <param name="MaxLength">optional limit</param>
            <param name="TextQual"></param>
            <param name="DataType"></param>        
            <returns></returns>
        </member>
        <member name="P:SEIDR.Doc.DocMetaData.FileHash">
            <summary>
            Returns a hash of the file content, based on <see cref="M:SEIDR.Doc.DocExtensions.GetFileHash(System.IO.FileInfo)"/>
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DocMetaData.RefreshFileHash">
            <summary>
            Removes the cached filehash and returns a fresh evaluation of <see cref="P:SEIDR.Doc.DocMetaData.FileHash"/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocMetaData.CheckExists">
            <summary>
            Check if the file exists
            </summary>
            <returns></returns>
        </member>
        <member name="T:SEIDR.Doc.DocReader">
            <summary>
            Allows reading a delimited or fixed width file based on meta data. <para>
            Includes paging for working with large files in batches
            </para>
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DocReader.op_Implicit(SEIDR.Doc.DocReader)~SEIDR.Doc.MetaDataBase">
            <summary>
            Pass the Reader as MetaDataBase.
            </summary>
            <param name="r"></param>
        </member>
        <member name="M:SEIDR.Doc.DocReader.op_Implicit(SEIDR.Doc.DocReader)~SEIDR.Doc.DocMetaData">
            <summary>
            Returns the MetaData as a <see cref="T:SEIDR.Doc.DocMetaData"/> instance, if it's that type of metaData.
            </summary>
            <param name="r"></param>
        </member>
        <member name="M:SEIDR.Doc.DocReader.op_Implicit(SEIDR.Doc.DocReader)~SEIDR.Doc.MultiRecordDocMetaData">
            <summary>
            Returns the MetaData as a <see cref="T:SEIDR.Doc.MultiRecordDocMetaData"/> instance, if it's that type of metadata.
            </summary>
            <param name="r"></param>
        </member>
        <member name="M:SEIDR.Doc.DocReader.op_Implicit(SEIDR.Doc.DocReader)~SEIDR.Doc.DocRecordColumnCollection">
            <summary>
            Returns the underlying DocRecordColumn Collection, but only if the MetaData is type <see cref="T:SEIDR.Doc.DocMetaData"/>.
            </summary>
            <param name="r"></param>
        </member>
        <member name="M:SEIDR.Doc.DocReader.#ctor">
            <summary>
            Basic constructor, no meta data configured yet.
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DocReader.#ctor(SEIDR.Doc.MetaDataBase)">
            <summary>
            Sets up a doc reader for DocRecord enumeration.
            </summary>
            <param name="info"></param>
        </member>
        <member name="M:SEIDR.Doc.DocReader.#ctor(System.String,System.String,System.Nullable{System.Char},System.String,System.Nullable{System.Int32})">
             <summary>
            
             </summary>
             <param name="alias"></param>
             <param name="FilePath"></param>
             <param name="LineEnd"></param>
             <param name="Delimiter"></param>
             <param name="pageSize"></param>
        </member>
        <member name="M:SEIDR.Doc.DocReader.#ctor(System.String,System.String,System.String,System.Nullable{System.Char},System.String,System.Nullable{System.Int32})">
            <summary>
            Creates a DocReader for the specified file by combining Directory and FileName
            </summary>
            <param name="alias"></param>
            <param name="Directory"></param>
            <param name="FileName"></param>
            <param name="LineEnd"></param>
            <param name="Delimiter"></param>
            <param name="pageSize"></param>
        </member>
        <member name="T:SEIDR.Doc.DocReader`1">
            <summary>
            Allows reading a delimited or fixed width file based on meta data. <para>
            Includes paging for working with large files in batches
            </para>
            </summary>
        </member>
        <member name="F:SEIDR.Doc.DocReader`1.IncludeNullRecords">
            <summary>
            Indicates whether or not empty lines are skipped, or returned as null.
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DocReader`1.Preview(System.String,System.Int32)">
            <summary>
            Preview the first <paramref name="charCount"/> characters from the file.
            </summary>
            <param name="FilePath"></param>
            <param name="charCount"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocReader`1.GuessColumnDataTypes(System.Int32)">
            <summary>
            Goes through the data in the associated DocReader and attempts to check all columns for data types and attempts to narrow down the most likely data type.        
            </summary>
            <param name="RecordLimit">Maximum number of lines to go through from the Document. If value is less than or equal to 0, will go through all records in the file.</param>
        </member>
        <member name="F:SEIDR.Doc.DocReader`1._MetaData">
            <summary>
            True underlying meta data
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DocReader`1.MetaData">
            <summary>
            Underlying MetaData
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DocReader`1.Columns">
            <summary>
            Columns associated with the meta data.
            <para>Returns null for multi record.</para>
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DocReader`1.FilePath">
            <summary>
            Full file path, from meta data
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DocReader`1.FileName">
            <summary>
            File name associated with the doc
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DocReader`1.Alias">
            <summary>
            File alias, from meta data
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DocReader`1.#ctor(SEIDR.Doc.MetaDataBase)">
            <summary>
            Sets up a doc reader for DocRecord enumeration.
            </summary>
            <param name="info"></param>
        </member>
        <member name="P:SEIDR.Doc.DocReader`1.RecordCount">
            <summary>
            Total number of records in the file after set up.
            <para>If the file cannot be parsed, or has not yet been parsed, the value will be -1.</para>
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DocReader`1.ReConfigure">
            <summary>
            Reconfigures the Reader settings/paging information, using any changes to the DocMetaData that was provided
            </summary>
        </member>
        <member name="T:SEIDR.Doc.DocReader`1.PageHelper">
            <summary>
            Paging information for reading from the file.
            </summary>
        </member>
        <member name="F:SEIDR.Doc.DocReader`1.PageHelper.StartPosition">
            <summary>
            Start character position of this page.
            </summary>
        </member>
        <member name="F:SEIDR.Doc.DocReader`1.PageHelper.EndPosition">
            <summary>
             End character position in the file of this page
            </summary>
        </member>
        <member name="F:SEIDR.Doc.DocReader`1.PageHelper.Fullness">
            <summary>Percentage filled of page size used</summary>
        </member>
        <member name="F:SEIDR.Doc.DocReader`1.PageHelper.Length">
            <summary>
            Size of the page.
            </summary>
        </member>
        <member name="F:SEIDR.Doc.DocReader`1.PageHelper.RecordCount">
            <summary>
            Number of records in page
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DocReader`1.PageHelper.#ctor(System.Int64,System.Int64,System.Int32,System.Int32)">
            <summary>
            Helper Class for DocReader to divide a file into segments for processing.
            </summary>
            <param name="position"></param>
            <param name="endPosition"></param>
            <param name="pageSize"></param>
            <param name="recordCount"></param>
        </member>
        <member name="M:SEIDR.Doc.DocReader`1.GetPageInfo(System.Int32)">
            <summary>
            Gets information about page number <paramref name="page"/>
            </summary>
            <param name="page"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocReader`1.#ctor(System.String,System.String,System.Nullable{System.Char},System.String,System.Nullable{System.Int32})">
            <summary>
            Sets up a basic delimited reader, assuming the file has headers starting on the first line.
            </summary>
            <param name="alias"></param>
            <param name="FilePath"></param>
            <param name="LineEnd">The line ending. If null, will use <see cref="P:System.Environment.NewLine"/></param>
            <param name="Delimiter">Column delimiter. If null, will try to guess when parsing, based on the content of the first line found.</param>
            <param name="pageSize">Overwrites the meta data page size of the inferred DocMetaData</param>
        </member>
        <member name="M:SEIDR.Doc.DocReader`1.#ctor">
            <summary>
            Basic constructor, no meta data configured yet.
            <para>Will need to call <see cref="M:SEIDR.Doc.DocReader`1.Configure(SEIDR.Doc.DocMetaData)"/> before using.</para>
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DocReader`1.Configure(SEIDR.Doc.DocMetaData)">
            <summary>
            Configures the DocReader to use the passed meta data.
            </summary>
            <param name="metaData"></param>
        </member>
        <member name="P:SEIDR.Doc.DocReader`1.PageCount">
            <summary>
            Count of pages based on configuration.
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DocReader`1.CheckPage(System.Int64)">
            <summary>
            Checks the page that the specified line number (file wide, from the start after skipping any lines/header)
            </summary>
            <param name="lineNumber"></param>
            <returns>Tuple indicating the page number and position of the line.</returns>
        </member>
        <member name="M:SEIDR.Doc.DocReader`1.CheckLine(System.Int32,System.Int32)">
            <summary>
            Gets the overall line number based on number of records per page used.
            </summary>
            <param name="page"></param>
            <param name="pageLine"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocReader`1.GetSpecificLines(System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>
            Enumerates the record contents from the spefied line numbers
            </summary>
            <param name="Lines"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocReader`1.GetSpecificRecords(System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>
            Enumerates specific records from the file, based on line number
            </summary>
            <param name="Lines"></param>
            <returns></returns>
        </member>
        <member name="P:SEIDR.Doc.DocReader`1.Item(System.Int64)">
            <summary>
            Gets the record from the specified position
            </summary>
            <param name="position"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocReader`1.GetPagePositions(System.Int64[])">
             <summary>
            
             </summary>
             <param name="lineNumberList"></param>
             <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocReader`1.GetPagePositions(System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>
            Gets all the line numbers used for a given line Number
            </summary>
            <param name="lineNumberList"></param>
            <returns></returns>
        </member>
        <member name="P:SEIDR.Doc.DocReader`1.Item(System.Int32,System.Int32)">
            <summary>
            Attempts to grab a specific DocRecord off the specified page
            </summary>
            <param name="pageNumber"></param>
            <param name="pageLineNumber"></param>
            <returns></returns>
        </member>
        <member name="F:SEIDR.Doc.DocReader`1.lastPage">
            <summary>
            The last pageNumber that was used for grabbing content from a file
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DocReader`1.GetPageLines(System.Int32)">
            <summary>
            Returns an IList of strings. May be either an <see cref="T:System.Array"/> of strings(MultiLineEnd Delimiter mode..) or a <see cref="!:List&lt;string&gt;"/>.
            <para>May be more useful when dealing with a class that inherits from <see cref="T:SEIDR.Doc.DocRecord"/></para>
            </summary>
            <param name="pageNumber"></param>
            <returns></returns>
        </member>
        <member name="F:SEIDR.Doc.DocReader`1.CurrentPage">
            <summary>
            cached list, the most recent result from calling <see cref="M:SEIDR.Doc.DocReader`1.GetPage(System.Int32,System.Boolean)"/>
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DocReader`1.GetPage(System.Int32,System.Boolean)">
            <summary>
            Gets the content of the specified 'page'
            </summary>
            <param name="pageNumber"></param>
            <param name="cached">If the same page is accessed more than once in a row, the same List of objects will be returned</param>
            <returns></returns>
        </member>
        <member name="T:SEIDR.Doc.DocRecord">
            <summary>
            Read/write class for use with DocQueries, DocReader, and DocWriter
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DocRecord.FullRecordHash">
            <summary>
            Returns a ulong value of all columns
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DocRecord.GetPartialHash(System.String[])">
            <summary>
            Returns an unsigned long hash code using a rolling hash
            </summary>
            <param name="ColumnsToHash"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocRecord.GetPartialHash(System.Boolean,System.String[])">
            <summary>
            Returns an unsigned long hash code, using either a rolling hash or string's GetHashCode.
            If any of the column values are null or empty strings, will return null instead of a value
            </summary>
            <param name="RollingHash"></param>
            <param name="columnsToHash"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocRecord.GetPartialHash(System.Boolean,System.Collections.Generic.IList{System.String})">
            <summary>
            Returns an unsigned long hash code, using either a rolling hash or string's GetHashCode.
            If any of the column values are null or empty strings, will return null instead of a value
            </summary>
            <param name="RollingHash"></param>
            <param name="columnsToHash"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocRecord.GetPartialHash(System.Boolean,System.Boolean,SEIDR.Doc.DocRecordColumnInfo[])">
            <summary>
            Returns an unsigned long hash code, using either a rolling hash method or string's GetHashCode.
            </summary>
            <param name="RollingHash"></param>
            <param name="includeNull">If true, will not return null if the column value is null</param>
            <param name="columnsToHash"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocRecord.Evalaute``1(System.Int32,System.Boolean)">
            <summary>
            Use <see cref="M:SEIDR.Doc.DocRecord.TryGet(System.String,System.Object@,System.String,System.Int32)"/> to return an object of Type <typeparamref name="T"/>.
            <para>If object is not the correct type, or fails to parse, then the default for the type will be returned instead (Unless <paramref name="ErrorNoSuccess"/> is true)</para>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="Position"></param>
            <param name="ErrorNoSuccess"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocRecord.Evaluate``1(System.String,System.String,System.Boolean)">
            <summary>
            Use <see cref="M:SEIDR.Doc.DocRecord.TryGet(System.String,System.Object@,System.String,System.Int32)"/> to return an object of Type <typeparamref name="T"/>.
            <para>If object is not the correct type, or fails to parse, then the default for the type will be returned instead (Unless <paramref name="ErrorNoSuccess"/> is true)</para>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="ColumnName"></param>
            <param name="Alias"></param>
            <param name="ErrorNoSuccess"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocRecord.TryEvaluate``1(System.Int32,``0@)">
            <summary>
            Tries to get the value of the field as a variable of type <typeparamref name="T"/>. 
            <para>Return value indicates whether the record value was successfully parsed.</para>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="Position"></param>
            <param name="Result"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocRecord.TryEvaluate``1(System.String,``0@,System.String)">
            <summary>
            Tries to get the value of the field as a variable of type <typeparamref name="T"/>. 
            <para>Return value indicates whether the record value was successfully parsed.</para>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="ColumnName"></param>      
            <param name="Result"></param>
            <param name="Alias"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocRecord.TryGet(SEIDR.Doc.DocRecordColumnInfo,System.Object@)">
            <summary>
            Tries to get data associated with the column for this record, data type depending on Column's data type.
            </summary>
            <param name="col"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocRecord.TryGet(System.String,System.Object@,System.String,System.Int32)">
            <summary>
            Tries to get an the object associated with the value.
            <para>Data type will match that of the specified column via TryParse. If you just want the string value - use the <see cref="M:SEIDR.Doc.DocRecord.GetBestMatch(System.String,System.String,System.Int32)"/> instead.</para>
            </summary>
            <param name="ColumnName"></param>
            <param name="result"></param>
            <param name="alias"></param>
            <param name="position"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocRecord.TryMapRecord``1(``0@)">
            <summary>
            Attempt to map DocRecord to an instance of Type T, where T is any type that has a parameterless constructor and setter properties.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocRecord.GetColumns(System.Predicate{SEIDR.Doc.DocRecordColumnInfo})">
            <summary>
            Enumerate a subset of columns associated with the record.
            </summary>
            <param name="Test"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocRecord.OnRecordDataChanged(SEIDR.Doc.RecordChangedEventArgs)">
            <summary>
            Raise event for record data being changed
            </summary>
            <param name="e"></param>
        </member>
        <member name="E:SEIDR.Doc.DocRecord.RecordDataChanged">
            <summary>
            A DocRecord has been modified - raise event to listeners
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DocRecord.Merge(SEIDR.Doc.DocRecordColumnCollection,SEIDR.Doc.DocRecord,SEIDR.Doc.DocRecord,System.Boolean)">
            <summary>
            Merges <paramref name="left"/> and <paramref name="right"/> into a new DocRecord using the Column meta data from <paramref name="collection"/>.
            </summary>
            <param name="collection"></param>
            <param name="left"></param>
            <param name="right"></param>
            <param name="checkExist">If true, only sets the column if it exists in the target collection. Otherwise, may throw na error if <paramref name="left"/> or <paramref name="right"/> contains a column not in the destination.</param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocRecord.AddMissingContent(SEIDR.Doc.DocRecord,System.String)">
            <summary>
            If a record was missing columns because of an extra newline incorrectly included in the content...Merges the last column of this record with the first record of <paramref name="b"/>, and then adds the rest to the end of content.
            </summary>
            <param name="b"></param>
            <param name="connection">Identifier to use when merging content from the first record of b into the last column of this Record</param>
        </member>
        <member name="M:SEIDR.Doc.DocRecord.HasColumn(System.String,System.String)">
            <summary>
            Checks if the record's column information contains the information being requested
            </summary>
            <param name="Alias"></param>
            <param name="ColumnName"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocRecord.HasColumn(System.String)">
            <summary>
            Check if there's any column that matches when an alias is unspecified
            </summary>
            <param name="ColumnName"></param>
            <returns></returns>
        </member>
        <member name="F:SEIDR.Doc.DocRecord.Columns">
            <summary>
            Used for determining records...
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DocRecord.ToString">
            <summary>
            Overrides to string, combining the columns depending on the set up of the Column Collection it was created with
            </summary>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocRecord.ToString(SEIDR.Doc.MetaDataBase,System.Boolean)">
            <summary>
            To string with option to include the end line delimiter or not.
            </summary>
            <param name="metaData"></param>
            <param name="includeLineEndDelimiter"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocRecord.AddToStringBuilder(System.Text.StringBuilder,SEIDR.Doc.MetaDataBase,System.Boolean)">
            <summary>
            Adds the record and the LineDelimiter to the stringbuilder
            </summary>
            <param name="sb"></param>
            <param name="metaData"></param>
            <param name="includeLineEndDelimiter"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocRecord.#ctor">
            <summary>
            Basic constructor, for use with DocReader. Does not do anything, Columns CanWrite, and content will need to be set separately
            </summary>        
        </member>
        <member name="M:SEIDR.Doc.DocRecord.#ctor(SEIDR.Doc.DocRecordColumnCollection)">
            <summary>
            Sets up a very basic DocRecord
            </summary>
            <param name="owner"></param>
        </member>
        <member name="M:SEIDR.Doc.DocRecord.#ctor(SEIDR.Doc.DocRecordColumnCollection,System.Boolean)">
            <summary>
            Sets up the DocRecord with owner and CanWrite
            </summary>
            <param name="owner"></param>
            <param name="canWrite"></param>
        </member>
        <member name="M:SEIDR.Doc.DocRecord.#ctor(SEIDR.Doc.DocRecordColumnCollection,System.Boolean,System.Collections.Generic.IList{System.String})">
            <summary>
            Sets up the DocRecord with an owner, CanWrite, and initial content
            </summary>
            <param name="owner"></param>
            <param name="canWrite"></param>
            <param name="ParsedContent"></param>
        </member>
        <member name="M:SEIDR.Doc.DocRecord.SetParsedContent(System.Collections.Generic.IList{System.String})">
            <summary>
            Resets the underlying content list and sets the values from the Ilist
            </summary>
            <param name="ParsedContent"></param>
        </member>
        <member name="M:SEIDR.Doc.DocRecord.Configure(SEIDR.Doc.DocRecordColumnCollection,System.Nullable{System.Boolean},System.Collections.Generic.IList{System.String})">
            <summary>
            Allows using the more complex constructor logic after construction. Mainly intended for use by DocColumnCollection generic parse
            </summary>
            <param name="owner"></param>
            <param name="canWrite"></param>
            <param name="parsedContent"></param>
        </member>
        <member name="P:SEIDR.Doc.DocRecord.CanWrite">
            <summary>
            Sets whether user can update values of the record.
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DocRecord.MissingData">
            <summary>
            If true, indicates that there was an early line terminator in delimited mode. (e.g. Column meta data indicates that there should be columns 1, 2, 3. But DocRecord only has data for columns 1 and 2)
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DocRecord.Item(System.String)">
            <summary>
            Gets/sets the column using Column name. Uses the column collection's default alias
            <para>Can only set the column if <see cref="P:SEIDR.Doc.DocRecord.CanWrite"/> is true.</para>
            </summary>        
            <param name="ColumnName"></param>
            <returns></returns>
        </member>
        <member name="P:SEIDR.Doc.DocRecord.Item(System.String,System.String)">
            <summary>
            Gets/sets the column using alias + Column name.
            <para>Can only set the column if <see cref="P:SEIDR.Doc.DocRecord.CanWrite"/> is true.</para>
            </summary>
            <param name="alias"></param>
            <param name="ColumnName"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocRecord.GetBestMatch(System.String,System.String,System.Int32)">
            <summary>
            Tries to get the best matching column
            </summary>
            <param name="ColumnName"></param>
            <param name="alias"></param>
            <param name="position">Optional position filter if source file has more than one column with the same name.</param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocRecord.SetBestMatch(System.String,System.String,System.String,System.Int32)">
            <summary>
            Attempts to set the value for the first column that matches specified criteria.
            </summary>
            <param name="value"></param>
            <param name="ColumnName"></param>
            <param name="alias"></param>
            <param name="position"></param>
            <returns></returns>
        </member>
        <member name="P:SEIDR.Doc.DocRecord.Item(SEIDR.Doc.DocRecordColumnInfo)">
            <summary>
            Gets/sets the value associated with the column
            </summary>
            <param name="column"></param>
            <returns></returns>
        </member>
        <member name="P:SEIDR.Doc.DocRecord.Item(SEIDR.Doc.IRecordColumnInfo)">
            <summary>
            Uses the Position specified by column to call <see cref="P:SEIDR.Doc.DocRecord.Item(System.Int32)"/>.
            </summary>
            <param name="column"></param>
            <returns></returns>
        </member>
        <member name="P:SEIDR.Doc.DocRecord.Item(System.Int32)">
            <summary>
            Getter/setter using position of the columns
            </summary>
            <param name="columnIndex"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocRecord.SetValue(System.Int32,System.Object)">
            <summary>
            Attempts to set the value to the string representation of the object (by calling <see cref="M:System.Object.ToString"/> )
            </summary>
            <param name="columnIndex"></param>
            <param name="value"></param>
        </member>
        <member name="M:SEIDR.Doc.DocRecord.SetValue(System.String,System.String,System.Int32,System.Object)">
            <summary>
            Attempts to set the value to the string representation of the object (by calling <see cref="M:System.Object.ToString"/> )
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DocRecord.SetValue(System.String,System.String,System.Object)">
            <summary>
            Attempts to set the value to the string representation of the object (by calling <see cref="M:System.Object.ToString"/> )
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DocRecord.SetValue(System.String,System.Object)">
            <summary>
            Attempts to set the value to the string representation of the object (by calling <see cref="M:System.Object.ToString"/> )
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DocRecord.KeyValues">
            <summary>
            Represent object as list of key values. For debug purposes.
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DocRecord.KeyValuesAlphabetical">
            <summary>
            Represent object as list of key values, sorted by column name. For debug purposes.
            </summary>
        </member>
        <member name="T:SEIDR.Doc.DocRecordColumnCollection">
            <summary>
            Document column information for doc reader/writer
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DocRecordColumnCollection.ParseFromIRecordSet(System.String,System.Collections.Generic.IEnumerable{SEIDR.Doc.IDataRecord})">
            <summary>
            Using IRecord info containing the following columns at minimum:
            <para>ColumnName (or Name)</para>        
            <para>Optional: Position (or Index/ID), MaxLength, LeftJustify, DataType</para>
            </summary>
            <param name="alias"></param>
            <param name="columnRecords"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocRecordColumnCollection.ParseFromType(System.Type)">
            <summary>
            Creates a column collection from a class's properties.
            </summary>
            <param name="toParse"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocRecordColumnCollection.Merge(System.String,SEIDR.Doc.DocRecordColumnCollection,SEIDR.Doc.DocRecordColumnCollection)">
            <summary>
            Merges the two column collections and returns a new collection with the specified alias
            </summary>
            <param name="newAlias"></param>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="P:SEIDR.Doc.DocRecordColumnCollection.DefaultNullIfEmpty">
            <summary>
            Default value for new columns' <see cref="P:SEIDR.Doc.DocRecordColumnInfo.NullIfEmpty"/>. Default is true
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DocRecordColumnCollection.Merge(SEIDR.Doc.DocRecordColumnCollection,SEIDR.Doc.DocRecordColumnCollection)">
            <summary>
            Merges the two column collections
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="P:SEIDR.Doc.DocRecordColumnCollection.Count">
            <summary>
            Number of columns in the collection
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DocRecordColumnCollection.MaxLength">
            <summary>
            If in fixed width mode, returns the max size of a record, based on the widths of columns.
            <para>May return -1 if one of the columns is not valid for fixed width mode (<see cref="P:SEIDR.Doc.DocRecordColumnCollection.Valid"/> will be false)</para>
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DocRecordColumnCollection.ParseRecord(System.Boolean,System.String,System.Boolean,System.Boolean,System.Nullable{System.Char},System.String,System.Boolean,System.Boolean)">
            <summary>
            Parses the record into a list of strings, for use with one of the DocRecord constructors (mainly, when using a class that inherits from DocRecord) 
            </summary>
            <param name="writeMode"></param>
            <param name="record"></param>
            <param name="FixWidth"></param>
            <param name="VariableWidth"></param>
            <param name="Delimiter"></param>
            <param name="TextQualifier"></param>
            <param name="AllowMissingColumns"></param>
            <param name="ThrowExceptionColumnCountMismatch"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocRecordColumnCollection.RenameColumn(System.Int32,System.String)">
            <summary>
            Changes the <see cref="P:SEIDR.Doc.DocRecordColumnInfo.ColumnName"/> of the associated column.
            </summary>
            <param name="position"></param>
            <param name="NewName"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocRecordColumnCollection.#ctor(System.String)">
            <summary>
            Creates a basic set up
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DocRecordColumnCollection.IndexOf(SEIDR.Doc.DocRecordColumnInfo)">
            <summary>
            Checks for the index of the column
            </summary>
            <param name="column"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocRecordColumnCollection.#ctor(System.Collections.Generic.List{SEIDR.Doc.DocRecordColumnInfo})">
            <summary>
            Attempts to set up for fixed width columns with prepopulated list
            </summary>
            <param name="columns"></param>
        </member>
        <member name="M:SEIDR.Doc.DocRecordColumnCollection.#ctor(SEIDR.Doc.DocRecordColumnInfo[])">
            <summary>
            Create Collection from list of columns
            </summary>
            <param name="cols"></param>
        </member>
        <member name="P:SEIDR.Doc.DocRecordColumnCollection.CanUseAsFixedWidth">
            <summary>
            True if the collection is valid for use as FixedWidth
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DocRecordColumnCollection.Valid">
            <summary>
            Usable for doc writing/reading
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DocRecordColumnCollection.RaggedRight">
            <summary>
            For use with Fix-width mode. Requires a line end delimiter.
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DocRecordColumnCollection.Alias">
            <summary>
            Default alias for new columns
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DocRecordColumnCollection.Item(System.String)">
            <summary>
            Grabs the first column whose column name matches, and whose alias matches <see cref="P:SEIDR.Doc.DocRecordColumnCollection.Alias"/>
            </summary>
            <param name="ColumnName"></param>
            <returns></returns>
        </member>
        <member name="P:SEIDR.Doc.DocRecordColumnCollection.Item(System.String,System.String,System.Int32)">
            <summary>
            Access Column info for specific column/alias
            </summary>
            <param name="SpecificAlias"></param>
            <param name="ColumnName"></param>
            <param name="Position">Physical position</param>
            <returns></returns>
        </member>
        <member name="P:SEIDR.Doc.DocRecordColumnCollection.BestMatchStrict">
            <summary>
            If true, then when getting BestMatch, will require an alias match if alias parameter is not null.
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DocRecordColumnCollection.GetBestMatch(System.String,System.String,System.Int32,System.Nullable{System.Boolean})">
            <summary>
            Attempt to get the best match for the column.
            </summary>
            <param name="Column"></param>
            <param name="alias"></param>
            <param name="position">Optional position filter</param>
            <param name="strict">Indicate that alias needs to match if <paramref name="alias"/> is not null.</param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocRecordColumnCollection.HasColumn(SEIDR.Doc.DocRecordColumnInfo)">
            <summary>
            Validates that the column is considered a member of this collection.
            </summary>
            <param name="columnInfo"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocRecordColumnCollection.HasColumn(System.String,System.String,System.Int32)">
            <summary>
            Check if a column exists that matches
            </summary>
            <param name="SpecificAlias"></param>
            <param name="ColumnName"></param>
            <param name="Position"></param>
            <returns></returns>
        </member>
        <member name="P:SEIDR.Doc.DocRecordColumnCollection.Item(System.Int32)">
            <summary>
            Access columns by index. Also the indexer that allows updating columns.
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocRecordColumnCollection.AddColumn(System.String,System.Nullable{System.Int32},System.Boolean,System.Boolean,SEIDR.Doc.DocRecordColumnType)">
            <summary>
            Adds a new column and returns its index
            </summary>
            <param name="ColumnName"></param>
            <param name="MaxSize"></param>
            <param name="leftJustify">Indicates if column should be left justified in fix width mode</param>
            <param name="textQualify">Indicates whether the column should be text qualified when writing.</param>
            <param name="dataType"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocRecordColumnCollection.CheckPositions">
            <summary>
            Force Columns to match their position in underlying list.
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DocRecordColumnCollection.RemoveColumnInfo(System.Collections.Generic.IEnumerable{SEIDR.Doc.DocRecordColumnInfo})">
            <summary>
            Remove a set of columns from the collection and re-evaluate positions.
            <para>This should typically not be used after starting to read/write a file associated with these columns</para>
            </summary>
            <param name="columnsToRemove"></param>
        </member>
        <member name="M:SEIDR.Doc.DocRecordColumnCollection.RemoveColumnInfo(SEIDR.Doc.DocRecordColumnInfo[])">
            <summary>
            Remove a set of columns from the collection and re-evaluate positions.
            <para>This should typically not be used after starting to read/write a file associated with these columns</para>
            </summary>
            <param name="columnsToRemove"></param>
        </member>
        <member name="M:SEIDR.Doc.DocRecordColumnCollection.UpdateColumn(System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.Boolean})">
            <summary>
            Updates the column information specified by column name, under this collection's <see cref="P:SEIDR.Doc.DocRecordColumnCollection.Alias"/>
            </summary>
            <param name="ColumnName"></param>
            <param name="newName"></param>
            <param name="MaxSize"></param>
            <param name="nullIfEmpty">If set, overrides the column value. If null, leaves the column's value alone</param>
        </member>
        <member name="M:SEIDR.Doc.DocRecordColumnCollection.UpdateColumn(System.String,System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.Boolean},System.Nullable{SEIDR.Doc.DocRecordColumnType})">
            <summary>
            Updates the column information specified by the Alias/column Name
            </summary>
            <param name="Alias"></param>
            <param name="ColumnName"></param>
            <param name="newName"></param>
            <param name="MaxSize"></param>
            <param name="NullIfEmpty">If set, overrides the column value. If null, leaves the column's value alone</param>
            <param name="dataType">Data Type of column</param>
        </member>
        <member name="P:SEIDR.Doc.DocRecordColumnCollection.LastPosition">
            <summary>
            Last position value in the underlying columns, for looping.
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DocRecordColumnCollection.AddColumn(SEIDR.Doc.DocRecordColumnInfo)">
            <summary>
            Adds the set up column to the collection
            </summary>
            <param name="column"></param>
            <returns>Position of the column.</returns>
        </member>
        <member name="M:SEIDR.Doc.DocRecordColumnCollection.AddMapping(System.Collections.Generic.Dictionary{System.Int32,SEIDR.Doc.DocRecordColumnInfo},SEIDR.Doc.DocRecordColumnInfo,System.String,System.String)">
            <summary>
            Adds a mapping of a source column to a column in this collection (Best Match)
            <para>Returns 'this' for method chaining.</para>
            </summary>
            <param name="map"></param>
            <param name="source"></param>
            <param name="ColumnName"></param>
            <param name="alias"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocRecordColumnCollection.CheckForFixedWidthValid">
            <summary>
            Checks if the object can be used for fixed width. 
            <para>Should be used if setting column information via indexers</para>
            </summary>
        </member>
        <member name="T:SEIDR.Doc.IRecordColumnInfo">
            <summary>
            Column information
            </summary>
        </member>
        <member name="P:SEIDR.Doc.IRecordColumnInfo.Position">
            <summary>
            Column position in a record.
            </summary>
        </member>
        <member name="P:SEIDR.Doc.IRecordColumnInfo.SortASC">
            <summary>
            If sort is ascending order.
            </summary>
        </member>
        <member name="T:SEIDR.Doc.DocRecordColumnInfo">
            <summary>
            Column information for Doc Reader/Writer
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DocRecordColumnInfo.CheckNeedTextQualifier(System.String,System.String)">
            <summary>
            Check whether or not a value indicates that the column should be text qualified.
            </summary>
            <param name="delimiter"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="P:SEIDR.Doc.DocRecordColumnInfo.Array">
            <summary>
            For formatting - indicates that data is separated by a subdelimiter and can be returned as an array or list.
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DocRecordColumnInfo.ArrayDelimiter">
            <summary>
            Data is expected to be an array - delimiter for splitting data.
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DocRecordColumnInfo.SetArrayMode(System.String)">
            <summary>
            Set to Array mode, and also set the ArrayDelimiter.
            </summary>
            <param name="arrDelim"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocRecordColumnInfo.UnsetArrayMode">
            <summary>
            Sets <see cref="P:SEIDR.Doc.DocRecordColumnInfo.Array"/> to false, and clears the <see cref="P:SEIDR.Doc.DocRecordColumnInfo.ArrayDelimiter"/>
            </summary>
            <returns></returns>
        </member>
        <member name="P:SEIDR.Doc.DocRecordColumnInfo.DataType">
            <summary>
            Indicates type of data
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DocRecordColumnInfo.ExtraMetaData">
            <summary>
            Optional, additional meta Data to associate to a column.
            <para>Defaults to null.</para>
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DocRecordColumnInfo.Format">
            <summary>
            Optional formatting for certain data types.
            <para>Currently only used for Date/DateTime</para>
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DocRecordColumnInfo.op_Implicit(SEIDR.Doc.DocRecordColumnInfo)~System.Int32">
            <summary>
            Treats the column as an int by position.
            </summary>
            <param name="column"></param>
        </member>
        <member name="M:SEIDR.Doc.DocRecordColumnInfo.op_Implicit(SEIDR.Doc.DocRecordColumnInfo)~System.String">
            <summary>
            Treats the column as a string by taking its Name (primary identifier)
            </summary>
            <param name="column"></param>
        </member>
        <member name="P:SEIDR.Doc.DocRecordColumnInfo.SEIDR#Doc#IRecordColumnInfo#SortASC">
            <summary>
            Sort order for <see cref="T:SEIDR.Doc.IRecordColumnInfo"/>
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DocRecordColumnInfo.NullIfEmpty">
            <summary>
            If true, a value matching <see cref="F:System.String.Empty"/> will be treated as null.
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DocRecordColumnInfo.MaxLength">
            <summary>
            Maximum width of the column when used with fixed width
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DocRecordColumnInfo.EarlyTerminator">
            <summary>
            For use with fixed width, cause column to end early. 
            <para>E.g., final column ends as soon as it reaches a newline instead of after <see cref="P:SEIDR.Doc.DocRecordColumnInfo.MaxLength"/> characters</para>
            <para>Note: last column in fixed width should account for the space taken by NewLine</para>
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DocRecordColumnInfo.ColumnName">
            <summary>
            Name of the column
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DocRecordColumnInfo.FullColumnName">
            <summary>
            <see cref="P:SEIDR.Doc.DocRecordColumnInfo.ColumnName"/>, but if the <see cref="P:SEIDR.Doc.DocRecordColumnInfo.OwnerAlias"/> is set, will be prepended by the OwnerAlias and a dot.
            <para>E.g. "a.ColName" or "fi .Name of Column"</para>
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DocRecordColumnInfo.OwnerAlias">
            <summary>
            Alias of the column's owner
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DocRecordColumnInfo.#ctor(System.String,System.String,System.Int32)">
            <summary>
            Creates a new Delimited Record Column info record, for getting information out of a delimited record
            </summary>
            <param name="Column"></param>
            <param name="Alias"></param>
            <param name="position">Column position</param>
        </member>
        <member name="M:SEIDR.Doc.DocRecordColumnInfo.#ctor(System.String,SEIDR.Doc.DocRecordColumnType,System.String)">
            <summary>
            Construct column info with unknown position. (Determine in collection)
            </summary>
            <param name="Column"></param>
            <param name="alias"></param>
            <param name="type"></param>
        </member>
        <member name="M:SEIDR.Doc.DocRecordColumnInfo.#ctor(System.String,System.String,System.Int32,SEIDR.Doc.DocRecordColumnType)">
            <summary>
            Creates a new Doc Record Column Info record, includes specifying type of data.
            </summary>
            <param name="column"></param>
            <param name="Alias"></param>
            <param name="position"></param>
            <param name="type"></param>
        </member>
        <member name="P:SEIDR.Doc.DocRecordColumnInfo.Position">
            <summary>
            Intended Position of the column in the raw file.
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DocRecordColumnInfo.TextQualify">
            <summary>
            Used when writing with <see cref="T:SEIDR.Doc.DocWriter"/>. Ignored in Fixed width mode.
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DocRecordColumnInfo.LeftJustify">
            <summary>
            Used when writing with <see cref="T:SEIDR.Doc.DocWriter"/>. Ignored in delimited mode
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DocRecordColumnInfo.Equals(System.Object)">
            <summary>
            Check that the columns are referencing the same data
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocRecordColumnInfo.op_Equality(SEIDR.Doc.DocRecordColumnInfo,SEIDR.Doc.DocRecordColumnInfo)">
            <summary>
            Check that the alias and column name match
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocRecordColumnInfo.op_Inequality(SEIDR.Doc.DocRecordColumnInfo,SEIDR.Doc.DocRecordColumnInfo)">
            <summary>
            Check that the alias or column name do not match
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocRecordColumnInfo.GetHashCode">
            <summary>
            Hash code is dependent on column name and alias only
            </summary>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocRecordColumnInfo.ToString">
            <summary>
            ToString, just returns Column Name.
            </summary>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocRecordColumnInfo.ToString(System.Boolean)">
            <summary>
            Alternate version of toString.
            </summary>
            <param name="includeAlias">If true and alias is non empty, will be formatted as [Alias].[ColumnName]<para>
            If true and alias is empty/white space, will return [ColumnName]</para><para>
            Otherwise, will return <see cref="M:SEIDR.Doc.DocRecordColumnInfo.ToString"/></para></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocRecordColumnInfo.CreateColumns(System.String,System.String[])">
            <summary>
            Sets up the columns using the same alias and in the same order as the passed parameters
            </summary>
            <param name="Alias"></param>
            <param name="ColumnList"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocRecordColumnInfo.Evaluate``1(System.String,System.Boolean)">
            <summary>
            Uses <see cref="!:TryGet(string, out object)"/> to return an object of type <typeparamref name="T"/>.
            <para>If the data type does not match, will either return the default for the type or throw an error, depending on <paramref name="DefaultOnFailure"/>.</para>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="value"></param>
            <param name="DefaultOnFailure"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocRecordColumnInfo.CompareDataType(System.Object)">
            <summary>
            Check if the object's type is compatible with the column meta data.
            </summary>
            <param name="o"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocRecordColumnInfo.TryEvaluate``1(System.String,``0@)">
            <summary>
            Tries to get the value as a variable of type <typeparamref name="T"/>.
            <para>Return value indicates whether record was successfully parsed.</para>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="value"></param>
            <param name="Result"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocRecordColumnInfo.TryGet(System.String,System.Object@,System.Boolean)">
            <summary>
            Tries to parse out the data from the value, based on Column data type.
            </summary>
            <param name="val"></param>
            <param name="result"></param>
            <param name="fromArray">Indicates that the caller is trying to get individual items from the array.</param>
            <returns></returns>
        </member>
        <member name="T:SEIDR.Doc.DocExtensions">
            <summary>
            Extensions related to documents/files and reading/writing/manipulating content
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DocExtensions.SerializeToFile(System.Object,System.String)">
            <summary>
            Overwrite the filepath with the xml content of the object (Basic XML serializer)
            </summary>
            <param name="toFile"></param>
            <param name="FilePath"></param>
        </member>
        <member name="M:SEIDR.Doc.DocExtensions.DeSerializeFile``1(System.String)">
            <summary>
            Deserialize the file's content into an instance fo type RT (Basic XML serializer)
            </summary>
            <typeparam name="RT"></typeparam>
            <param name="FilePath"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocExtensions.SerializeToXML(System.Object)">
            <summary>
            Serialize the object to an XML string and return it (Basic XML serializer)
            </summary>
            <param name="toString"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocExtensions.DeserializeXML``1(System.String)">
            <summary>
            Attempt to deserialize the XML into an object of type RT. Does not catch exceptions
            <para>Uses Basic XMLSerializer</para>
            </summary>
            <typeparam name="RT"></typeparam>
            <param name="XML"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocExtensions.GuessDelimiter(System.String)">
            <summary>
            Tries to guess the delimiter of a line string from the following characters: |,\t;:
            </summary>
            <param name="line"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocExtensions.GuessDelimiter(System.Collections.Generic.IList{System.String},System.Int32)">
            <summary>
            Guess the delimiter from a List of strings, assuming they will have the same primary delimiter.
            </summary>
            <param name="lines"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocExtensions.GetFileHash(System.IO.FileInfo)">
            <summary>
            Uses md5 to create a hash of the file content. Returns null if the file does not exist.
            </summary>
            <param name="file"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocExtensions.GetFileHash(System.String)">
            <summary>
            Uses md5 to create a hash of the file content from the file whose path is specified.
            <para>Returns null if file does not exist.</para>
            </summary>
            <param name="fullFilePath"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocExtensions.AddAttributes(System.IO.FileInfo,System.IO.FileAttributes[])">
            <summary>
            Add listed attributes to the File and refreshes the FilInfo. Does nothing if the File doesn't exist.
            </summary>
            <param name="f"></param>
            <param name="AttributesToAdd"></param>
        </member>
        <member name="M:SEIDR.Doc.DocExtensions.RemoveAttributes(System.IO.FileInfo,System.IO.FileAttributes[])">
            <summary>
            Remove listed attributes from the File and refreshes the FilInfo. Does nothing if the File doesn't exist.
            </summary>
            <param name="f"></param>
            <param name="attributesToRemove"></param>
        </member>
        <member name="M:SEIDR.Doc.DocExtensions.GetFileName(System.String,System.DateTime)">
            <summary>
            Generates a new file name using the dateFormat and passed FileDate. Multiple date offsets can be used by offsetting with an alias.
            <para>E.g., &lt;a:0YYYY0MM-1D>test_&lt;a:YY>_&lt;a:MM>_&lt;a:DD>_&lt;DD>.txt for date 2017/12/2 should lead to test_17_12_01_02.txt</para>
            </summary>
            <param name="dateFormat"></param>
            <param name="fileDate"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocExtensions.ParseDateRegex(System.String,System.String,System.DateTime@)">
            <summary>
            Parses the file date out of a file.
            <para>Example: file_&lt;YYYY>_&lt;MM>_&lt;DD>_*&lt;0YYYY0MM1DD>.txt might be used for file_2017_12_01_through_2017_12_04.txt to get 2017/12/02</para>
            <para>Another example for the same fileName: file_*_through_&lt;YYYY>_&lt;MM>_&lt;DD>_&lt;0YYYY0MM-2DD>.txt could be used for file_2017_12_01_through_2017_12_04.txt to get 2017/12/02</para>
            </summary>
            <param name="fileName"></param>
            <param name="dateFormat"></param>
            <param name="fileDate">File date from parsing the fileName with dateFormat. Will be unchanged if the method returns false. 
            <para>Note: if the format has an offset for Month/Year, this could potentially lead to some unexpected behavior due to months having different numbers of days, or leap years.
            </para>
            </param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocExtensions.GetFileDate(SEIDR.Doc.DocMetaData,System.String)">
            <summary>
            Gets the file date
            </summary>
            <param name="metaData"></param>
            <param name="dateFormat"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocExtensions.ParseDate(System.String,System.String,System.DateTime@)">
            <summary>
            Parses the filename to determine a date that should be associated with it. 
            <para>If a date can be determined, the FileDate out parameter will be set and usable</para>
            </summary>
            <param name="fileName"></param>
            <param name="dateFormat">* For skipping a variable number of misc characters, &lt;MM> for Finding a month, &lt;DD> for finding a day, &lt;YY> for finding year without century, &lt;YYYY> for finding year with century.
            <para>E.g., 'example01_2016_File_12_30' would match 'example01_*&lt;YYYY>_File_&lt;MM>_&lt;DD>' or '*&lt;YYYY>*&lt;MM>_&lt;DD>'. Other numbers in between may cause issues, though. </para> </param>
            <param name="FileDate"></param>
            <returns>True if able to parse a date from the file name using specified format.</returns>
        </member>
        <member name="M:SEIDR.Doc.DocExtensions.CleanLine(System.String)">
            <summary>
            Removes invisible characters from a line of text. Also replaces u0092 with single quote.
            </summary>
            <param name="line"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocExtensions.SplitOutsideQuotes(System.String,System.Char,System.Char)">
            <summary>
            Splits a string so that delimiters inside quotes do not create extra fields.
            </summary>
            <remarks>Assumes that there are no NULL characters in the string.</remarks>
            <param name="line">Line to be split</param>
            <param name="delimiter">Delimiter to split the file</param>
            <param name="TextQual">Text qualifier. Delimiters between text qualifiers will be kept. Default to '"'</param>
            <returns>Array of strings split by delimiter except where the delimiter is between text qualifiers</returns>
        </member>
        <member name="M:SEIDR.Doc.DocExtensions.SplitOutsideQuotes(System.String,System.Char,System.String)">
            <summary>
            Splits a string so that delimiters inside quotes do not create extra fields.
            </summary>
            <remarks>Assumes that there are no NULL characters in the string.</remarks>
            <param name="line">Line to be split</param>
            <param name="delimiter">Delimiter to split the file</param>
            <param name="TextQual">Text qualifier. Delimiters between text qualifiers will be kept.</param>
            <returns>Array of strings split by delimiter except where the delimiter is between text qualifiers</returns>
        </member>
        <member name="M:SEIDR.Doc.DocExtensions.StartsWithByteSet(System.Byte[],System.Byte[])">
            <summary>
            Return true if the byte array to check starts with all of the bytes specified in start set, in the same order.
            </summary>
            <param name="check"></param>
            <param name="startSet">Byte list that the CHECK parameter must start with to return true.</param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocExtensions.StartsWithByteSet(System.Char[],System.Text.Encoding,System.Byte[])">
            <summary>
            Attempt to check if char array converted to bytes matches the start set
            </summary>
            <param name="check"></param>
            <param name="encodingType"></param>
            <param name="startSet"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocExtensions.GetEmptyTable(SEIDR.Doc.DocRecordColumnCollection,System.String)">
            <summary>
            Returns an empty DataTable, with columns populated based on the source DocRecordColumnCollection.
            </summary>
            <param name="TableName"></param>
            <param name="recordColumns"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocExtensions.ToDataTableDoc``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Converts an IEnumerable set of DataRecords into a DataTableDoc.
            </summary>
            <typeparam name="DT"></typeparam>
            <param name="dataRecords"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocExtensions.GetDataTableDocPage``1(SEIDR.Doc.DocReader{``0},System.Int32)">
            <summary>
            Returns a page of the DocReader as though it were a DataTable
            </summary>
            <typeparam name="DT"></typeparam>
            <param name="source"></param>
            <param name="page"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocExtensions.GetRecord``1(SEIDR.Doc.DocRecordColumnCollection,System.Object[])">
            <summary>
            Gets an object instance for a type that implements IDataRecord using the source column collection.
            </summary>
            <typeparam name="DT"></typeparam>
            <param name="sourceColumns"></param>
            <param name="dataSource"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocExtensions.Map``1(``0,SEIDR.Doc.DocRecordColumnCollection)">
            <summary>
            Maps the data from a record to a new record with a different underlying column collection.
            <para>Data is mapped based on ColumnName.</para>
            </summary>
            <typeparam name="DT"></typeparam>
            <param name="record"></param>
            <param name="newColumns">New ColumnSet to associate metadata for the returning record.</param>        
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocExtensions.Map``1(``0,SEIDR.Doc.DocRecordColumnCollection,SEIDR.Doc.DocWriterMap)">
            <summary>
            Maps the data from a record to a new record with a different underlying column collection.
            <para>Data is mapped based on ColumnName, unless the source record's column is mapped to a column from the destination.</para>
            </summary>
            <typeparam name="DT"></typeparam>
            <param name="record"></param>
            <param name="newColumns">New ColumnSet to associate metadata for the returning record.</param>        
            <param name="map">Allows mapping a column/position from <paramref name="record"/> to a named column in <paramref name="newColumns"/>.</param>
            <returns></returns>
        </member>
        <member name="T:SEIDR.Doc.FAttModder">
            <summary>
            Use to change the attributes of a given File.
            </summary>
        </member>
        <member name="M:SEIDR.Doc.FAttModder.RemoveAttribute(System.String,System.IO.FileAttributes[])">
            <summary>
            Removes any of the listed attributes from the file.
            <para>Throws an exception if the file does not exist.</para>
            </summary>
            <param name="fullFilePath">Full file path for file we want to change attributes on.</param>
            <param name="toRemove">List of FileAttributes to be turned off.</param>
        </member>
        <member name="M:SEIDR.Doc.FAttModder.AddAttribute(System.String,System.IO.FileAttributes[])">
            <summary>
            Adds any of the listed attributes from the file.
            <para>Throws an exception if the file does not exist.</para>
            </summary>
            <param name="fullFilePath">Full file path for file we want to change attributes on.</param>
            <param name="toAdd">List of FileAttributes to be turned on.</param>
        </member>
        <member name="T:SEIDR.Doc.GroupOn">
            <summary>
            For grouping data that's being processed by a processor. Implicitly gathers some aggregate data from the data when added, based on the type assigned to the GroupOn.
            </summary>
            <remarks>The average aggregation data is not exact and is instead an approximate average ONLY.
            <para>
            The GroupOn should be used consistently with the same fields or groupings of fields. If you are combining fields as a group, you should have an identifier to make sure that there are no cases like '430' + '14' matching '4' + '314'. Depending on the data, it's probably not advisable to combine fields as data unless you're creating a derived field and know what you're doing.
            </para>
            </remarks>
        </member>
        <member name="M:SEIDR.Doc.GroupOn.Matches(SEIDR.Doc.GroupOn)">
            <summary>
            Checks if two groupOns have the same name. Description is ignored actually.
            </summary>
            <param name="g"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.GroupOn.#ctor(System.String,SEIDR.Doc.GroupOn.GroupType,System.String)">
            <summary>
            Constructor + Description
            </summary>
            <param name="GroupName">Name for identifying this object. It should describe the type of data being grouped, with keys being the actual values grouping.</param>
            <param name="type">Type of object action to take when adding a string to the group's data</param>
            <param name="GroupDescription">Optional, extra description to describe the goal of the GroupOn object</param>
        </member>
        <member name="M:SEIDR.Doc.GroupOn.#ctor(System.String,SEIDR.Doc.GroupOn.GroupType)">
            <summary>
            Constructor
            </summary>
            <param name="GroupName">Name for identifying this object. It should describe the type of data being grouped, with keys being the actual values grouping.</param>
            <param name="type">Type of object action to take when adding a string to the group's data</param>
        </member>
        <member name="M:SEIDR.Doc.GroupOn.Compare(SEIDR.Doc.GroupOn,SEIDR.Doc.GroupOn)">
            <summary>
            Compares two GroupOns to see if they 
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="T:SEIDR.Doc.GroupOn.GroupType">
            <summary>
            How data is stored when you add an item to the group. Also determines the type of object returned when you want to get a dataObject for a given key.
            </summary>
        </member>
        <member name="F:SEIDR.Doc.GroupOn.GroupType.NumRange">
            <summary>
            double[4]: Min, Max, average. Conversion fail
            </summary>
        </member>
        <member name="F:SEIDR.Doc.GroupOn.GroupType.NumSign">
            <summary>
            int[4]: Count less than 0, Count == 0, Count greater than 0, conversion fail
            </summary>
        </member>
        <member name="F:SEIDR.Doc.GroupOn.GroupType.varchar">
            <summary>
            int[2]: Min Length, Max Length
            </summary>
        </member>
        <member name="F:SEIDR.Doc.GroupOn.GroupType.dateType">
            <summary>
            datetime[2]: min date, max date
            </summary>
        </member>
        <member name="F:SEIDR.Doc.GroupOn.GroupType.Record">
            <summary>
            List (string): just holds onto every piece of fieldDate added in a list of strings
            </summary>
        </member>
        <member name="P:SEIDR.Doc.GroupOn.type">
            <summary>
            Numeric representation of internal property '_type'. Mainly used for comparison between groupOn objects
            </summary>
        </member>
        <member name="P:SEIDR.Doc.GroupOn.Name">
            <summary>
            Name representing this groupOn. Mainly used for comparison between groupOn objects
            </summary>
        </member>
        <member name="M:SEIDR.Doc.GroupOn.AddData(System.String,System.String)">
            <summary>
            Adds the content of a string to a data object that matches based on the key( Case insensitive, trimmed spaces).
            <para>Type of object in data depends on the GroupType chosen at construction.</para>
            </summary>
            <param name="key">Key for finding the group/data Object we want to update.</param>
            <param name="fieldData">Content from a line of raw data that we want to use to update the data</param>
        </member>
        <member name="M:SEIDR.Doc.GroupOn.NewData(System.String,SEIDR.Doc.GroupOn.dataObj)">
            <summary>
            Initialize the object inside before adding it to the data list
            </summary>
            <param name="fieldData">Data used to modify object</param>
            <param name="data">Data object to modify</param>
        </member>
        <member name="M:SEIDR.Doc.GroupOn.ToString">
            <summary>
            Override object's ToString
            </summary>
            <returns>String representing the object</returns>
        </member>
        <member name="M:SEIDR.Doc.GroupOn.GetObject(System.String)">
            <summary>
            Gets the data for a specific key. You need to know what type of data it is based on what type of group on you chose.
            <para>Record: List(string), varchar: int[2], dateType: datetime[2], numrange: double[4], numSign: int[4]</para>
            </summary>
            <param name="key">Key for finding the data object holding the data you want.</param>
            <returns>Object containing the data associated with this key.</returns>
        </member>
        <member name="T:SEIDR.Doc.Processor">
            <summary>
            Can be Customized for doing some File Analysis.
            <para>By using the addon boolean, you can create multiple processors to check for different things in a given file.</para>
            <para>You can also use the addon boolean to combine analysis data from multiple files into one final output file.</para>
            <para> </para>
            <para>Run Procedure:</para>
            <para>Initialize Processor. Set things like Name and the AddOn Boolean or AddAdditionalInformation Boolean.</para>    
            <para>Initialize any objects you want to modify during any of the processing methods.</para>
            <para>Anything that can be found by using the indexer[string ReferenceName] will appear in the output report, plus any notes from the updateNote(string referenceName, noteText) method.</para>
            <para>Call The processor's Run method.</para>
            </summary>
            <remarks>
            Custom objects should be fine to use with the indexer as long as they override ToString().
            <para>The first Processor running in a program should have Addon set to false(the Default). An existing file will then be moved so that only data from your processors are in the same file. Header information can be added using the ReportHeader string array.</para>
            <para>The quick reader used by Processor will not provide Line Endings to the user. Any line ending analysis would require a custom reading of the file, or a different initiation the quick reader. In both cases, this means that the Processor class would not work for this purpose.</para>
            <para>Use the GroupOn class to organize data along with some premade and implicit aggregation functionality.</para>
            <para>Running multiple processor threads on the same file should technically be safe and not have lock issues, but is untested.</para>
            </remarks>
        </member>
        <member name="P:SEIDR.Doc.Processor.OutputFile">
            <summary>
            Full path of file to be created by processor.
            </summary>
        </member>
        <member name="M:SEIDR.Doc.Processor.ChangeOutputFolder(System.String)">
            <summary>
            Change the output directory of the processor to be the passed directory. Also creates the directory if it doesn't exist already.
            </summary>
            <param name="directory">Path to directory</param>
        </member>
        <member name="F:SEIDR.Doc.Processor.AddOn">
            <summary>
            Set to true to override default behavior and append any data from this processor to the end of the file.
            <para>Default: An existing file will be renamed so that a new file can be created for this processor</para>
            </summary>
        </member>
        <member name="F:SEIDR.Doc.Processor.ProcessorName">
            <summary>
            Used for Identifying Processor Write blocks.
            </summary>
        </member>
        <member name="P:SEIDR.Doc.Processor.Name">
            <summary>
            Used for Identifying Processor Write Blocks. 
            <para>Modifies the value of ProcessorName</para>
            </summary>
        </member>
        <member name="P:SEIDR.Doc.Processor.Item(System.String)">
            <summary>
            Public indexer. Cast values to object to store them. 
            <para>It may be necessary to cast to and from object when modifying values.</para>
            </summary>
            <remarks>
            Custom objects should be fine as long as they override ToString.
            </remarks>
            <param name="ReferenceName">Column name or parameter for grouping an object.</param>
            <returns>Value of object stored or null if it doesn't exist</returns>
        </member>
        <member name="M:SEIDR.Doc.Processor.GetString(System.String)">
            <summary>
            String version of getter. Will return null if the reference has not been created.
            </summary>
            <param name="ReferenceName"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.Processor.Has(System.String)">
            <summary>
            Returns true if the given reference name has an associated value.
            </summary>
            <param name="referenceName"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.Processor.GetDouble(System.String)">
            <summary>
            Attempts to find the reference. returns 0 if the reference doesn't exist or if it's not a double.
            </summary>
            <param name="referenceName"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.Processor.GetGroup(System.String)">
            <summary>
            GroupOn version of getter. Will return null if the reference has not been created.
            </summary>
            <param name="referenceName"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.Processor.SetAggregates(System.String[])">
            <summary>
            Mark objects in processor as aggregate.
            </summary>
            <param name="ReferenceNames">List of object names to mark aggregate</param>
        </member>
        <member name="M:SEIDR.Doc.Processor.GetLong(System.String)">
            <summary>
            Long version of getter. Returns 0 if not set. The value of the object if you try to get it via the indexer will still be null though.
            </summary>
            <param name="referenceName"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.Processor.GetInt(System.String)">
            <summary>
            int version of getter. Returns 0 if not set. The value of the object if you try to get it via the indexer will still be null though.
            </summary>
            <param name="referenceName"></param>
            <returns></returns>
        </member>
        <member name="P:SEIDR.Doc.Processor.defaultGet">
            <summary>
            Default datetime for GetDate(string)
            </summary>
        </member>
        <member name="M:SEIDR.Doc.Processor.GetDate(System.String)">
            <summary>
            Datetime version of getter. Returns the value of defaultGet if the value has not been set yet
            </summary>
            <param name="referenceName"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.Processor.Remove(System.String)">
            <summary>
            Removes a custom object from the results that will be in the output.
            </summary>
            <param name="referenceName">Column name or parameter for grouping an object.</param>
        </member>
        <member name="M:SEIDR.Doc.Processor.UpdateNote(System.String,System.String)">
            <summary>
            Update any notes associated with ReferenceName. It is not necessary to worry about formatting, that is already handled.
            <para>**NOTE:You cannot clear or remove values from the notes**</para>
            </summary>
            <param name="ReferenceName">Reference name. Matches the indexer. Must already exist.</param>
            <param name="NoteText">Notes associated with the reference name. Will be included in output</param>
        </member>
        <member name="P:SEIDR.Doc.Processor.RecordCount">
            <summary>
            Gets the record count. Headers and empty lines are not included.
            </summary>
        </member>
        <member name="F:SEIDR.Doc.Processor.ReportHeader">
            <summary>
            ReportHeader[0] = File Description
            <para>
            ReportHeader[...] = Section Names
            </para>
            </summary>
        </member>
        <member name="F:SEIDR.Doc.Processor.Process">
            <summary>
            Process function to apply to every line.
            <para>Can be used to update the underlying values stored and accessed by the indexer in order to get some automated analysis on a file.</para>
            <para>Can be set to point to any void function that takes a string as a parameter</para>
            <para>The pointed function can also include running a ProcessEventHolder on the line after splitting by delimiter.</para>
            <para>Default: Point to null(Does nothing)</para>
            </summary>
        </member>
        <member name="F:SEIDR.Doc.Processor.ProcessHeader">
            <summary>
            Will be called on the first non empty string unless it's null or FileHasHeader is set to false
            <para>Default: Point to null</para>
            </summary>
        </member>
        <member name="F:SEIDR.Doc.Processor.PostProcess">
            <summary>
            Will be called at the end of the processor's run. Can be used to add additional information/notes based on analysis of the various objects
            <para>Takes no parameters or points to a parameterless void function.</para>
            </summary>
        </member>
        <member name="M:SEIDR.Doc.Processor.#ctor(System.String,System.String,System.Boolean)">
            <summary>
            Constructor. Allows choice for output file's path
            <para>Any existing copy of the output file will be renamed to have its rename time at the end of its name, unless AddOn is set to true</para>
            </summary>
            <param name="FilePath">Full path to File to be analyzed</param>
            <param name="OutputPath">Full path to output analysis file.</param>
            <param name="Append">If true, add on to the file if it exists. Else rename any existing copy of a file at OutputPath</param>
        </member>
        <member name="M:SEIDR.Doc.Processor.#ctor(System.String)">
            <summary>
            Default Constructor. Output File with any analysis will be the given file and added extension of ".ilxp"
            <para>Any existing copy of the file will be renamed to have its rename time at the end of its name, unless AddOn is set to true</para>
            </summary>
            <param name="FilePath">Path to file to be analyzed</param>
        </member>
        <member name="M:SEIDR.Doc.Processor.#ctor(System.String,System.String[])">
            <summary>
            Constructor. Requires an output path but allows you to run multiple files through a single Processor
            <para>Example construction: Processor p = new Processor("C:/User/Test/Result.ilx", "C:/User/Test/Test1.txt", "C:/User/Test/Test2.txt",...)</para>
            </summary>
            <param name="outputFile">Path to file that will contain results</param>
            <param name="inputFiles">List of filepaths to run the processor on. This is params so it can be passed as a string[] or as a number of strings as separate parameters</param>
        </member>
        <member name="M:SEIDR.Doc.Processor.#ctor(System.String,System.Data.DataTable)">
            <summary>
            Run on the results of a query instead of a file.
            </summary>
            <param name="outputFile">File to contain any results</param>
            <param name="table">DataSet filled by a query</param>
        </member>
        <member name="M:SEIDR.Doc.Processor.ReInit(System.String,System.String[])">
            <summary>
            Restart the file settings in order to be able to do a new run.
            </summary>
            <param name="outputFile"></param>
            <param name="inputFiles"></param>
        </member>
        <member name="M:SEIDR.Doc.Processor.Reinit(System.String,System.Data.DataTable)">
            <summary>
            Restart using a DataSet as the data source for run
            </summary>
            <param name="outputFile"></param>
            <param name="table"></param>
        </member>
        <member name="F:SEIDR.Doc.Processor.FileHasHeader">
            <summary>
            Set to false if the file does not contain a header.
            <para> If true, ProcessHeader will be called on the first line, or it will be skipped if ProcessHeader is null</para>
            <para>Default: True.</para>
            </summary>
        </member>
        <member name="M:SEIDR.Doc.Processor.Run">
            <summary>
            Read each line of the file and processes it using the methods pointed to by Process and ProcessHeader
            <para>PostProcess is run at the end if it has been set to point to a non null method.</para>
            </summary>
            <remarks>
            An exception will be thrown if Process still points to null when this is run.
            </remarks>
        </member>
        <member name="F:SEIDR.Doc.Processor.ProcessData">
            <summary>
            Point to a method that processes a data row.
            <para>You should be able to either keep data in an object provided by the Processor's value holder(and will appear in the output), or an outside variable for your own methods and post process analysis.</para>
            </summary>
        </member>
        <member name="F:SEIDR.Doc.Processor.PostProcessData">
            <summary>
            Use for post processing analysis on the results of a query.
            </summary>
        </member>
        <member name="F:SEIDR.Doc.Processor.lineLength">
            <summary>
            Full length of each line in the output file.
            </summary>
        </member>
        <member name="F:SEIDR.Doc.Processor.NameLength">
            <summary>
            space taken up by variable name in output file. 
            </summary>
        </member>
        <member name="F:SEIDR.Doc.Processor.AddRunTimeInformation">
            <summary>
            Adds additional information about the run at the bottom of a section.
            </summary>
        </member>
        <member name="T:SEIDR.Doc.FileReader">
            <summary>
            FileReader is meant to read lines from a streamreader with the results put into string arrays split on standardized newlines.
            <para>Expectation is that lines will be split by some character, most likely a newline. If the newline is CRLF, will need to set the ChangeLineEndings property to true.
            </para>
            <para>Reading will return an array of strings split by a char</para>
            <para>Standard use:</para> 
            <para>QuickReader qr = new QuickReader(...);</para>
            <para>bool working = true;</para>
            <para> while(working){</para>
            <para> string[] lines = qr.Read(out working);...</para>
            <para>}</para>
            <para>Alternate, need to do something for first block only:</para> 
            <para>string[] lines = qr.Read(out working);</para>
            do{<para>...if (!moreWork)break;</para><para> qr.Read(out working);</para>
            <para>}while(true);</para>
            </summary>
            <remarks>
            <para>Any static methods will act on a single string and assume that there are no line endings inside the string.</para>
            There are also two static methods that are both for splitting lines and keeping any delimiters that are text qualified. 
            </remarks>
        </member>
        <member name="M:SEIDR.Doc.FileReader.SplitOutsideQuotes(System.String,System.Char)">
            <summary>
            Splits a string so that delimiters inside quotes do not create extra fields. Use '"' as Text Qualifier
            </summary>
            <remarks>Assumes that there is no line ending in the string.</remarks>
            <param name="line">Line to be split</param>
            <param name="delimiter">Delimiter to split the file</param>
            <returns>Array of strings split by delimiter except where the delimiter is between text qualifiers</returns>
        </member>
        <member name="M:SEIDR.Doc.FileReader.CleanLine(System.String)">
            <summary>
            Removes invisible characters from a line of text. Also replaces u0092 with single quote.
            </summary>
            <param name="line"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.FileReader.SplitOutsideQuotes(System.String,System.Char,System.Char)">
            <summary>
            Splits a string so that delimiters inside quotes do not create extra fields.
            </summary>
            <remarks>Assumes that there is no line ending in the string.</remarks>
            <param name="line">Line to be split</param>
            <param name="delimiter">Delimiter to split the file</param>
            <param name="TextQual">Text qualifier. Delimiters between text qualifiers will be kept</param>
            <returns>Array of strings split by delimiter except where the delimiter is between text qualifiers</returns>
        </member>
        <member name="F:SEIDR.Doc.FileReader.defaultBlock">
            <summary>
            Value used by newly created quickreader objects as the block size
            </summary>
        </member>
        <member name="P:SEIDR.Doc.FileReader.block">
            <summary>
            Sets the number of characters to try to read per call of Read.
            <para>
            Minimum value: 1000. An error will not be thrown if you try to set it to less, but the value will just be set to 1000 instead.
            </para>
            <remarks>
            Note that reading less characters than the size of the block is not a problem. 
            <para>Rather, reading fewer characters than the block size is the way to know that we're done with the file.
            </para>
            </remarks>
            </summary>
        </member>
        <member name="F:SEIDR.Doc.FileReader.TrimQuotes">
            <summary>
            Set to true to remove all quotes.
            </summary>
        </member>
        <member name="F:SEIDR.Doc.FileReader.CleanInvisibles">
            <summary>
            Set to true to remove invisible characters like form feed or null
            </summary>
        </member>
        <member name="P:SEIDR.Doc.FileReader.splitter">
            <summary>
            Character to split lines on.         
            </summary>
        </member>
        <member name="P:SEIDR.Doc.FileReader.ChangeLineEnding">
            <summary>
            If true, change all groups of line endings to a single LF. Else try to read as is.
            </summary>
        </member>
        <member name="M:SEIDR.Doc.FileReader.#ctor(System.String,System.Char)">
            <summary>
            Constructor with custom splitter
            </summary>
            <param name="path">File path to read</param>
            <param name="separator">Character to split lines on. If you want to split on line endings and need more than one character, you'll need to set ChangeLineEnding and then use '\n'.
            <para>If you want to split manually, I would suggest splitting by line endings and using '\n', then joining on '\n' and then doing your custom split.</para></param>
        </member>
        <member name="P:SEIDR.Doc.FileReader.FilePath">
            <summary>
            Full Path to file being read.
            </summary>
        </member>
        <member name="M:SEIDR.Doc.FileReader.#ctor(System.String,System.Char,System.Boolean)">
            <summary>
            Constructor with option to set whether to lock on read
            </summary>
            <param name="path"></param>
            <param name="separator"></param>
            <param name="readlock">If true, lock the file while open.</param>
        </member>
        <member name="M:SEIDR.Doc.FileReader.#ctor(System.String,System.Boolean)">
            <summary>
            QuickReader with a Write lockif the boolean is true.
            </summary>
            <param name="path">Path of file to read</param>
            <param name="WriteLock">If true, prevent the file from being modified by taking the write lock.</param>
        </member>
        <member name="M:SEIDR.Doc.FileReader.#ctor(System.String)">
            <summary>
            Constructor. Default splitter is '\n'.
            </summary>
            <param name="path">File path to read</param>
        </member>
        <member name="M:SEIDR.Doc.FileReader.Finalize">
            <summary>
            Deconstructor.
            </summary>
        </member>
        <member name="M:SEIDR.Doc.FileReader.Read(System.Int32@,System.Boolean@)">
            <summary>
            Reads up to (default) 1000000 characters from the file and returns an array of strings split by the separator. Will remove the final string unless a non full block was read.
            <para>If this method is called after the file finishes reading, an Exception will be thrown.</para>
            </summary>
            <param name="work">Number of characters read from the file. Does not necessarily match the number of characters in the joined string[]</param>
            <param name="moreWork">Whether or not there are more characters in the file to read. Equivalent to checking if work is less than the block size.</param>
            <returns>Split lines from the file.</returns>
        </member>
        <member name="M:SEIDR.Doc.FileReader.Read(System.Boolean@)">
            <summary>
            Reads up to (default) 1000000 characters from the file and returns an array of strings split by the separator. Will remove the final string unless a non full block was read.
            <para>If this method is called after the file finishes reading, an Exception will be thrown.</para>
            </summary>
            <param name="moreWork">True if there is (probably) more content to read from the file. It would also be set to true if the file happened to end filling up a block.</param>
            <returns>Split string of lines containing the read characters. Split default is '\n' but can be changed with one of the constructors.</returns>
        </member>
        <member name="M:SEIDR.Doc.FileReader.Read(System.Int32@)">
            <summary>
            Reads up to (default) 1000000 characters from the file and returns an array of strings split by the separator. Will remove the final string unless a non full block was read.
            <para>If this method is called after the file finishes reading, an Exception will be thrown.</para>
            </summary>
            <param name="work">The number of characters read. There's more to read in the file as long as this is equal to the size of the block(1000000).
            <para>Does not account for characters added or subtracted from removing quotes or holding to keep only full lines in the strings contained in the array</para>
            <para>If the value is less than the QuickReader's block size, there is no more work to do.
            </para>
            </param>
            <returns>Split string of lines from the file.</returns>
        </member>
        <member name="M:SEIDR.Doc.FileReader.GuessDelimiter(System.String)">
            <summary>
            Tries to guess the delimiter of a line string from the following characters: |,\t;:
            </summary>
            <param name="line"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.FileReader.CleanLine(System.String,System.Boolean)">
            <summary>
            Cleans a single line using the method from validate clean.
            </summary>
            <param name="line">Line to clean</param>
            <param name="combineNewlines">If true, all groups of newline characters will be replaced by a single LF</param>
            <returns>Cleaned line</returns>
        </member>
        <member name="M:SEIDR.Doc.FileReader.Dispose">
            <summary>
            Disposes the underlying stream.
            </summary>
        </member>
        <member name="T:SEIDR.FixWidthConverter">
            <summary>
            Class for converting a fixed width file to pipe delimited. Intended use is for FileAnalysis, not for loading.
            </summary>    
        </member>
        <member name="T:SEIDR.FixWidthConverter.DELIMITER">
            <summary>
            valid delimiters to pass to <see cref="M:SEIDR.FixWidthConverter.SetDelimiter(SEIDR.FixWidthConverter.DELIMITER)"/> 
            </summary>
        </member>
        <member name="F:SEIDR.FixWidthConverter.DELIMITER.TAB">
            <summary>
            Tab Delimiter
            </summary>
        </member>
        <member name="F:SEIDR.FixWidthConverter.DELIMITER.COMMA">
            <summary>
            Comma Delimiter
            </summary>
        </member>
        <member name="F:SEIDR.FixWidthConverter.DELIMITER.PIPE">
            <summary>
            Pipe Delimiter (|)
            </summary>
        </member>
        <member name="P:SEIDR.FixWidthConverter.LineEnding">
            <summary>
            The LineEnding that will be used for the output file after running <see cref="M:SEIDR.FixWidthConverter.ConvertFile"/> 
            </summary>
        </member>
        <member name="P:SEIDR.FixWidthConverter.LineEnding_CR">
            <summary>
            Include carriage return in the output lines.
            </summary>
        </member>
        <member name="P:SEIDR.FixWidthConverter.LineEnding_LF">
            <summary>
            Include LF in the output lines.
            </summary>
        </member>
        <member name="P:SEIDR.FixWidthConverter.OutputFilePath">
            <summary>
            Full path to Output File
            </summary>
        </member>
        <member name="F:SEIDR.FixWidthConverter.Derived">
            <summary>
            Regex based Derived columns.
            </summary>
        </member>
        <member name="M:SEIDR.FixWidthConverter.CheckDerivedColumns">
            <summary>
            Loop through derived columns for UI purposes.
            </summary>
            <returns></returns>
        </member>
        <member name="M:SEIDR.FixWidthConverter.Derive(System.String)">
            <summary>
            Check line to see if it can update any of the derived column values
            </summary>
            <param name="line"></param>
        </member>
        <member name="M:SEIDR.FixWidthConverter.InsertDerived(SEIDR.DerivedColumnInfo)">
            <summary>
            Add a derived column info to the dictionary for Comparing
            </summary>
            <param name="dci"></param>
        </member>
        <member name="M:SEIDR.FixWidthConverter.InsertDerived(SEIDR.DerivedColumnInfo[])">
            <summary>
            Adds a set of derived column info to the dictionary for comparing.
            </summary>
            <param name="dci"></param>
        </member>
        <member name="P:SEIDR.FixWidthConverter.Delimiter">
            <summary>
            Delimiter for output file.
            </summary>
        </member>
        <member name="M:SEIDR.FixWidthConverter.SetDelimiter(System.Char)">
            <summary>
            Sets the delimiter after validating that it is a covered value 
            </summary>
            <param name="outDelimiter"></param>
        </member>
        <member name="M:SEIDR.FixWidthConverter.SetDelimiter(SEIDR.FixWidthConverter.DELIMITER)">
            <summary>
            Sets the output delimiter for
            </summary>
            <param name="outDelimiter"></param>
        </member>
        <member name="M:SEIDR.FixWidthConverter.AddDerived(System.String,System.Boolean)">
            <summary>
            Add derived columns and their values to the line. Column name or value is chosen based on header
            </summary>
            <param name="line"></param>
            <param name="header">If true, add column name. If false, add derived column value</param>
            <returns></returns>
        </member>
        <member name="P:SEIDR.FixWidthConverter.filterOut">
            <summary>
            Contains filters for removing lines from the result file if true.
            </summary>
        </member>
        <member name="P:SEIDR.FixWidthConverter.filterIn">
            <summary>
            Contains filters for adding lines to the result file if true.
            </summary>
        </member>
        <member name="P:SEIDR.FixWidthConverter.fieldWidths">
            <summary>
            Contains length of each field.
            </summary>
        </member>
        <member name="M:SEIDR.FixWidthConverter.#ctor(System.String,System.String)">
            <summary>
            Constructor. Takes an input file and desired output file.
            </summary>
            <param name="inputPath"></param>
            <param name="outputPath"></param>
        </member>
        <member name="M:SEIDR.FixWidthConverter.#ctor(System.String)">
            <summary>
            Constructor. Output file will be input file path + an extension dependent on the delimiter.
            </summary>
            <param name="inputPath"></param>
        </member>
        <member name="P:SEIDR.FixWidthConverter.CanCreateOutput">
            <summary>
            Indicates whether or not this instance can be used to create an output file.
            </summary>
        </member>
        <member name="M:SEIDR.FixWidthConverter.#ctor">
            <summary>
            Version just for creating settings
            </summary>
        </member>
        <member name="M:SEIDR.FixWidthConverter.construct(System.String,System.String)">
            <summary>
            Returns a fixedWidthConverter setup based on the setupfile. output will be input + .csv
            </summary>
            <param name="inputFile"></param>
            <param name="SetUpFile"></param>
        </member>
        <member name="M:SEIDR.FixWidthConverter.ToString">
            <summary>
            ToString method. Can be written to a file for use by the static construct method in order to use the same settings on another file.
            </summary>
            <returns></returns>
        </member>
        <member name="F:SEIDR.FixWidthConverter.hasHeader">
            <summary>
            Set to true if the file already contains a header.
            </summary>
        </member>
        <member name="F:SEIDR.FixWidthConverter.NewHeader">
            <summary>
            String to Replacement for existing header. should be pipe delimited.
            </summary>
        </member>
        <member name="M:SEIDR.FixWidthConverter.ConvertFile">
            <summary>
            Create the new delimited file using fieldwidths, filters, and header settings.
            </summary>
        </member>
        <member name="M:SEIDR.FixWidthConverter.ConvertIndexes(System.String)">
            <summary>
            Convert a fixed width line to pipe delimited. Public for use on the header if needed
            </summary>
            <param name="line"></param>
            <returns></returns>
        </member>
        <member name="F:SEIDR.FixWidthConverter.HeaderDifferentIndexes">
            <summary>
            Set to true if the header's indexes do not match the normal records' indexes. May be useful if you want to use a custom header...
            <para>If true, you should call on ConvertIndexes on the header line yourself.</para>
            </summary>
        </member>
        <member name="M:SEIDR.FixWidthConverter.makeSpaces(System.String)">
            <summary>
            Convert to spaces for the conversion filter
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.FixWidthConverter.makeDigits(System.String,System.Boolean)">
            <summary>
            Convert to digit expression for conversion filter
            </summary>
            <param name="input"></param>
            <param name="includeSpace"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.FixWidthConverter.makeLetters(System.String,System.Boolean,System.Boolean)">
            <summary>
            convert to letters for conversion filters
            </summary>
            <param name="input"></param>
            <param name="includeSpace"></param>
            <param name="includeNumeric"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.FixWidthConverter.makeAnything(System.String)">
            <summary>
            convert to anything for conversion filters
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.FixWidthConverter.ConvertIndexes(System.String,System.Collections.Generic.List{System.Int32})">
            <summary>
            Convert a line to pipe delimited. Public for use on header in case its indexes don't match for some reason...
            </summary>
            <param name="line"></param>
            <param name="FieldLength"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.FixWidthConverter.FilterRecords(System.String[],System.Boolean)">
            <summary>
            Filter records using the regex conditions. returns an array of included records.
            </summary>
            <param name="data"></param>
            <param name="hasHeader">If true, will not check the first record for conditions because it's a header.</param>
            <returns></returns>
        </member>
        <member name="T:SEIDR.DerivedColumnInfo">
            <summary>
            For adding extra columns to a file
            </summary>
        </member>
        <member name="F:SEIDR.DerivedColumnInfo.expression">
            <summary>
            Regex for checking against each line.
            </summary>
        </member>
        <member name="F:SEIDR.DerivedColumnInfo.columnName">
            <summary>
            Name to go in the output file
            </summary>
        </member>
        <member name="P:SEIDR.DerivedColumnInfo.maxLength">
            <summary>
            Max Length of a line that passes. Or just the start position for a derived column that goes to the end of the line
            </summary>
        </member>
        <member name="F:SEIDR.DerivedColumnInfo.value">
            <summary>
            Value to place in column
            </summary>
        </member>
        <member name="M:SEIDR.DerivedColumnInfo.#ctor(System.String,System.String,System.Int32,System.Int32)">
            <summary>
            constructor
            </summary>
            <param name="express"></param>
            <param name="name"></param>
            <param name="start"></param>
            <param name="length"></param>
        </member>
        <member name="M:SEIDR.DerivedColumnInfo.Set(System.String)">
            <summary>
            Update value based on passed line and the start/length given when this was created
            </summary>
            <param name="line"></param>
        </member>
        <member name="M:SEIDR.DerivedColumnInfo.FileString">
            <summary>
            ToString for saving to file
            </summary>
            <returns></returns>
        </member>
        <member name="M:SEIDR.DerivedColumnInfo.ToString">
            <summary>
            To String override
            </summary>
            <returns></returns>
        </member>
        <member name="M:SEIDR.DerivedColumnInfo.#ctor(System.String)">
            <summary>
            For constructing form file
            </summary>
            <param name="ToStringValue"></param>
        </member>
        <member name="T:SEIDR.NumExtensions">
            <summary>
            Helpers for decimals.
            </summary>
        </member>
        <member name="M:SEIDR.NumExtensions.Between(System.Int32,System.Int32,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Checks that <paramref name="value"/> is between <paramref name="a"/> and <paramref name="b"/>
            </summary>
            <param name="value"></param>
            <param name="a"></param>
            <param name="b"></param>
            <param name="inclusiveLeft">If true, can return true when <paramref name="a"/> == <paramref name="value"/></param>
            <param name="inclusiveRight">If true, can return true when <paramref name="b"/> == <paramref name="value"/></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.NumExtensions.Between(System.Double,System.Double,System.Double,System.Boolean,System.Boolean)">
            <summary>
            Checks that <paramref name="value"/> is between <paramref name="a"/> and <paramref name="b"/>
            </summary>
            <param name="value"></param>
            <param name="a"></param>
            <param name="b"></param>
            <param name="inclusiveLeft">If true, can return true when <paramref name="a"/> == <paramref name="value"/></param>
            <param name="inclusiveRight">If true, can return true when <paramref name="b"/> == <paramref name="value"/></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.NumExtensions.Between(System.Single,System.Single,System.Single,System.Boolean,System.Boolean)">
            <summary>
            Checks that <paramref name="value"/> is between <paramref name="a"/> and <paramref name="b"/>
            </summary>
            <param name="value"></param>
            <param name="a"></param>
            <param name="b"></param>
            <param name="inclusiveLeft">If true, can return true when <paramref name="a"/> == <paramref name="value"/></param>
            <param name="inclusiveRight">If true, can return true when <paramref name="b"/> == <paramref name="value"/></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.NumExtensions.Between(System.Int64,System.Int64,System.Int64,System.Boolean,System.Boolean)">
            <summary>
            Checks that <paramref name="value"/> is between <paramref name="a"/> and <paramref name="b"/>
            </summary>
            <param name="value"></param>
            <param name="a"></param>
            <param name="b"></param>
            <param name="inclusiveLeft">If true, can return true when <paramref name="a"/> == <paramref name="value"/></param>
            <param name="inclusiveRight">If true, can return true when <paramref name="b"/> == <paramref name="value"/></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.NumExtensions.Between(System.Int16,System.Int16,System.Int16,System.Boolean,System.Boolean)">
            <summary>
            Checks that <paramref name="value"/> is between <paramref name="a"/> and <paramref name="b"/>
            </summary>
            <param name="value"></param>
            <param name="a"></param>
            <param name="b"></param>
            <param name="inclusiveLeft">If true, can return true when <paramref name="a"/> == <paramref name="value"/></param>
            <param name="inclusiveRight">If true, can return true when <paramref name="b"/> == <paramref name="value"/></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.NumExtensions.Between(System.Decimal,System.Decimal,System.Decimal,System.Boolean,System.Boolean)">
            <summary>
            Checks that <paramref name="value"/> is between <paramref name="a"/> and <paramref name="b"/>
            </summary>
            <param name="value"></param>
            <param name="a"></param>
            <param name="b"></param>
            <param name="inclusiveLeft">If true, can return true when <paramref name="a"/> == <paramref name="value"/></param>
            <param name="inclusiveRight">If true, can return true when <paramref name="b"/> == <paramref name="value"/></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.NumExtensions.Between(System.Byte,System.Byte,System.Byte,System.Boolean,System.Boolean)">
            <summary>
            Checks that <paramref name="value"/> is between <paramref name="a"/> and <paramref name="b"/>
            </summary>
            <param name="value"></param>
            <param name="a"></param>
            <param name="b"></param>
            <param name="inclusiveLeft">If true, can return true when <paramref name="a"/> == <paramref name="value"/></param>
            <param name="inclusiveRight">If true, can return true when <paramref name="b"/> == <paramref name="value"/></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.NumExtensions.Between(System.Byte,System.Int32,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Checks that <paramref name="value"/> is between <paramref name="a"/> and <paramref name="b"/>
            </summary>
            <param name="value"></param>
            <param name="a"></param>
            <param name="b"></param>
            <param name="inclusiveLeft">If true, can return true when <paramref name="a"/> == <paramref name="value"/></param>
            <param name="inclusiveRight">If true, can return true when <paramref name="b"/> == <paramref name="value"/></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.NumExtensions.Between(System.Double,System.Int32,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Checks that <paramref name="value"/> is between <paramref name="a"/> and <paramref name="b"/>
            </summary>
            <param name="value"></param>
            <param name="a"></param>
            <param name="b"></param>
            <param name="inclusiveLeft">If true, can return true when <paramref name="a"/> == <paramref name="value"/></param>
            <param name="inclusiveRight">If true, can return true when <paramref name="b"/> == <paramref name="value"/></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.NumExtensions.Between``2(``0,``1,``1,System.Boolean,System.Boolean)">
            <summary>
            Checks that <paramref name="value"/> is between <paramref name="a"/> and <paramref name="b"/>
            </summary>
            <param name="value"></param>
            <param name="a"></param>
            <param name="b"></param>
            <param name="inclusiveLeft">If true, can return true when <paramref name="a"/> == <paramref name="value"/></param>
            <param name="inclusiveRight">If true, can return true when <paramref name="b"/> == <paramref name="value"/></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.NumExtensions.Average(System.Double,System.Int32,System.Double,System.Int32)">
            <summary>
            Combines two averages
            </summary>
            <param name="a"></param>
            <param name="countA"></param>
            <param name="b"></param>
            <param name="countB"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.NumExtensions.Average(System.Double,System.Double,System.Int32)">
            <summary>
            Returns the average of a, together with b based on the count of numbers used to get average b, added to the average.
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <param name="CountB"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.NumExtensions.Average(System.Double,System.Double)">
            <summary>
            Returns the average of a and b.
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.NumExtensions.Average(System.Double,System.Int64,System.Double,System.Int64)">
            <summary>
            Combines two averages
            </summary>
            <param name="a"></param>
            <param name="countA"></param>
            <param name="b"></param>
            <param name="countB"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.NumExtensions.Average(System.Double,System.Double,System.Int64)">
            <summary>
            Returns the average of a, together with b based on the count of numbers used to get average b, added to the average.
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <param name="CountB"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.NumExtensions.Average(System.Decimal,System.Int32,System.Decimal,System.Int32)">
            <summary>
            Combines two averages
            </summary>
            <param name="a"></param>
            <param name="countA"></param>
            <param name="b"></param>
            <param name="countB"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.NumExtensions.Average(System.Decimal,System.Decimal,System.Int32)">
            <summary>
            Returns the average of a, together with b based on the count of numbers used to get average b, added to the average.
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <param name="CountB"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.NumExtensions.Average(System.Decimal,System.Decimal)">
            <summary>
            Returns the average of a and b.
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.NumExtensions.Average(System.Decimal,System.Int64,System.Decimal,System.Int64)">
            <summary>
            Combines two averages
            </summary>
            <param name="a"></param>
            <param name="countA"></param>
            <param name="b"></param>
            <param name="countB"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.NumExtensions.Average(System.Decimal,System.Decimal,System.Int64)">
            <summary>
            Returns the average of a, together with b based on the count of numbers used to get average b, added to the average.
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <param name="CountB"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.NumExtensions.Average(System.Decimal,System.Int64,System.Decimal)">
            <summary>
            Returns the average of a, based on the count of numbers used to get average a, together with b added to the average.
            </summary>
            <param name="a"></param>
            <param name="countA"></param>
            <param name="b">Single value to add longo computation of the average.</param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.NumExtensions.Average(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Average the two provided averages.
            </summary>
            <param name="a"></param>
            <param name="countA"></param>
            <param name="b"></param>
            <param name="countB"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.NumExtensions.Average(System.Int32,System.Int32)">
            <summary>
            Averages the two integers
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.NumExtensions.Average(System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Average the two provided averages.
            </summary>
            <param name="a"></param>
            <param name="countA"></param>
            <param name="b"></param>
            <param name="countB"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.NumExtensions.Average(System.Int64,System.Int64)">
            <summary>
            Averages the two Int64s
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="T:SEIDR.LikeExpressions">
            <summary>
            Used for comparing strings using a sql WildCard '%' and '_'. Also for:
            <para>* Finding the first or last occurance of such a string in an array of strings</para>
            <para>* Finding the first substring occurrence of a condition within a single string. (Other methods match condition against ENTIRE string)</para>
            </summary>
            <remarks>For Reference, the Original Intended use is to use this to find column names in the header of a file that match a pattern like 'ac%t' and use that index in a Processor in order to make a generic report generator for a given type of file.</remarks>
        </member>
        <member name="F:SEIDR.LikeExpressions.AllowRegex">
            <summary>
            If true, will not escape regex special characters, allowing you to take advantage of regex in your calling method.
            </summary>
        </member>
        <member name="M:SEIDR.LikeExpressions.SearchStringWithCase(System.String,System.String)">
            <summary>
            Checks for the substring within the full line that matches the condition of a like Statement. Requires matching case
            </summary>
            <param name="fullLine">Full string to check</param>
            <param name="condition">LIKE Condition</param>        
            <returns>First occurrence of a substring of fullLine that matches condition, or null.</returns>
        </member>
        <member name="M:SEIDR.LikeExpressions.SearchString(System.String,System.String)">
            <summary>
            Checks for the substring within the full line that matches the condition of a like Statement. Ignores case.
            </summary>
            <param name="fullLine">Full string to check</param>
            <param name="condition">LIKE Condition</param>        
            <returns>First occurrence of a substring of fullLine that matches condition, or null.</returns>
        </member>
        <member name="M:SEIDR.LikeExpressions.Compare(System.String,System.String)">
            <summary>
            Checks if a string fits a comparison check using the SQL WildCards '%' and '_'. Case is ignored.
            </summary>
            <param name="line">Line to check.</param>
            <param name="comparison">What would go in the LIKE expression</param>
            <returns>True if it passes the comparison, false otherwise</returns>
        </member>
        <member name="M:SEIDR.LikeExpressions.CompareWithCase(System.String,System.String)">
            <summary>
            Checks if line is LIKE comparison, case sensitive.
            </summary>
            <param name="line">String we want to find a match for comparison in</param>
            <param name="comparison">Value we want to find inside line</param>
            <returns>True if line is LIKE comparison,  false otherwise</returns>
        </member>
        <member name="M:SEIDR.LikeExpressions.Compare(System.String[],System.String)">
            <summary>
            Goes through each string in lines to find the first string that matches comparison.
            </summary>
            <param name="lines">Array of Lines to check for a match with comparison</param>
            <param name="comparison">What would go in a LIKE statement</param>
            <returns>Index of First string in lines that matches comparison. Returns -1 if no match is found.</returns>
        </member>
        <member name="M:SEIDR.LikeExpressions.ReverseCompare(System.String[],System.String)">
            <summary>
            Performs Compare in the opposite order on the line.
            </summary>
            <param name="lines">Array of Lines to check for a match with comparison</param>
            <param name="comparison">What would go in a LIKE statement</param>
            <returns>Index of Last string in lines that matches comparison. Returns -1 if no match is found.</returns>
        </member>
        <member name="M:SEIDR.LikeExpressions.ReverseCompare(System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
            Performs compare in the opposite order, returns the first string from the Enumerable that matches
            </summary>
            <param name="lines"></param>
            <param name="Comparison"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.LikeExpressions.GetMatches(System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
            Searches an array of strings to find all strings that match comparison
            </summary>
            <param name="lines">Array of strings to search</param>
            <param name="comparison">Comparison that can include the % wildcard</param>
            <returns>Array containing all strings that match comparison</returns>
        </member>
        <member name="T:SEIDR.Mailer">
            <summary>
            Wrapper for sending mail messages
            </summary>
        </member>
        <member name="P:SEIDR.Mailer.SendTo">
            <summary>
            Default Recipients of email
            </summary>
        </member>
        <member name="P:SEIDR.Mailer.SMTPServer">
            <summary>
            The SMTP Server that your mailer connects to. E.g. gmail.com
            </summary>
        </member>
        <member name="P:SEIDR.Mailer.Domain">
            <summary>
            Domain, e.g. gmail, gmail.com, @gmail.com
            <para>Stored without the '@'</para>
            </summary>
        </member>
        <member name="F:SEIDR.Mailer.Sender">
            <summary>
            Name of the sender. Will have Domain added when sending if there is no '@'
            </summary>
        </member>
        <member name="M:SEIDR.Mailer.#ctor(System.String,System.String,System.String,System.Int32)">
            <summary>
            
            </summary>
            <param name="mailSender">Address to use for the sender</param>
            <param name="SendTo"></param>
            <param name="Server"></param>
            <param name="Port"></param>
        </member>
        <member name="M:SEIDR.Mailer.#ctor(System.Net.Mail.MailAddress,System.String,System.String,System.Int32)">
            <summary>
            
            </summary>
            <param name="mailSender">MailAddress for the sender to use</param>
            <param name="SendTo">Default Recipient of emails</param>
            <param name="Server"></param>
            <param name="Port"></param>
        </member>
        <member name="M:SEIDR.Mailer.SendMail(System.Net.Mail.MailMessage)">
            <summary>
            Sends the mail message using the Smtp configurations for the SMTP server
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:SEIDR.Mailer.SendMail(System.String,System.String,System.Boolean,System.String,System.Collections.Generic.IEnumerable{System.Net.Mail.MailAddress},System.String,System.String,System.String,System.Collections.Generic.ICollection{System.Net.Mail.Attachment},System.Net.Mail.MailPriority)">
            <summary>
            Sends a mail from the specified sender
            <para>Will send to the mail list specified by SendTo, unless MultiRecipient is specified.</para>
            <para>Note: If sender or SMTP Server is null, will return immediately.</para>
            </summary>
            <param name="subject">Email's subject line</param>
            <param name="MailBody">Content making up the email's body.</param>
            <param name="isHtml">If true, sends as an HTML mail</param>
            <param name="RecipientList">Allow for overriding the SendToList with a comma delimited list of addresses</param>
            <param name="MultiRecipient">Allow for overriding the SendToList without overriding for overall</param>        
            <param name="CCList">List of mail addresses to CC</param>
            <param name="BCCList">List of mail addresses to BCC</param>
            <param name="replyToList">List of mail address for recipients to reply to, if supported by SmtpServer. (In addition to Sender)</param>
            <param name="attachmentList">Optional List of attachments to include when sending email</param>
            <param name="mailPriority">Message priority</param>
        </member>
        <member name="M:SEIDR.META.NestedTokenNode.LoopNodes">
            <summary>
            Depth first loop through Children
            </summary>
            <returns></returns>
        </member>
        <member name="M:SEIDR.META.ObjectExtensions.ToTable(System.Collections.Generic.IEnumerable{System.Object},System.String,System.String[])">
            <summary>
            Converts the IEnumerable of objects to a dataTable with the specified name.
            </summary>
            <param name="obj"></param>
            <param name="Name"></param>
            <param name="propertyList"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.META.ObjectExtensions.CreateInstance``1(System.Data.DataRow)">
            <summary>
            Converts the datarow into an instance of type RT. Requires a parameterless constructor
            </summary>
            <typeparam name="RT"></typeparam>
            <param name="source"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.META.ObjectExtensions.CreateDataRow``1(``0)">
            <summary>
            Creates a datarow from the given record
            </summary>
            <typeparam name="RT"></typeparam>
            <param name="Record"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.META.ObjectExtensions.CreateDataRowView``1(``0)">
            <summary>
            Creates a DataRowView from the given record.
            </summary>
            <typeparam name="RT"></typeparam>
            <param name="Record"></param>
            <returns></returns>
        </member>
        <member name="T:SEIDR.META.Tokenizer">
            <summary>
            Separates records into tokens. 
            <para>Note(Special Tokens): colon, commas, semicolon, period, brackets, parenthesis are considered their own tokens by default.
            </para>
            <para>Note that this is an IEnumerable so you can either use the peek/GetNext, or you can simply use the tokenizer in a foreach loop.</para>
            </summary>
        </member>
        <member name="M:SEIDR.META.Tokenizer.MergeUntil(System.String@,System.String,System.Boolean)">
            <summary>
            Merges the following tokens until reaching a 'tokenUntil' token.
            </summary>
            <param name="combineString"></param>
            <param name="tokenUntil"></param>
            <param name="appendToken">Adds the combine until token to the CombineString</param>
        </member>
        <member name="M:SEIDR.META.Tokenizer.#ctor(System.String)">
            <summary>
            Creates an instance ofa Tokenizer that separates the string into tokens based on spaces. Also separates special characters into their own token
            </summary>
            <param name="content"></param>
        </member>
        <member name="M:SEIDR.META.Tokenizer.#ctor(System.String,System.Boolean,System.Char[])">
            <summary>
            Creates an instance of a Tokenizer but overrides the list of default characters to treat as tokens.
            </summary>
            <param name="content"></param>
            <param name="includeDefaultSpecialTokens">If true, will include the default special tokens (,.[];</param>
            <param name="specialTokenList"></param>
        </member>
        <member name="M:SEIDR.META.Tokenizer.HandleDefaultSpecialTokens(System.String)">
            <summary>
            Surrounds default special token characters with spaces so that they are separated into their own spot when splitting by space
            </summary>
            <param name="temp"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.META.Tokenizer.GetTokens(System.String)">
            <summary>
            Takes the passed string and extracts a list of tokens from it
            </summary>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.META.Tokenizer.GetTokens(System.String,System.Char[],System.Boolean)">
            <summary>
            Takes teh passed content string and extracts a lsit of tokens from it.
            <para>Also treats the passed list of characters as special tokens.</para>
            </summary>
            <param name="s"></param>
            <param name="specialTokens"></param>
            <param name="includeDefaultSpecialTokens">If true, will continue to treat the default special tokens as special tokens (see class description)       
            </param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.META.Tokenizer.GetNextToken">
            <summary>
            Gets the next token
            </summary>
            <returns></returns>
        </member>
        <member name="P:SEIDR.META.Tokenizer.HasMoreTokens">
            <summary>
            Check if there are more tokens to look at
            </summary>
        </member>
        <member name="P:SEIDR.OperationServiceModels.Batch.BatchTypeCode">
            <summary>
            For some thread control stuff. And file limiting, etc. 
            <para>BatchType Table also contains a description for the type of files expected to be used
            </para>
            </summary>
        </member>
        <member name="P:SEIDR.OperationServiceModels.Batch.ThreadID">
            <summary>
            Depend on Operation + BatchType + Profile. If Operation/BatchType/Profile do not set, will be picked by whatever Thread has open spots in its queue and updated
            </summary>
        </member>
        <member name="M:SEIDR.OperationServiceModels.Batch.SetMissingThreadID(System.Byte)">
            <summary>
            Sets the ThreadID on the batch if it's missing/null
            </summary>
            <param name="ID"></param>
        </member>
        <member name="P:SEIDR.OperationServiceModels.Batch.Step">
            <summary>
            The current step number - determines the operation + parameters.
            </summary>
        </member>
        <member name="P:SEIDR.OperationServiceModels.Batch.CurrentStep">
            <summary>
            Current step number stored in raw table. Returns <see cref="P:SEIDR.OperationServiceModels.Batch.Step"/>, which is used by view
            </summary>
        </member>
        <member name="P:SEIDR.OperationServiceModels.Batch.AttemptCount">
            <summary>
            Number of attempts on the operation/step. Will be incremented each time work starts.
            <para>Begins at 1 for the first attempt.</para>
            <para>Resets when the status/Current step change</para>
            </summary>
        </member>
        <member name="P:SEIDR.OperationServiceModels.Batch.Version">
            <summary>
            Operation's Version.
            </summary>
        </member>
        <member name="M:SEIDR.OperationServiceModels.Batch.Register(SEIDR.DataBase.DatabaseManager,System.Int32,System.Collections.Generic.List{SEIDR.OperationServiceModels.Batch_File},System.Collections.Generic.IEnumerable{SEIDR.OperationServiceModels.Batch_File}@)">
            <summary>
            Register the list of Batch_File records with the profile. Returns the first batch. 
            <para>Consider passing to an Operator thread if the corresponding one is free. 
            </para><para>(Should include a bool on the worker indicating it's free, also locking. </para>
            <para>Be able to set the batch so that it starts doing work instead of querying database for work.)</para>
            </summary>
            <param name="mgr"></param>
            <param name="BatchProfileID"></param>
            <param name="fileList">List of Batch_Files to be created by a File Watcher</param>
            <param name="rejected">Files that were not added to any batches as a result of hash or path matching originals of Batch_File's already in use</param>
            <returns>First batch registered with the files, or null</returns>
        </member>
        <member name="M:SEIDR.OperationServiceModels.Batch.AddFile(System.String,System.Nullable{System.DateTime})">
            <summary>
            If the file exists and is not already in the batch, add it to the batch.
            </summary>
            <param name="FilePath"></param>
            <param name="FileDate">Specifies file date - file creation time will be used if not provided</param>
        </member>
        <member name="M:SEIDR.OperationServiceModels.Batch.AddFile(System.IO.FileInfo,System.Nullable{System.DateTime})">
            <summary>
            If the file exists and the path is not in the batch yet, add it to the batch.
            </summary>
            <param name="FilePath"></param>
            <param name="FileDate">Specifies file date - file creation time will be used if not provided</param>
        </member>
        <member name="M:SEIDR.OperationServiceModels.Batch.DeleteFile(System.String)">
            <summary>
            Removes the file - will be applied when the batch status is updated.
            </summary>
            <param name="FilePath"></param>
        </member>
        <member name="P:SEIDR.OperationServiceModels.BatchProfile.ScheduleID">
            <summary>
            TODO: set up Schedule object... Use would be in the DB, though, just calling a proc to create Batches as needed
            </summary>
        </member>
        <member name="T:SEIDR.OperationServiceModels.BATCHSTATUS">
            <summary>
            Descriptions of the base BatchStatuses. If an operation tries to pass an invalid status, then a base status will be chosen depending on
            whether it was expected to be success or failure.
            <para>E.g., trying to pass a failure status after returning true from operation will result in either 'S' or 'C'</para>
            </summary>
        </member>
        <member name="F:SEIDR.OperationServiceModels.BATCHSTATUS.WORKING">
            <summary>
            Status set when the batch has been picked up for adding to the work queue.
            </summary>
        </member>
        <member name="F:SEIDR.OperationServiceModels.BATCHSTATUS.COMPLETE">
            <summary>
            Status set when the Batch is done with all steps
            </summary>
        </member>
        <member name="F:SEIDR.OperationServiceModels.BATCHSTATUS.COMPLETE_INVAlID">
            <summary>
            Status set when the batch is done with all steps but finished with either an error status or entries in the Error Log
            </summary>
        </member>
        <member name="F:SEIDR.OperationServiceModels.BATCHSTATUS.REGISTERED">
            <summary>
            Status Set when Batch is created by a schedule
            </summary>
        </member>
        <member name="F:SEIDR.OperationServiceModels.BATCHSTATUS.REGISTERED_FILES">
            <summary>
            Status set when batch has been created by registering files
            </summary>
        </member>
        <member name="F:SEIDR.OperationServiceModels.BATCHSTATUS.STOP_REQUESTED">
            <summary>
            Status set when a user wants to stop a Batch. 
            <para>If the step completes anyway, will go to either 'X' or 'CE', depending on the presence of additional steps
            </para>
            </summary>
        </member>
        <member name="F:SEIDR.OperationServiceModels.BATCHSTATUS.STOP_ACKNOWLEDGED">
            <summary>
            Status set when the Operation Stopper has found the batch
            </summary>
        </member>
        <member name="F:SEIDR.OperationServiceModels.BATCHSTATUS.STOP_FULFILLED">
            <summary>
            Status set when the worker has been force-stopped.
            </summary>
        </member>
        <member name="F:SEIDR.OperationServiceModels.BATCHSTATUS.INVALID_SEQUENCE">
            <summary>
            Status set when the Batch is not in sequence
            </summary>
        </member>
        <member name="F:SEIDR.OperationServiceModels.BATCHSTATUS.WORKING_ERROR">
            <summary>
            Status set when the batch execution failed.
            </summary>
        </member>
        <member name="F:SEIDR.OperationServiceModels.BATCHSTATUS.INVALID_STOP">
            <summary>
            Status to be set when the Parameters are invalid or the batch is otherwise not valid for use with an operation.        
            </summary>
        </member>
        <member name="F:SEIDR.OperationServiceModels.BATCHSTATUS.STEP_SUCCESS">
            <summary>
            Single step has been completed successfully
            </summary>
        </member>
        <member name="F:SEIDR.OperationServiceModels.BATCHSTATUS.PARTIAL_SUCCESS">
            <summary>
            Single step has been partially completed, but can still move on to the next operation without finishing completely
            </summary>
        </member>
        <member name="F:SEIDR.OperationServiceModels.BATCHSTATUS.SKIP_STEP">
            <summary>
            Step should be skipped without doing work. E.g., an operation should only be done in exceptional cases
            </summary>
        </member>
        <member name="P:SEIDR.OperationServiceModels.Batch_File.FileName">
            <summary>
            Just the fileName of the Batch_File, rather than full path
            </summary>
        </member>
        <member name="P:SEIDR.OperationServiceModels.Batch_File.FilePath">
            <summary>
            Full path of file.
            </summary>
        </member>
        <member name="P:SEIDR.OperationServiceModels.Batch_File.Exists">
            <summary>
            Gets whether or not a file exists at the current FilePath specified
            </summary>
        </member>
        <member name="P:SEIDR.OperationServiceModels.IOperatorManager.PauseEvent">
            <summary>
            Call PauseEvent.WaitOne() to prevent doing work when service is supposed to be paused.
            </summary>
        </member>
        <member name="P:SEIDR.OperationServiceModels.IOperatorManager.BatchSize">
            <summary>
            Max number of batches to select at a time
            </summary>
        </member>
        <member name="P:SEIDR.OperationServiceModels.IOperatorManager.QueueLimitMargin">
            <summary>
            Extra space for WorkQueue - Batch/Work queue limit determined by BatchSize + Margin
            </summary>
        </member>
        <member name="M:SEIDR.OperationServiceModels.Operator.AddBatches(System.Collections.Generic.IEnumerable{SEIDR.OperationServiceModels.Batch})">
            <summary>
            Add batches to a list - to be used by cancellation and/or Executor Operators. Queue may be able to use profile off of it?
            </summary>
            <param name="batchList"></param>
        </member>
        <member name="M:SEIDR.OperationServiceModels.iOperation.Execute(SEIDR.OperationServiceModels.Batch,System.Data.DataSet,System.String@)">
            <summary>
            Executes the Operation.
            </summary>
            <param name="b">Batch to execute. Contains a list of file objects</param>
            <param name="parameters">Results of calling the procedure from meta data. May be null.</param>
            <param name="BatchStatus">Attempt to Override result status. Will be validated.</param>
            <returns>True if completed successfully, else false</returns>
        </member>
        <member name="M:SEIDR.OperationServiceModels.iOperation.GetResultNotification(System.Boolean,System.String)">
            <summary>
            Allow for a specialized status message for notification e-mail. Ok to return null
            </summary>
            <param name="ExecuteResult"></param>
            <param name="BatchStatus"></param>
            <returns></returns>
        </member>
        <member name="P:SEIDR.OperationServiceModels.iOperationMetaData.Operation">
            <summary>
            Name of your operation
            </summary>
        </member>
        <member name="P:SEIDR.OperationServiceModels.iOperationMetaData.OperationSchema">
            <summary>
            A namespace for your operation to prvent of overlap. Should not be null, but defaults to 'SEIDR'.
            <para>If parameter select does not include a schema, this will be used for the Schema.</para>
            </summary>
        </member>
        <member name="P:SEIDR.OperationServiceModels.iOperationMetaData.Description">
            <summary>
            Description of operation's purpose. 
            </summary>
        </member>
        <member name="P:SEIDR.OperationServiceModels.iOperationMetaData.Version">
            <summary>
            Numeric identifier - allow updating the operation while keeping a legacy version intact. Version defaults to 1
            </summary>
        </member>
        <member name="P:SEIDR.OperationServiceModels.iOperationMetaData.ThreadID">
            <summary>
            For forcing the Operator service to pass to a specific thread. 
            <para>Default is to use null - set thread based on batch type or profile</para>
            <para>NOTE: If your operation is not thread safe/uses global variables for state, set this to a value between 1 and 15</para>
            <para>If the threadID is zero or too high for the set up, then the operation will be ignored.</para>
            <para>Higher than 4 is better to set on batch types/profiles, rather than on the operation, though</para>
            </summary>
        </member>
        <member name="P:SEIDR.OperationServiceModels.iOperationMetaData.ParameterSelect">
            <summary>
            Procedure to be called by Operator service - the datarow will be passed on along with the batch.
            <para>Should take a @Profile_OperationID (int or bigger) as the primary parameter</para>
            <para>BatchID will also be passed if available as a parameter</para>
            <para>Will be ignored if null or white space</para>
            </summary>
        </member>
        <member name="P:SEIDR.OperationServiceModels.OperationModel.OperationSchema">
            <summary>
            Set by Service from MetaData.
            </summary>
        </member>
        <member name="P:SEIDR.OperationServiceModels.OperationModel.Operation">
            <summary>
            Set by Service from MetaData.
            </summary>
        </member>
        <member name="P:SEIDR.OperationServiceModels.OperationModel.Version">
            <summary>
            Set by Service from MetaData
            </summary>
        </member>
        <member name="P:SEIDR.OperationServiceModels.OperationModel.ThreadID">
            <summary>
            For forcing an operation to use a specific thread. 
            </summary>
        </member>
        <member name="T:SEIDR.Serialization.UBJsonDocument">
            <summary>
            UBJsonObject for containing other UBJsonObjects. <para>
            Primary target for serializing and deserializing...</para>
            </summary>
        </member>
        <member name="T:SEIDR.ThreadManaging.Lock">
            <summary>
            LockManager helper enum.
            </summary>
        </member>
        <member name="F:SEIDR.ThreadManaging.Lock.NoLock">
            <summary>
            Mostly the same effect as unlocked. Differentiated for intent.
            <para>
            NoLock is for accepting that objects may be in an incomplete state.
            </para>
            </summary>
        </member>
        <member name="F:SEIDR.ThreadManaging.Lock.Unlocked">
            <summary>
            Default lock value - No lock acquired
            </summary>
        </member>
        <member name="F:SEIDR.ThreadManaging.Lock.Shared">
            <summary>
            Shared allows many threads to look at the same object without having to worry about it being updated.
            </summary>
        </member>
        <member name="F:SEIDR.ThreadManaging.Lock.Shared_Exclusive_Intent">
            <summary>
            Contribute to shareCount, but obtain exclusive intent
            </summary>        
        </member>
        <member name="F:SEIDR.ThreadManaging.Lock.Exclusive_Intent">
            <summary>
            Exclusive intent will eventually be the same as an exclusive lock but will wait longer for any share locks to finish
            </summary>
        </member>
        <member name="F:SEIDR.ThreadManaging.Lock.Exclusive">
            <summary>
            Exclusive locks are for writing/updating the values of an object
            <para>
            Will wait until all share level locks are released before actually obtaining the lock
            </para>
            </summary>
        </member>
        <member name="M:SEIDR.ThreadManaging.LockHelper`1.CheckTarget(System.String)">
            <summary>
            Creates a simple alias that should be unique to the type and alias combination. Used for lock targets
            </summary>
            <param name="alias"></param>
            <returns></returns>
        </member>
        <member name="T:SEIDR.ThreadManaging.LockHelper">
            <summary>
            Helper for using <see cref="T:SEIDR.ThreadManaging.LockManager"/> class
            </summary>
        </member>
        <member name="P:SEIDR.ThreadManaging.LockHelper.Target">
            <summary>
            Target of the underlying LockManager
            </summary>
        </member>
        <member name="M:SEIDR.ThreadManaging.LockHelper.#ctor(SEIDR.ThreadManaging.LockManager,SEIDR.ThreadManaging.Lock)">
            <summary>        
            Helper for using <see cref="T:SEIDR.ThreadManaging.LockManager"/> class
            </summary>
            <param name="manager">Manager whose lock level is managed. Should be unlocked when creating the helper.</param>
            <param name="lockLevel">Target lock level for the helper to acquire.</param>
        </member>
        <member name="M:SEIDR.ThreadManaging.LockHelper.#ctor(SEIDR.ThreadManaging.Lock,SEIDR.ThreadManaging.LockManager)">
            <summary>        
            Helper for using <see cref="T:SEIDR.ThreadManaging.LockManager"/> class
            </summary>
            <param name="manager">Manager whose lock level is managed. Should be unlocked when creating the helper.</param>
            <param name="lockLevel">Target lock level for the helper to acquire.</param>
        </member>
        <member name="M:SEIDR.ThreadManaging.LockHelper.#ctor(SEIDR.ThreadManaging.Lock,System.String,System.Int32,System.Int32)">
            <summary>
            Helper for using <see cref="T:SEIDR.ThreadManaging.LockManager"/> class
            </summary>
            <param name="lockLevel"></param>
            <param name="target"></param>
            <param name="ExclusiveTimeout"></param>
            <param name="ExclusiveIntentTimeout"></param>
        </member>
        <member name="P:SEIDR.ThreadManaging.LockHelper.IsExclusiveSynched">
            <summary>
            Check if the lock level is current <see cref="F:SEIDR.ThreadManaging.Lock.Exclusive"/>, and if that exclusive has been acquired on this thread.
            </summary>
        </member>
        <member name="M:SEIDR.ThreadManaging.LockHelper.Wait(System.Int32)">
            <summary>
            Waits up to <paramref name="timeout"/> milliseconds to acquire and release a lock. 
            <para>Returns false if timeout was reached.</para>
            </summary>
            <param name="timeout"></param>
            <returns>True if timeout was not used.</returns>
        </member>
        <member name="M:SEIDR.ThreadManaging.LockHelper.Transition(SEIDR.ThreadManaging.Lock)">
            <summary>
            Attempts to transition the lock to another lock level. Returns true if the lock is at the target level at the end of the call.
            <para>Note: If there's no timeout, this will always either return true or throw an exception.</para>
            </summary>
            <param name="transitionTarget"></param>
            <returns></returns>
        </member>
        <member name="P:SEIDR.ThreadManaging.LockHelper.ExlusiveLockTimeout">
            <summary>
            Sets approximate timeout for acquiring an exclusive lock, in seconds.
            </summary>
        </member>
        <member name="P:SEIDR.ThreadManaging.LockHelper.ExclusiveIntentAcquisitionTimeout">
            <summary>
            Sets deadline for acquiring exclusive intent, in seconds.
            </summary>
        </member>
        <member name="M:SEIDR.ThreadManaging.LockHelper.Release">
            <summary>
            Attempts to release any held lock.
            </summary>
        </member>
        <member name="P:SEIDR.ThreadManaging.LockHelper.LevelLevel">
            <summary>
            Gets the lock level of the underlying LockManager
            </summary>
        </member>
        <member name="T:SEIDR.ThreadManaging.LockManager">
            <summary>
            Creates an object for managing different levels of locking.
            <para>
            This is only useful for multi threading and each thread really needs to have its own lock manager(s). 
            </para>
            <para>Instances should NOT be created as static variables or shared across threads.</para>
            </summary>
        </member>
        <member name="F:SEIDR.ThreadManaging.LockManager.ShareBoundary">
            <summary>
            A lock below this value is considered 'Share' 
            <para>
            A lock at or above the value is considered exclusive
            </para>
            </summary>
        </member>
        <member name="F:SEIDR.ThreadManaging.LockManager.LockBoundary">
            <summary>
            A lock below this value is considered 'unlocked' and should mainly be used for consistency or if the lock might be changed.
            <para>
            E.g. if the lock is in a variable, and the level of locking depends on other factors.
            </para>
            </summary>
        </member>
        <member name="F:SEIDR.ThreadManaging.LockManager.DefaultTarget">
            <summary>
            The identifier for the default lock manager target
            </summary>
        </member>
        <member name="P:SEIDR.ThreadManaging.LockManager.HasLock">
            <summary>
            Check if this LockManager is holding any lock 
            </summary>
        </member>
        <member name="P:SEIDR.ThreadManaging.LockManager.LockManagementID">
            <summary>
            Identifier for Lock Management
            </summary>
        </member>
        <member name="P:SEIDR.ThreadManaging.LockManager.LockLevel">
            <summary>
            Gets the value of this LockManager's lock.
            <para>
            If setting, will also try to acquire the lock, unless the new value is unlocked. 
            </para><para>
            If the new value is unlocked, nothing will be done. (Call Release to unlock)
            </para><remarks>
            Setting the value will also do nothing if the LockManageralready holds a lock.
            </remarks>
            </summary>
        </member>
        <member name="P:SEIDR.ThreadManaging.LockManager.ExclusiveLockTimeout">
            <summary>
            Timeout for acquiring an exclusive lock
            </summary>
        </member>
        <member name="P:SEIDR.ThreadManaging.LockManager.ExclusiveIntentAcquisitionTimeout">
            <summary>
            Sets an approximate deadline for acquiring ExclusiveIntent.
            </summary>
        </member>
        <member name="P:SEIDR.ThreadManaging.LockManager.Target">
            <summary>
            Readonly lock target.
            </summary>
        </member>
        <member name="M:SEIDR.ThreadManaging.LockManager.#ctor(System.String)">
            <summary>
            Constructor. Note: This does  not overlap with locking by the <see cref="!:TimedLockManager"/>
            <para>Used for sharing or getting exclusive locks on sections based on other sections using the same target.</para>
            </summary>
            <param name="TARGET">Case insensitive</param>        
        </member>
        <member name="M:SEIDR.ThreadManaging.LockManager.Release">
            <summary>
            Release your lock. Useful even with nolock in the event that you MIGHT need to change to using a lock later on.
            <para> 
            Also useful even with no lock if you're using a variable to decide the lock level based on other factors
            </para>
            <remarks>
            Will throw an exception if you try to release an already unlocked LockManager.
            </remarks>
            </summary>
        </member>
        <member name="M:SEIDR.ThreadManaging.LockManager.Wait">
            <summary>
            Block until no other threads are trying to acquire locks.
            </summary>
        </member>
        <member name="M:SEIDR.ThreadManaging.LockManager.CheckExclusiveSynched">
            <summary>
            Checks if the LockManger has an exclusive lock on this thread.
            </summary>
            <returns></returns>
        </member>
        <member name="M:SEIDR.ThreadManaging.LockManager.Wait(System.Int32)">
            <summary>
            Block until no other threads are trying to acquire locks.
            </summary>
            <param name="timeout"></param>
            <returns>True if this method returns without reaching the timeout.</returns>
        </member>
        <member name="M:SEIDR.ThreadManaging.LockManager.Wait(System.String,System.Int32)">
            <summary>
            Block until no other threads are trying to acquire a lock on the target.
            </summary>
            <param name="target"></param>
            <param name="timeout">Timeout to wait. If less than or equal to 0, will be ignored.</param>
            <returns>False if the timeout is reached, or if the target is not used by the LockManager functionality.</returns>
        </member>
        <member name="F:SEIDR.ThreadManaging.LockManager.EXCLUSIVE_INTENT_EXPIRATION_SECONDS">
            <summary>
            Maximum number of seconds that exclusive intent can be maintained without grabbing the actual exclusive lock.
            <para>(5 minutes)</para>
            </summary>
        </member>
        <member name="M:SEIDR.ThreadManaging.LockManager.TransitionLock(SEIDR.ThreadManaging.Lock)">
            <summary>
            Determines whether the current lock needs to be released before calling <see cref="M:SEIDR.ThreadManaging.LockManager.Acquire(SEIDR.ThreadManaging.Lock,System.Boolean,System.Boolean)"/> in safe mode.
            </summary>
            <param name="level">Lock level to be transitioned to.</param>
            <returns>Result of <see cref="M:SEIDR.ThreadManaging.LockManager.Acquire(SEIDR.ThreadManaging.Lock,System.Boolean,System.Boolean)"/>, or true if the Lock is already at the desired level</returns>
        </member>
        <member name="M:SEIDR.ThreadManaging.LockManager.GetExclusiveIntent(SEIDR.ThreadManaging.Lock,System.Object,System.Object,System.Int32,System.Boolean)">
            <summary>
            Mark exclusive intent in concurrentDictionary.
            </summary>
            <param name="level"></param>
            <param name="target"></param>
            <param name="intentTarget"></param>
            <param name="MONITOR_WAIT_TIMEOUT"></param>
            <param name="timeoutSafe"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.ThreadManaging.LockManager.Acquire(SEIDR.ThreadManaging.Lock,System.Boolean,System.Boolean)">
            <summary>
            Try to acquire a lock.
            <para>
            An exception will be thrown if you try to acquire a lock on a lock manager that already has a lock, unless moving to a higher lock level.
            </para>
            <remarks>
            If you try to acquire Lock.Unlocked, this will simply Release any lock the lock manager might have.
            </remarks>
            </summary>
            <param name="level"></param>
            <param name="safe">Returns immediately instead of throwing LockManagerExceptions if Parameter validation fails, or if the LockManager instance is already trying to acquire a lock.
            <para>Does not stop errors thrown as a result of another thread calling dispose on the LockManager while it's trying to dispose.</para></param>
            <param name="timeoutSafe">If true, returns false instead of throwing TimeOutExceptions for Exclusive and Exclusive Intent</param>
            <returns>True if lock is successfully acquired.</returns>
        </member>
        <member name="T:SEIDR.ThreadManaging.LockManagerException">
            <summary>
            Lock Manager Exception. Thrown by the lock manager when there's an issue with a lock trying to be acquired.
            </summary>
        </member>
        <member name="T:SEIDR.ThreadManaging.LockManagerSynchronizationException">
            <summary>
            Thrown by Lock Manager when the calling method's threadID does not match the threadID that acquired the current lock
            </summary>
        </member>
        <member name="M:SEIDR.ThreadManaging.LockMangerExtensions.Wait``1(``0,System.String,System.Int32)">
            <summary>
            Blocks thread until there isn't a thread attempting to access the target, 
            </summary>
            <typeparam name="RT"></typeparam>
            <param name="obj">Used together with Alias (if provided) to determine the target, using <see cref="M:SEIDR.ThreadManaging.LockHelper`1.CheckTarget(System.String)"/></param>
            <param name="Alias"></param>
            <param name="timeout"></param>
        </member>
        <member name="T:SEIDR.ThreadManaging.MultiLockHelper`1">
            <summary>
            Aid for helping with multiple locks concurrently, when the individual locks are managed by <see cref="T:SEIDR.ThreadManaging.LockHelper`1"/> instances.
            </summary>
            <typeparam name="RT"></typeparam>
        </member>
        <member name="M:SEIDR.ThreadManaging.MultiLockHelper`1.#ctor(System.Collections.Generic.IEnumerable{System.String},SEIDR.ThreadManaging.Lock,System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="targetAliasList">A list of aliases used in combination with the TypeName for determining target. Used with <see cref="M:SEIDR.ThreadManaging.LockHelper`1.CheckTarget(System.String)"/></param>
            <param name="lockTarget"></param>
            <param name="exclusiveTimeout"></param>
            <param name="ExclusiveIntentTimeout"></param>
        </member>
        <member name="T:SEIDR.ThreadManaging.MultiLockHelper">
            <summary>
            Aid for helping with multiple locks concurrently. 
            <para>E.g., on a main thread which manages a list of child threads and needs to lock for a target from each thread
            </para>
            </summary>
        </member>
        <member name="M:SEIDR.ThreadManaging.MultiLockHelper.#ctor(System.Collections.Generic.IEnumerable{System.String},System.Int32,System.Int32)">
            <summary>
            Helper wrapper for concurrently managing multiple locks that should share target access level.
            <para>Note: will throw an argument exception if targets are not unique</para>
            <para>Will intialize as NoLock (effectively unlocked).</para>
            </summary>
            <param name="targetList"></param>
            <param name="exclusiveTimeout"></param>
            <param name="ExclusiveIntentTimeout"></param>
        </member>
        <member name="M:SEIDR.ThreadManaging.MultiLockHelper.#ctor(SEIDR.ThreadManaging.Lock,System.Collections.Generic.IEnumerable{System.String},System.Int32,System.Int32)">
            <summary>
            Helper wrapper for concurrently managing multiple locks that should share target access level.
            <para>Note: will throw an argument exception if targets are not unique</para>
            </summary>
            <param name="targetLock"></param>
            <param name="targetList"></param>
            <param name="exclusiveTimeout"></param>
            <param name="ExclusiveIntentTimeout"></param>
        </member>
        <member name="P:SEIDR.ThreadManaging.MultiLockHelper.Item(System.String)">
            <summary>
            Get the lock helper for the specified target
            </summary>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.ThreadManaging.MultiLockHelper.SetExclusiveTimeout(System.Int32)">
            <summary>
            Updates the timeLimit for acquiring <see cref="F:SEIDR.ThreadManaging.Lock.Exclusive"/>. Set to 0 to remove the limit
            </summary>
            <param name="newTimeout"></param>
        </member>
        <member name="M:SEIDR.ThreadManaging.MultiLockHelper.SetExclusiveIntentTimeout(System.Int32)">
            <summary>
            Updates the timeLimit for acquiring <see cref="F:SEIDR.ThreadManaging.Lock.Exclusive_Intent"/>. Set to 0 to remove the limit
            </summary>
            <param name="newTimeout"></param>
        </member>
        <member name="M:SEIDR.ThreadManaging.MultiLockHelper.Transition(SEIDR.ThreadManaging.Lock,System.Boolean)">
            <summary>
            Attempts to transition all locks.
            </summary>
            <param name="target"></param>
            <param name="skipFail"></param>
            <returns>True if all locks were able to transition. False if any did not reach the indicated target level.</returns>
        </member>
        <member name="M:SEIDR.ThreadManaging.MultiLockHelper.Release">
            <summary>
            Release all lockHelpers
            </summary>
        </member>
        <member name="T:SEIDR.UserFriendlyDateRegex">
            <summary>
            Date Regex logic for simple conversion of friendly date regex to replace the information with the provided date information
            </summary>
        </member>
        <member name="M:SEIDR.UserFriendlyDateRegex.Eval(System.String,System.Nullable{System.DateTime})">
            <summary>
            Used for evaluating a style of user friendly date variable, where month, day, and/or year are represented by letters within ankle brackets.        
            <para>Might be useful somewhere. Does not handle offsets</para>
            </summary>
            <param name="s"></param>
            <param name="Evaluation">Use current date if not provided</param>
            <returns></returns>
        </member>
    </members>
</doc>
